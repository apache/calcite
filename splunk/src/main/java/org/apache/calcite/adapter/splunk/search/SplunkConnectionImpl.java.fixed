/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.calcite.adapter.splunk.search;

import org.apache.calcite.adapter.splunk.util.StringUtils;
import org.apache.calcite.linq4j.Enumerator;
import org.apache.calcite.linq4j.Linq4j;
import org.apache.calcite.util.Unsafe;
import org.apache.calcite.util.Util;

import au.com.bytecode.opencsv.CSVReader;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import static org.apache.calcite.runtime.HttpUtils.appendURLEncodedArgs;
import static org.apache.calcite.runtime.HttpUtils.post;

import static java.util.Objects.requireNonNull;

/**
 * Implementation of {@link SplunkConnection} based on Splunk's REST API.
 * Enhanced to support "_extra" field collection for CIM models, configurable SSL validation,
 * and automatic 401 retry with re-authentication.
 * Uses JSON output for simpler and more reliable data processing.
 */
public class SplunkConnectionImpl implements SplunkConnection {
  private static final Logger LOGGER =
      LoggerFactory.getLogger(SplunkConnectionImpl.class);

  private static final Pattern SESSION_KEY =
      Pattern.compile(
          "<sessionKey>([0-9a-zA-Z^_]+)</sessionKey>");

  // Authentication retry configuration
  private static final int MAX_RETRY_ATTEMPTS = 1;
  private static final String AUTH_ERROR_INDICATOR = "401";

  final URL url;
  final String username;
  final String password;
  final String token;
  final boolean disableSslValidation;
  final boolean useTokenAuth;

  // Mutable authentication state
  private String sessionKey = "";
  private final Map<String, String> requestHeaders = new HashMap<>();
  private final Object authLock = new Object(); // For thread-safe re-authentication

  public SplunkConnectionImpl(String url, String username, String password)
      throws MalformedURLException {
    this(url, username, password, false);
  }

  public SplunkConnectionImpl(String url, String username, String password,
          boolean disableSslValidation)
      throws MalformedURLException {
    this(URI.create(url).toURL(), username, password, disableSslValidation);
  }

  public SplunkConnectionImpl(URL url, String username, String password) {
    this(url, username, password, false);
  }

  public SplunkConnectionImpl(URL url, String username, String password,
          boolean disableSslValidation) {
    this.url = requireNonNull(url, "url cannot be null");
    this.username = requireNonNull(username, "username cannot be null");
    this.password = requireNonNull(password, "password cannot be null");
    this.token = null;
    this.useTokenAuth = false;
    this.disableSslValidation = disableSslValidation;

    if (disableSslValidation) {
      configureSSL();
    }
    connect();
  }

  /**
   * Constructor for token-based authentication.
   */
  public SplunkConnectionImpl(String url, String token) throws MalformedURLException {
    this(url, token, false);
  }

  /**
   * Constructor for token-based authentication with SSL configuration.
   */
  public SplunkConnectionImpl(String url, String token, boolean disableSslValidation) throws MalformedURLException {
    this(URI.create(url).toURL(), token, disableSslValidation);
  }

  /**
   * Constructor for token-based authentication.
   */
  public SplunkConnectionImpl(URL url, String token) {
    this(url, token, false);
  }

  /**
   * Constructor for token-based authentication with SSL configuration.
   */
  public SplunkConnectionImpl(URL url, String token, boolean disableSslValidation) {
    this.url = requireNonNull(url, "url cannot be null");
    this.token = requireNonNull(token, "token cannot be null");
    this.username = null;
    this.password = null;
    this.useTokenAuth = true;
    this.disableSslValidation = disableSslValidation;

    if (disableSslValidation) {
      configureSSL();
    }

    // For token auth, set authorization header directly and skip connect()
    synchronized (authLock) {
      requestHeaders.put("Authorization", "Bearer " + token);
    }
  }

  /**
   * Configure SSL settings for this connection.
   * WARNING: disableSslValidation should only be used in development/testing.
   */
  private void configureSSL() {
    if (!disableSslValidation) {
      return;
    }

    try {
      // Create a trust manager that accepts all certificates
      TrustManager[] trustAllCerts = new TrustManager[]{
          new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
              return null;
            }

            public void checkClientTrusted(X509Certificate[] certs, String authType) {
              // Trust all client certificates
            }

            public void checkServerTrusted(X509Certificate[] certs, String authType) {
              // Trust all server certificates
            }
          }
      };

      // Install the all-trusting trust manager
      SSLContext sc = SSLContext.getInstance("SSL");
      sc.init(null, trustAllCerts, new java.security.SecureRandom());
      HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

      // Disable hostname verification
      HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);

      LOGGER.warn("SSL certificate validation has been disabled. This should only be used in " +
              "development/testing environments.");

    } catch (Exception e) {
      throw new RuntimeException("Failed to configure SSL settings", e);
    }
  }

  private static void close(Closeable c) {
    try {
      c.close();
    } catch (Exception ignore) {
      // ignore
    }
  }

  /**
   * Performs authentication for username/password based connections.
   * Can be called multiple times to re-authenticate on session expiry.
   */
  @SuppressWarnings("CatchAndPrintStackTrace")
  private void connect() {
    if (useTokenAuth) {
      LOGGER.debug("Skipping connect() for token-based authentication");
      return;
    }

    synchronized (authLock) {
      BufferedReader rd = null;

      try {
        String loginUrl =
            String.format(Locale.ROOT,
                "%s://%s:%d/services/auth/login",
                url.getProtocol(),
                url.getHost(),
                url.getPort());

        StringBuilder data = new StringBuilder();
        appendURLEncodedArgs(
            data, "username", username, "password", password);

        LOGGER.info("Attempting to authenticate to Splunk at: {}", loginUrl);

        // Create a temporary header map for authentication (don't include stale session)
        Map<String, String> authHeaders = new HashMap<>();

        rd = Util.reader(post(loginUrl, data, authHeaders));

        String line;
        StringBuilder reply = new StringBuilder();
        while ((line = rd.readLine()) != null) {
          reply.append(line);
          reply.append("\n");
        }

        Matcher m = SESSION_KEY.matcher(reply);
        if (m.find()) {
          sessionKey = m.group(1);
          requestHeaders.clear(); // Clear any old headers
          requestHeaders.put("Authorization", "Splunk " + sessionKey);
          LOGGER.info("Successfully authenticated to Splunk, received session key");
        } else {
          LOGGER.error("Failed to extract session key from authentication response");
          LOGGER.debug("Authentication response: {}", reply.toString());
          throw new RuntimeException("Authentication failed - no session key found in response");
        }
      } catch (java.net.SocketTimeoutException e) {
        String errorMsg = String.format("Connection to Splunk timed out. Please verify:\n"
  +
                "1. Splunk URL is correct: %s\n"
  +
                "2. Splunk server is running and accessible\n"
  +
                "3. Network connectivity allows access to port %d\n"
  +
                "4. No firewall is blocking the connection",
            url.toString(), url.getPort());
        LOGGER.error("Connection timeout during authentication: {}", errorMsg);
        throw new RuntimeException("Splunk connection timeout: " + errorMsg, e);
      } catch (java.net.ConnectException e) {
        String errorMsg = String.format("Cannot connect to Splunk server. Please verify:\n"
  +
                "1. Splunk URL is correct: %s\n"
  +
                "2. Splunk server is running\n"
  +
                "3. Splunk REST API is enabled\n"
  +
                "4. Port %d is accessible",
            url.toString(), url.getPort());
        LOGGER.error("Connection refused during authentication: {}", errorMsg);
        throw new RuntimeException("Splunk connection refused: " + errorMsg, e);
      } catch (java.net.UnknownHostException e) {
        String errorMsg = String.format("Cannot resolve Splunk hostname: %s\n"
  +
            "Please verify the hostname/IP address is correct", url.getHost());
        LOGGER.error("DNS resolution failed during authentication: {}", errorMsg);
        throw new RuntimeException("Splunk hostname resolution failed: " + errorMsg, e);
      } catch (javax.net.ssl.SSLException e) {
        String errorMsg = String.format("SSL connection failed to Splunk server: %s\n"
  +
                "Consider setting SPLUNK_DISABLE_SSL_VALIDATION=true for development/testing",
            url.toString());
        LOGGER.error("SSL error during authentication: {}", errorMsg);
        throw new RuntimeException("Splunk SSL connection failed: " + errorMsg, e);
      } catch (Exception e) {
        LOGGER.error("Authentication failed with unexpected error", e);
        throw new RuntimeException("Failed to authenticate to Splunk: " + e.getMessage(), e);
      } finally {
        if (rd != null) {
          close(rd);
        }
      }
    }
  }

  /**
   * Checks if an exception indicates an HTTP 401 authentication error specifically.
   * More conservative than the general isAuthenticationError method.
   * Package-private for access by SplunkJsonResultEnumeratorWithRetry.
   */
  boolean isHttpAuthenticationError(Throwable e) {
    if (e == null) {
      return false;
    }

    // Network connectivity issues are definitely NOT authentication errors
    if (e instanceof java.net.SocketTimeoutException ||
        e instanceof java.net.ConnectException ||
        e instanceof java.net.UnknownHostException ||
        e instanceof javax.net.ssl.SSLException) {
      return false;
    }

    // Look for HTTP 401 in the message
    String message = e.getMessage();
    if (message != null && (message.contains("401") || message.contains("Unauthorized"))) {
      return true;
    }

    // FIXED: Also check for IOException with HTTP 401 response code
    if (e instanceof java.io.IOException) {
      String ioMessage = e.getMessage();
      if (ioMessage != null && ioMessage.contains("Server returned HTTP response code: 401")) {
        return true;
      }
    }
    // Check cause chain but be conservative
    Throwable cause = e.getCause();
    while (cause != null) {
      // Network issues in the cause chain are NOT auth errors
      if (cause instanceof java.net.SocketTimeoutException ||
          cause instanceof java.net.ConnectException ||
          cause instanceof java.net.UnknownHostException ||
          cause instanceof javax.net.ssl.SSLException) {
        return false;
      }

      String causeMessage = cause.getMessage();
      if (causeMessage != null && (
          causeMessage.contains("401") || causeMessage.contains(
              "Unauthorized"))) {
        return true;
      }

      // FIXED: Check IOException in cause chain too
      if (cause instanceof java.io.IOException) {
        String causeIoMessage = cause.getMessage();
        if (causeIoMessage != null && causeIoMessage.contains("Server returned HTTP response " +
                "code: 401")) {
          return true;
        }
      }

      cause = cause.getCause();
    }

    return false;
  }

  /**
   * Re-authenticates the connection based on the authentication method.
   */
  private void reAuthenticate() {
    LOGGER.info("Re-authenticating Splunk connection due to session expiry");

    if (useTokenAuth) {
      // For token auth, we can't refresh the token automatically
      // Just reset the header - the token might have been refreshed externally
      synchronized (authLock) {
        requestHeaders.clear();
        requestHeaders.put("Authorization", "Bearer " + token);
      }
      LOGGER.info("Reset token authorization header");
    } else {
      // For username/password auth, get a new session
      connect();
      LOGGER.info("Successfully re-authenticated with new session key");
    }
  }

  /**
   * Checks if an exception indicates an HTTP 401 authentication error specifically.
   * More conservative than the general isAuthenticationError method.
   * Package-private for access by SplunkJsonResultEnumeratorWithRetry.
   */

  /**
   * Re-authenticates the connection based on the authentication method.
   */

  @Override public void getSearchResults(String search, Map<String, String> otherArgs,
      List<String> fieldList, SearchResultListener srl) {
    requireNonNull(srl, "SearchResultListener cannot be null");
    performSearchWithRetry(search, otherArgs, srl);
  }

  @Override public Enumerator<Object> getSearchResultEnumerator(String search,
      Map<String, String> otherArgs, List<String> fieldList, Set<String> explicitFields) {
    return getSearchResultEnumerator(search, otherArgs, fieldList, explicitFields, new HashMap<>());
  }

  @Override public Enumerator<Object> getSearchResultEnumerator(String search,
      Map<String, String> otherArgs, List<String> fieldList, Set<String> explicitFields,
      Map<String, String> reverseFieldMapping) {
    return performSearchForEnumeratorWithRetry(search, otherArgs, fieldList, explicitFields,
            reverseFieldMapping);
  }

  /**
   * Performs search with automatic retry on authentication failure.
   */
  private void performSearchWithRetry(String search, Map<String, String> otherArgs,
          SearchResultListener srl) {
    Exception lastException = null;

    for (int attempt = 0; attempt <= MAX_RETRY_ATTEMPTS; attempt++) {
      try {
        performSearch(search, otherArgs, srl);
        return; // Success
      } catch (Exception e) {
        lastException = e;

        // Only retry on actual authentication errors, not network issues
        if (isHttpAuthenticationError(e) && attempt < MAX_RETRY_ATTEMPTS) {
          LOGGER.warn("HTTP 401 authentication error detected on attempt {}, retrying...",
                  attempt + 1);
          try {
            reAuthenticate();
          } catch (Exception authException) {
            LOGGER.error("Re-authentication failed", authException);
            break; // Don't retry if re-auth fails
          }
        } else {
          break; // Non-auth error or max retries reached
        }
      }
    }

    // If we get here, all retries failed
    StringWriter sw = new StringWriter();
    if (lastException != null) {
      lastException.printStackTrace(new PrintWriter(sw));
      LOGGER.error("Search failed after {} attempts: {}\n{}",
          MAX_RETRY_ATTEMPTS + 1, lastException.getMessage(), sw);
    }
  }

  /**
   * Performs search for enumerator with automatic retry on authentication failure.
   */
  private Enumerator<Object> performSearchForEnumeratorWithRetry(
      String search,
      Map<String, String> otherArgs,
      List<String> schemaFieldList,
      Set<String> explicitFields,
      Map<String, String> reverseFieldMapping) {

    Exception lastException = null;

    for (int attempt = 0; attempt <= MAX_RETRY_ATTEMPTS; attempt++) {
      try {
        return performSearchForEnumerator(search, otherArgs, schemaFieldList, explicitFields,
                reverseFieldMapping);
      } catch (Exception e) {
        lastException = e;

        // Only retry on actual authentication errors, not network issues
        if (isHttpAuthenticationError(e) && attempt < MAX_RETRY_ATTEMPTS) {
          LOGGER.warn("HTTP 401 authentication error detected on attempt {}, retrying...",
                  attempt + 1);
          try {
            reAuthenticate();
          } catch (Exception authException) {
            LOGGER.error("Re-authentication failed", authException);
            break; // Don't retry if re-auth fails
          }
        } else {
          break; // Non-auth error or max retries reached
        }
      }
    }

    // If we get here, all retries failed
    StringWriter sw = new StringWriter();
    if (lastException != null) {
      lastException.printStackTrace(new PrintWriter(sw));
      LOGGER.error("Search enumerator failed after {} attempts: {}\n{}",
          MAX_RETRY_ATTEMPTS + 1, lastException.getMessage(), sw);
    }

    return Linq4j.emptyEnumerator();
  }

  private void performSearch(
      String search,
      Map<String, String> otherArgs,
      SearchResultListener srl) {
    String searchUrl =
        String.format(Locale.ROOT,
            "%s://%s:%d/services/search/jobs/export",
            url.getProtocol(),
            url.getHost(),
            url.getPort());

    StringBuilder data = new StringBuilder();
    Map<String, String> args = new LinkedHashMap<>(otherArgs);
    args.put("search", search);
    // override these args
    args.put("output_mode", "csv");
    args.put("preview", "0");

    // TODO: remove this once the csv parser can handle leading spaces
    args.put("check_connection", "0");

    appendURLEncodedArgs(data, args);

    // Use synchronized access to headers to ensure thread safety
    Map<String, String> headersToUse;
    synchronized (authLock) {
      headersToUse = new HashMap<>(requestHeaders);
    }

    try {
      // wait at most 30 minutes for first result
      InputStream in = post(searchUrl, data, headersToUse, 10000, 1800000);
      parseResults(in, srl);
    } catch (Exception e) {
      throw new RuntimeException("Search request failed: " + e.getMessage(), e);
    }
  }

  private Enumerator<Object> performSearchForEnumerator(
      String search,
      Map<String, String> otherArgs,
      List<String> schemaFieldList,
      Set<String> explicitFields,
      Map<String, String> reverseFieldMapping) {
    String searchUrl =
        String.format(Locale.ROOT,
            "%s://%s:%d/services/search/jobs/export",
            url.getProtocol(),
            url.getHost(),
            url.getPort());

    StringBuilder data = new StringBuilder();
    Map<String, String> args = new LinkedHashMap<>(otherArgs);
    args.put("search", search);

    args.put("output_mode", "json");
    args.put("preview", "0");
    args.put("check_connection", "0");

    LOGGER.debug("=== SPLUNK SEARCH DEBUG ===");
    LOGGER.debug("Search URL: {}", searchUrl);
    LOGGER.debug("Search query: {}", search);
    LOGGER.debug("All search args: {}", args);
    LOGGER.debug("=== END SPLUNK SEARCH DEBUG ===");

    appendURLEncodedArgs(data, args);

    Map<String, String> headersToUse;
    synchronized (authLock) {
      headersToUse = new HashMap<>(requestHeaders);
    }

    try {
      // wait at most 30 minutes for first result
      InputStream in = post(searchUrl, data, headersToUse, 10000, 1800000);
      return new SplunkJsonResultEnumeratorWithRetry(in, schemaFieldList, explicitFields, reverseFieldMapping, this);
    } catch (Exception e) {
      throw new RuntimeException("Search request failed: " + e.getMessage(), e);
    }
  }

