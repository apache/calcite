# new-decorr.iq
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This is used to test for bugs associated with new decorrelator.
# Most of the test cases here come from the .iq file removed in CoreQuidemTest2.
# This file maybe can be deleted after these .iq files are made available.

!use post
!set outputformat mysql

# [CALCITE-7372] TopDownGeneralDecorrelator will throw an error when the JOIN condition has correlation
# This case comes from sub-query.iq [CALCITE-7257]
WITH t0(t0a, t0b) AS (VALUES (1, 1), (2, 0)),
     t1(t1a, t1b, t1c) AS (VALUES (1, 1, 3)),
     t2(t2a, t2b, t2c) AS (VALUES (1, 1, 5), (2, 2, 7))
SELECT * FROM t0 WHERE t0a <
(SELECT sum(t1c) FROM
  (SELECT t1c
   FROM   t1 JOIN t2 ON (t1a < t0a AND t2b >= t1b))
);
+-----+-----+
| T0A | T0B |
+-----+-----+
|   2 |   0 |
+-----+-----+
(1 row)

!ok

# [CALCITE-7356] The MARK JOIN generated by TopDownGeneralDecorrelator needs to be adapted to RelFieldTrimmer
!use blank
CREATE TABLE emps (
  empid INTEGER NOT NULL,
  deptno INTEGER NOT NULL,
  name VARCHAR(10) NOT NULL,
  salary DECIMAL(10, 2) NOT NULL,
  commission INTEGER);
(0 rows modified)

!update

INSERT INTO emps (empid, deptno, name, salary, commission) VALUES
(100, 10, 'Bill', 10000.00, 1000),
(200, 20, 'Eric', 8000.00, 500),
(150, 10, 'Sebastian', 7000.00, NULL),
(110, 10, 'Theodore', 11500.00, 250),
(170, 30, 'Theodore', 11500.00, 250),
(140, 10, 'Sebastian', 7000.00, NULL);
(6 rows modified)

!update

SELECT empid, EXISTS(select * from (
  SELECT e2.deptno FROM emps e2 where e1.commission = e2.commission) as table3
  where table3.deptno <> e1.deptno)
from emps e1 order by empid;
+-------+--------+
| EMPID | EXPR$1 |
+-------+--------+
|   100 | false  |
|   110 | true   |
|   140 | false  |
|   150 | false  |
|   170 | true   |
|   200 | false  |
+-------+--------+
(6 rows)

!ok

!if (use_new_decorr) {
EnumerableSort(sort0=[$0], dir0=[ASC])
  EnumerableCalc(expr#0..3=[{inputs}], EMPID=[$t0], EXPR$1=[$t3])
    EnumerableHashJoin(condition=[AND(IS NOT DISTINCT FROM($1, $3), IS NOT DISTINCT FROM($2, $4))], joinType=[left_mark])
      EnumerableCalc(expr#0..4=[{inputs}], proj#0..1=[{exprs}], COMMISSION=[$t4])
        EnumerableTableScan(table=[[BLANK, EMPS]])
      EnumerableCalc(expr#0..3=[{inputs}], proj#0..1=[{exprs}])
        EnumerableHashJoin(condition=[AND(=($1, $3), <>($2, $0))], joinType=[inner])
          EnumerableAggregate(group=[{1, 4}])
            EnumerableTableScan(table=[[BLANK, EMPS]])
          EnumerableCalc(expr#0..4=[{inputs}], DEPTNO=[$t1], COMMISSION=[$t4])
            EnumerableTableScan(table=[[BLANK, EMPS]])
!plan
!}

# [CALCITE-7382] The TopDownGeneralDecorrelator returns an error result when a subquery contains a LIMIT 1
# This case comes from sub-query.iq [CALCITE-6652]
!use scott
SELECT dname, (SELECT emp.comm FROM "scott".emp WHERE dept.deptno = emp.deptno ORDER BY emp.comm LIMIT 1) FROM "scott".dept;
+------------+--------+
| DNAME      | EXPR$1 |
+------------+--------+
| ACCOUNTING |        |
| OPERATIONS |        |
| RESEARCH   |        |
| SALES      |   0.00 |
+------------+--------+
(4 rows)

!ok

SELECT dname, (SELECT empno FROM emp WHERE dept.deptno = emp.deptno LIMIT 1) FROM dept WHERE deptno = 10;
+------------+--------+
| DNAME      | EXPR$1 |
+------------+--------+
| ACCOUNTING |   7782 |
+------------+--------+
(1 row)

!ok

# [CALCITE-7389] PruneJoinSingleValue rule causes type mismatch in EXISTS
!use scott
select count(*) as c from "scott".dept where exists (select 1);
+---+
| C |
+---+
| 4 |
+---+
(1 row)

!ok

EnumerableAggregate(group=[{}], C=[COUNT()])
  EnumerableTableScan(table=[[scott, DEPT]])
!plan

select empno, deptno in (select 10) from emp;
+-------+--------+
| EMPNO | EXPR$1 |
+-------+--------+
|  7782 | true   |
|  7839 | true   |
|  7934 | true   |
|  7369 | false  |
|  7499 | false  |
|  7521 | false  |
|  7566 | false  |
|  7654 | false  |
|  7698 | false  |
|  7788 | false  |
|  7844 | false  |
|  7876 | false  |
|  7900 | false  |
|  7902 | false  |
+-------+--------+
(14 rows)

!ok

!if (use_new_decorr) {
EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t7):INTEGER], expr#9=[10], expr#10=[=($t8, $t9)], EMPNO=[$t0], EXPR$1=[$t10])
  EnumerableTableScan(table=[[scott, EMP]])
!plan
!}

# This case comes from scalar.iq [CALCITE-709]
# Aggregate functions do not support type promotion, so a cast is added to pass the test.
select deptno, (select sum(cast(empno as bigint)) from "scott".emp where deptno = dept.deptno limit 0) as x from "scott".dept;
+--------+---+
| DEPTNO | X |
+--------+---+
|     10 |   |
|     20 |   |
|     30 |   |
|     40 |   |
+--------+---+
(4 rows)

!ok

!if (use_old_decorr) {
EnumerableCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{0}])
  EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
    EnumerableTableScan(table=[[scott, DEPT]])
  EnumerableValues(tuples=[[]])
!plan
!}

!if (use_new_decorr) {
EnumerableCalc(expr#0..3=[{inputs}], DEPTNO=[$t0], EXPR$0=[$t2])
  EnumerableHashJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[0], expr#4=[<=($t2, $t3)], proj#0..2=[{exprs}], $condition=[$t4])
      EnumerableWindow(window#0=[window(partition {0} rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])
        EnumerableAggregate(group=[{1}], EXPR$0=[$SUM0($0)])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t0):BIGINT NOT NULL], expr#9=[IS NOT NULL($t7)], EMPNO=[$t8], DEPTNO=[$t7], $condition=[$t9])
            EnumerableTableScan(table=[[scott, EMP]])
!plan
!}

# [CALCITE-7403] Missing ENUMERABLE Convention for LogicalConditionalCorrelate
# This case comes from some.iq [CALCITE-6786]
WITH tb as (select array(SELECT * FROM (VALUES (TRUE), (NULL)) as x(a)) as a)
SELECT TRUE IN (SELECT b FROM UNNEST(a) AS x1(b)) AS test FROM tb;
+------+
| TEST |
+------+
| true |
+------+
(1 row)

!ok

!if (use_new_decorr) {
EnumerableCalc(expr#0..1=[{inputs}], TEST=[$t1])
  EnumerableConditionalCorrelate(correlation=[$cor0], joinType=[left_mark], requiredColumns=[{0}], condition=[$1])
    EnumerableCollect(field=[x])
      EnumerableValues(tuples=[[{ true }, { null }]])
    EnumerableUncollect
      EnumerableCalc(expr#0=[{inputs}], expr#1=[$cor0], expr#2=[$t1.A], A=[$t2])
        EnumerableValues(tuples=[[{ 0 }]])
!plan
!}

# [CALCITE-7396] PruneEmptyRules does not support LEFT_MARK JOIN
# This case comes from sub-query.iq
!use post
select * from dept where deptno not in (select deptno from emp where false);
+--------+-------------+
| DEPTNO | DNAME       |
+--------+-------------+
|     10 | Sales       |
|     20 | Marketing   |
|     30 | Engineering |
|     40 | Empty       |
+--------+-------------+
(4 rows)

!ok
EnumerableValues(tuples=[[{ 10, 'Sales      ' }, { 20, 'Marketing  ' }, { 30, 'Engineering' }, { 40, 'Empty      ' }]])
!plan

# [CALCITE-7400] PruneJoinSingleValue rule causes type mismatch in IN
# This case comes from sub-query.iq [CALCITE-4756]
select 1 in (values(null), (null));
+--------+
| EXPR$0 |
+--------+
|        |
+--------+
(1 row)

!ok

# [CALCITE-7401] Multi-level correlated subqueries cause an out-of-range error in the TopDownGeneralDecorrelator
# This case comes from sub-query.iq [CALCITE-5789]
select deptno from dept d1 where exists (
 select 1 from dept d2 where d2.deptno = d1.deptno and exists (
  select 1 from dept d3 where d3.deptno = d2.deptno and d3.dname = d1.dname));
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
|     40 |
+--------+
(4 rows)

!ok

# [CALCITE-7402] Two-level nested correlated subquery causes TopDownGeneralDecorrelator type mismatch during translation
# This case comes from sub-query.iq [CALCITE-5716]
!use scott
SELECT dept.deptno, (
  SELECT max(emp.empno)
  FROM emp
  WHERE empno = (SELECT max(empno) AS maxDept
                 FROM emp e2
                 WHERE e2.deptno = dept.deptno)
        AND emp.deptno = dept.deptno),
  dept.dname
FROM dept;
+--------+--------+------------+
| DEPTNO | EXPR$1 | DNAME      |
+--------+--------+------------+
|     10 |   7934 | ACCOUNTING |
|     20 |   7902 | RESEARCH   |
|     30 |   7900 | SALES      |
|     40 |        | OPERATIONS |
+--------+--------+------------+
(4 rows)

!ok

# End new-decorr.iq
