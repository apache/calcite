# new-decorr.iq
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This is used to test for bugs associated with new decorrelator.
# Most of the test cases here come from the .iq file removed in CoreQuidemTest2.
# This file maybe can be deleted after these .iq files are made available.

!use post
!set outputformat mysql

# [CALCITE-7372] TopDownGeneralDecorrelator will throw an error when the JOIN condition has correlation
# This case comes from sub-query.iq [CALCITE-7257]
WITH t0(t0a, t0b) AS (VALUES (1, 1), (2, 0)),
     t1(t1a, t1b, t1c) AS (VALUES (1, 1, 3)),
     t2(t2a, t2b, t2c) AS (VALUES (1, 1, 5), (2, 2, 7))
SELECT * FROM t0 WHERE t0a <
(SELECT sum(t1c) FROM
  (SELECT t1c
   FROM   t1 JOIN t2 ON (t1a < t0a AND t2b >= t1b))
);
+-----+-----+
| T0A | T0B |
+-----+-----+
|   2 |   0 |
+-----+-----+
(1 row)

!ok

# [CALCITE-7356] The MARK JOIN generated by TopDownGeneralDecorrelator needs to be adapted to RelFieldTrimmer
!use blank
CREATE TABLE emps (
  empid INTEGER NOT NULL,
  deptno INTEGER NOT NULL,
  name VARCHAR(10) NOT NULL,
  salary DECIMAL(10, 2) NOT NULL,
  commission INTEGER);
(0 rows modified)

!update

INSERT INTO emps (empid, deptno, name, salary, commission) VALUES
(100, 10, 'Bill', 10000.00, 1000),
(200, 20, 'Eric', 8000.00, 500),
(150, 10, 'Sebastian', 7000.00, NULL),
(110, 10, 'Theodore', 11500.00, 250),
(170, 30, 'Theodore', 11500.00, 250),
(140, 10, 'Sebastian', 7000.00, NULL);
(6 rows modified)

!update

SELECT empid, EXISTS(select * from (
  SELECT e2.deptno FROM emps e2 where e1.commission = e2.commission) as table3
  where table3.deptno <> e1.deptno)
from emps e1 order by empid;
+-------+--------+
| EMPID | EXPR$1 |
+-------+--------+
|   100 | false  |
|   110 | true   |
|   140 | false  |
|   150 | false  |
|   170 | true   |
|   200 | false  |
+-------+--------+
(6 rows)

!ok

!if (use_new_decorr) {
EnumerableSort(sort0=[$0], dir0=[ASC])
  EnumerableCalc(expr#0..3=[{inputs}], EMPID=[$t0], EXPR$1=[$t3])
    EnumerableHashJoin(condition=[AND(IS NOT DISTINCT FROM($1, $3), IS NOT DISTINCT FROM($2, $4))], joinType=[left_mark])
      EnumerableCalc(expr#0..4=[{inputs}], proj#0..1=[{exprs}], COMMISSION=[$t4])
        EnumerableTableScan(table=[[BLANK, EMPS]])
      EnumerableCalc(expr#0..3=[{inputs}], proj#0..1=[{exprs}])
        EnumerableHashJoin(condition=[AND(=($1, $3), <>($2, $0))], joinType=[inner])
          EnumerableAggregate(group=[{1, 4}])
            EnumerableTableScan(table=[[BLANK, EMPS]])
          EnumerableCalc(expr#0..4=[{inputs}], DEPTNO=[$t1], COMMISSION=[$t4])
            EnumerableTableScan(table=[[BLANK, EMPS]])
!plan
!}

# [CALCITE-7382] The TopDownGeneralDecorrelator returns an error result when a subquery contains a LIMIT 1
# This case comes from sub-query.iq [CALCITE-6652]
!use scott
SELECT dname, (SELECT emp.comm FROM "scott".emp WHERE dept.deptno = emp.deptno ORDER BY emp.comm LIMIT 1) FROM "scott".dept;
+------------+--------+
| DNAME      | EXPR$1 |
+------------+--------+
| ACCOUNTING |        |
| OPERATIONS |        |
| RESEARCH   |        |
| SALES      |   0.00 |
+------------+--------+
(4 rows)

!ok

SELECT dname, (SELECT empno FROM emp WHERE dept.deptno = emp.deptno LIMIT 1) FROM dept WHERE deptno = 10;
+------------+--------+
| DNAME      | EXPR$1 |
+------------+--------+
| ACCOUNTING |   7782 |
+------------+--------+
(1 row)

!ok

# [CALCITE-7389] PruneJoinSingleValue rule causes type mismatch in EXISTS
!use scott
select count(*) as c from "scott".dept where exists (select 1);
+---+
| C |
+---+
| 4 |
+---+
(1 row)

!ok

EnumerableAggregate(group=[{}], C=[COUNT()])
  EnumerableTableScan(table=[[scott, DEPT]])
!plan

select empno, deptno in (select 10) from emp;
+-------+--------+
| EMPNO | EXPR$1 |
+-------+--------+
|  7782 | true   |
|  7839 | true   |
|  7934 | true   |
|  7369 | false  |
|  7499 | false  |
|  7521 | false  |
|  7566 | false  |
|  7654 | false  |
|  7698 | false  |
|  7788 | false  |
|  7844 | false  |
|  7876 | false  |
|  7900 | false  |
|  7902 | false  |
+-------+--------+
(14 rows)

!ok

!if (use_new_decorr) {
EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t7):INTEGER], expr#9=[10], expr#10=[=($t8, $t9)], EMPNO=[$t0], EXPR$1=[$t10])
  EnumerableTableScan(table=[[scott, EMP]])
!plan
!}

# End new-decorr.iq
