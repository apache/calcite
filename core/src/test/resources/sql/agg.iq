# agg.iq - Aggregate functions
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
!use post
!set outputformat mysql

# count(*) returns number of rows in table
select count(ename) as c from emp;
+---+
| C |
+---+
| 9 |
+---+
(1 row)

!ok

# count of not-nullable column same as count(*)
select count(ename) as c from emp;
+---+
| C |
+---+
| 9 |
+---+
(1 row)

!ok

# count of nullable column
select count(deptno) as c from emp;
+---+
| C |
+---+
| 8 |
+---+
(1 row)

!ok

# composite count
select count(deptno, ename, 1, deptno) as c from emp;
+---+
| C |
+---+
| 8 |
+---+
(1 row)

!ok

# DISTINCT and GROUP BY
select distinct deptno, count(*) as c from emp group by deptno;
+--------+---+
| DEPTNO | C |
+--------+---+
|     10 | 2 |
|     20 | 1 |
|     30 | 2 |
|     50 | 2 |
|     60 | 1 |
|        | 1 |
+--------+---+
(6 rows)

!ok

select distinct deptno from emp group by deptno;
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
|     50 |
|     60 |
|        |
+--------+
(6 rows)

!ok

select distinct count(*) as c from emp group by deptno;
+---+
| C |
+---+
| 1 |
| 2 |
+---+
(2 rows)

!ok

select distinct count(*) as c from emp group by deptno having count(*) > 1;
+---+
| C |
+---+
| 2 |
+---+
(1 row)

!ok

select distinct count(*) as c from emp group by deptno order by deptno desc;
Expression 'DEPTNO' is not in the select clause
!error

select distinct count(*) as c from emp group by deptno order by 1 desc;
+---+
| C |
+---+
| 2 |
| 1 |
+---+
(2 rows)

!ok

# [CALCITE-2192] RelBuilder wrongly skips creation of Aggregate that prunes
# columns if input is unique
select distinct deptno
from (select deptno, count(*) from emp group by deptno);
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
|     50 |
|     60 |
|        |
+--------+
(6 rows)

!ok

# [CALCITE-998] Exception when calling STDDEV_SAMP, STDDEV_POP
# stddev_samp
select stddev_samp(deptno) as s from emp;
+----+
| S  |
+----+
| 19 |
+----+
(1 row)

!ok

# stddev_pop
select stddev_pop(deptno) as s from emp;
+----+
| S  |
+----+
| 17 |
+----+
(1 row)

!ok

# stddev
select stddev(deptno) as s from emp;
+----+
| S  |
+----+
| 19 |
+----+
(1 row)

!ok

# both
select gender,
  stddev_pop(deptno) as p,
  stddev_samp(deptno) as s,
  stddev(deptno) as ss,
  count(deptno) as c
from emp
group by gender;
+--------+----+----+----+---+
| GENDER | P  | S  | SS | C |
+--------+----+----+----+---+
| F      | 17 | 19 | 19 | 5 |
| M      | 17 | 20 | 20 | 3 |
+--------+----+----+----+---+
(2 rows)

!ok

select city, gender as c from emps;
+---------------+---+
| CITY          | C |
+---------------+---+
| Vancouver     | F |
| San Francisco | M |
|               |   |
| Vancouver     | M |
|               | F |
+---------------+---+
(5 rows)

!ok

# SELECT DISTINCT includes fully and partially null rows
select distinct city, gender from emps;
+---------------+--------+
| CITY          | GENDER |
+---------------+--------+
|               |        |
| Vancouver     | M      |
|               | F      |
| San Francisco | M      |
| Vancouver     | F      |
+---------------+--------+
(5 rows)

!ok

# COUNT excludes fully or partially null rows
select count(city, gender) as c from emps;
+---+
| C |
+---+
| 3 |
+---+
(1 row)

!ok

# COUNT-DISTINCT excludes fully or partially null rows
select count(distinct city, gender) as c from emps;
+---+
| C |
+---+
| 3 |
+---+
(1 row)

!ok

select distinct mod(deptno, 20) as m, gender as c from emps;
+----+---+
| M  | C |
+----+---+
|  0 | F |
| 10 |   |
|  0 | M |
+----+---+
(3 rows)

!ok

# Partially null row (10, NULL) is excluded from count.
select count(distinct mod(deptno, 20), gender) as c from emps;
+---+
| C |
+---+
| 2 |
+---+
(1 row)

!ok

select count(mod(deptno, 20), gender) as c from emps;
+---+
| C |
+---+
| 4 |
+---+
(1 row)

!ok

# Nulls in GROUP BY
select x = 1 as x1, count(*) as c
from (values 0, 1, 2, cast(null as integer)) as t(x)
group by x = 1;
X1 BOOLEAN(1)
C BIGINT(19) NOT NULL
!type
+-------+---+
| X1    | C |
+-------+---+
| false | 2 |
| true  | 1 |
|       | 1 |
+-------+---+
(3 rows)

!ok

# Basic GROUPING SETS
select deptno, count(*) as c from emps group by grouping sets ((), (deptno));
+--------+---+
| DEPTNO | C |
+--------+---+
|     10 | 1 |
|     20 | 2 |
|     40 | 2 |
|        | 5 |
+--------+---+
(4 rows)

!ok

# GROUPING SETS on expression
select deptno + 1, count(*) as c from emps group by grouping sets ((), (deptno + 1));
+--------+---+
| EXPR$0 | C |
+--------+---+
|     11 | 1 |
|     21 | 2 |
|     41 | 2 |
|        | 5 |
+--------+---+
(4 rows)

!ok

# CUBE
select deptno + 1, count(*) as c from emp group by cube(deptno, gender);
+--------+---+
| EXPR$0 | C |
+--------+---+
|     11 | 1 |
|     11 | 1 |
|     11 | 2 |
|     21 | 1 |
|     21 | 1 |
|     31 | 2 |
|     31 | 2 |
|     51 | 1 |
|     51 | 1 |
|     51 | 2 |
|     61 | 1 |
|     61 | 1 |
|        | 1 |
|        | 1 |
|        | 3 |
|        | 6 |
|        | 9 |
+--------+---+
(17 rows)

!ok

# ROLLUP on 1 column
select deptno + 1, count(*) as c
from emp
group by rollup(deptno);
+--------+---+
| EXPR$0 | C |
+--------+---+
|     11 | 2 |
|     21 | 1 |
|     31 | 2 |
|     51 | 2 |
|     61 | 1 |
|        | 1 |
|        | 9 |
+--------+---+
(7 rows)

!ok

# ROLLUP on 2 columns; project columns in different order
select gender, deptno + 1, count(*) as c
from emp
group by rollup(deptno, gender);
+--------+--------+---+
| GENDER | EXPR$1 | C |
+--------+--------+---+
| M      |     21 | 1 |
| F      |     11 | 1 |
| F      |     31 | 2 |
| F      |     51 | 1 |
| F      |     61 | 1 |
| F      |        | 1 |
| M      |     11 | 1 |
| M      |     51 | 1 |
|        |     11 | 2 |
|        |     21 | 1 |
|        |     31 | 2 |
|        |     51 | 2 |
|        |     61 | 1 |
|        |        | 1 |
|        |        | 9 |
+--------+--------+---+
(15 rows)

!ok

# ROLLUP on column with nulls
# Note the two rows with NULL key (one represents ALL)
select gender, count(*) as c
from emp
group by rollup(gender);
+--------+---+
| GENDER | C |
+--------+---+
| F      | 6 |
| M      | 3 |
|        | 9 |
+--------+---+
(3 rows)

!ok

# ROLLUP plus ORDER BY
select gender, count(*) as c
from emp
group by rollup(gender)
order by c desc;
+--------+---+
| GENDER | C |
+--------+---+
|        | 9 |
| F      | 6 |
| M      | 3 |
+--------+---+
(3 rows)

!ok

# ROLLUP cartesian product
select deptno, count(*) as c
from emp
group by rollup(deptno), rollup(gender);
+--------+---+
| DEPTNO | C |
+--------+---+
|     10 | 1 |
|     10 | 1 |
|     20 | 1 |
|     20 | 1 |
|        | 1 |
|     10 | 2 |
|     30 | 2 |
|     30 | 2 |
|     50 | 1 |
|     50 | 1 |
|     50 | 2 |
|     60 | 1 |
|     60 | 1 |
|        | 1 |
|        | 3 |
|        | 6 |
|        | 9 |
+--------+---+
(17 rows)

!ok

# ROLLUP cartesian product of with tuple with expression
select deptno / 2 + 1 as half1, count(*) as c
from emp
group by rollup(deptno / 2, gender), rollup(substring(ename FROM 1 FOR 1));
+-------+---+
| HALF1 | C |
+-------+---+
|    11 | 1 |
|    11 | 1 |
|    11 | 1 |
|    11 | 1 |
|    16 | 1 |
|    16 | 1 |
|    16 | 1 |
|    16 | 1 |
|    16 | 2 |
|    16 | 2 |
|    26 | 1 |
|    26 | 1 |
|    26 | 1 |
|    26 | 1 |
|    26 | 1 |
|    26 | 1 |
|    26 | 2 |
|    31 | 1 |
|    31 | 1 |
|    31 | 1 |
|    31 | 1 |
|     6 | 1 |
|     6 | 1 |
|     6 | 1 |
|     6 | 1 |
|     6 | 1 |
|     6 | 1 |
|     6 | 2 |
|       | 1 |
|       | 1 |
|       | 1 |
|       | 1 |
|       | 1 |
|       | 1 |
|       | 1 |
|       | 1 |
|       | 1 |
|       | 2 |
|       | 2 |
|       | 9 |
+-------+---+
(40 rows)

!ok

# ROLLUP with HAVING
select deptno + 1 as d1, count(*) as c
from emp
group by rollup(deptno)
having count(*) > 3;
+----+---+
| D1 | C |
+----+---+
|    | 9 |
+----+---+
(1 row)

!ok

# CUBE and DISTINCT
select distinct count(*) from emp group by cube(deptno, gender);
+--------+
| EXPR$0 |
+--------+
|      1 |
|      2 |
|      3 |
|      6 |
|      9 |
+--------+
(5 rows)

!ok

# CUBE and JOIN
select e.deptno, e.gender, min(e.ename) as min_name
from emp as e join dept as d using (deptno)
group by cube(e.deptno, d.deptno, e.gender)
having count(*) > 2 or gender = 'M' and e.deptno = 10;
+--------+--------+----------+
| DEPTNO | GENDER | MIN_NAME |
+--------+--------+----------+
|     10 | M      | Bob      |
|     10 | M      | Bob      |
|        | F      | Alice    |
|        |        | Alice    |
+--------+--------+----------+
(4 rows)

!ok

# GROUPING in SELECT clause of GROUP BY query
select count(*) as c, grouping(deptno) as g
from emp
group by deptno;
+---+---+
| C | G |
+---+---+
| 1 | 0 |
| 1 | 0 |
| 1 | 0 |
| 2 | 0 |
| 2 | 0 |
| 2 | 0 |
+---+---+
(6 rows)

!ok

!use scott

# GROUPING in SELECT clause of CUBE query
select deptno, job, count(*) as c, grouping(deptno) as d,
  grouping(job) j, grouping(deptno, job) as x
from "scott".emp
group by cube(deptno, job);
+--------+-----------+----+---+---+---+
| DEPTNO | JOB       | C  | D | J | X |
+--------+-----------+----+---+---+---+
|     10 | CLERK     |  1 | 0 | 0 | 0 |
|     10 | MANAGER   |  1 | 0 | 0 | 0 |
|     10 | PRESIDENT |  1 | 0 | 0 | 0 |
|     10 |           |  3 | 0 | 1 | 1 |
|     20 | ANALYST   |  2 | 0 | 0 | 0 |
|     20 | CLERK     |  2 | 0 | 0 | 0 |
|     20 | MANAGER   |  1 | 0 | 0 | 0 |
|     20 |           |  5 | 0 | 1 | 1 |
|     30 | CLERK     |  1 | 0 | 0 | 0 |
|     30 | MANAGER   |  1 | 0 | 0 | 0 |
|     30 | SALESMAN  |  4 | 0 | 0 | 0 |
|     30 |           |  6 | 0 | 1 | 1 |
|        | ANALYST   |  2 | 1 | 0 | 2 |
|        | CLERK     |  4 | 1 | 0 | 2 |
|        | MANAGER   |  3 | 1 | 0 | 2 |
|        | PRESIDENT |  1 | 1 | 0 | 2 |
|        | SALESMAN  |  4 | 1 | 0 | 2 |
|        |           | 14 | 1 | 1 | 3 |
+--------+-----------+----+---+---+---+
(18 rows)

!ok

!use post

# GROUPING, GROUP_ID, GROUPING_ID in SELECT clause of GROUP BY query
select count(*) as c,
  grouping(deptno) as g,
  group_id() as gid,
  grouping_id(deptno) as gd,
  grouping_id(gender) as gg,
  grouping_id(gender, deptno) as ggd,
  grouping_id(deptno, gender) as gdg
from emp
group by rollup(deptno, gender);
+---+---+-----+----+----+-----+-----+
| C | G | GID | GD | GG | GGD | GDG |
+---+---+-----+----+----+-----+-----+
| 1 | 0 |   0 |  0 |  0 |   0 |   0 |
| 1 | 0 |   0 |  0 |  0 |   0 |   0 |
| 1 | 0 |   0 |  0 |  0 |   0 |   0 |
| 1 | 0 |   0 |  0 |  0 |   0 |   0 |
| 1 | 0 |   0 |  0 |  0 |   0 |   0 |
| 1 | 0 |   0 |  0 |  0 |   0 |   0 |
| 1 | 0 |   0 |  0 |  0 |   0 |   0 |
| 2 | 0 |   0 |  0 |  0 |   0 |   0 |
| 9 | 1 |   0 |  1 |  1 |   3 |   3 |
| 1 | 0 |   0 |  0 |  1 |   2 |   1 |
| 1 | 0 |   0 |  0 |  1 |   2 |   1 |
| 1 | 0 |   0 |  0 |  1 |   2 |   1 |
| 2 | 0 |   0 |  0 |  1 |   2 |   1 |
| 2 | 0 |   0 |  0 |  1 |   2 |   1 |
| 2 | 0 |   0 |  0 |  1 |   2 |   1 |
+---+---+-----+----+----+-----+-----+
(15 rows)

!ok

# GROUPING accepts multiple arguments, gives same result as GROUPING_ID
select count(*) as c,
  grouping(deptno) as gd,
  grouping_id(deptno) as gid,
  grouping(deptno, gender, deptno) as gdgd,
  grouping_id(deptno, gender, deptno) as gidgd
from emp
group by rollup(deptno, gender)
having grouping(deptno) <= grouping_id(deptno, gender, deptno);
+---+----+-----+------+-------+
| C | GD | GID | GDGD | GIDGD |
+---+----+-----+------+-------+
| 1 |  0 |   0 |    0 |     0 |
| 1 |  0 |   0 |    0 |     0 |
| 1 |  0 |   0 |    0 |     0 |
| 1 |  0 |   0 |    0 |     0 |
| 1 |  0 |   0 |    0 |     0 |
| 1 |  0 |   0 |    0 |     0 |
| 1 |  0 |   0 |    0 |     0 |
| 2 |  0 |   0 |    0 |     0 |
| 1 |  0 |   0 |    2 |     2 |
| 1 |  0 |   0 |    2 |     2 |
| 1 |  0 |   0 |    2 |     2 |
| 2 |  0 |   0 |    2 |     2 |
| 2 |  0 |   0 |    2 |     2 |
| 2 |  0 |   0 |    2 |     2 |
| 9 |  1 |   1 |    7 |     7 |
+---+----+-----+------+-------+
(15 rows)

!ok

# GROUPING in ORDER BY clause
select count(*) as c
from emp
group by rollup(deptno)
order by grouping(deptno), c;
+---+
| C |
+---+
| 1 |
| 1 |
| 1 |
| 2 |
| 2 |
| 2 |
| 9 |
+---+
(7 rows)

!ok

# Duplicate argument to GROUPING_ID.
select deptno, gender, grouping_id(deptno, gender, deptno), count(*) as c
from emp
where deptno = 10
group by rollup(gender, deptno);
+--------+--------+--------+---+
| DEPTNO | GENDER | EXPR$2 | C |
+--------+--------+--------+---+
|     10 | F      |      0 | 1 |
|     10 | M      |      0 | 1 |
|        | F      |      5 | 1 |
|        | M      |      5 | 1 |
|        |        |      7 | 2 |
+--------+--------+--------+---+
(5 rows)

!ok

# GROUPING in SELECT clause of ROLLUP query
select count(*) as c, deptno, grouping(deptno) as g
from emp
group by rollup(deptno);
+---+--------+---+
| C | DEPTNO | G |
+---+--------+---+
| 1 |     20 | 0 |
| 1 |     60 | 0 |
| 1 |        | 0 |
| 2 |     10 | 0 |
| 2 |     30 | 0 |
| 2 |     50 | 0 |
| 9 |        | 1 |
+---+--------+---+
(7 rows)

!ok

# GROUPING, GROUPING_ID and GROUP_ID
select deptno, gender, grouping(deptno) gd, grouping(gender) gg,
  grouping_id(deptno, gender) dg, grouping_id(gender, deptno) gd,
  group_id() gid, count(*) c
from emp
group by cube(deptno, gender);
+--------+--------+----+----+----+----+-----+---+
| DEPTNO | GENDER | GD | GG | DG | GD | GID | C |
+--------+--------+----+----+----+----+-----+---+
|     10 | F      |  0 |  0 |  0 |  0 |   0 | 1 |
|     10 | M      |  0 |  0 |  0 |  0 |   0 | 1 |
|     20 | M      |  0 |  0 |  0 |  0 |   0 | 1 |
|     30 | F      |  0 |  0 |  0 |  0 |   0 | 2 |
|     50 | F      |  0 |  0 |  0 |  0 |   0 | 1 |
|     50 | M      |  0 |  0 |  0 |  0 |   0 | 1 |
|     60 | F      |  0 |  0 |  0 |  0 |   0 | 1 |
|        | F      |  0 |  0 |  0 |  0 |   0 | 1 |
|        |        |  1 |  1 |  3 |  3 |   0 | 9 |
|     10 |        |  0 |  1 |  1 |  2 |   0 | 2 |
|     20 |        |  0 |  1 |  1 |  2 |   0 | 1 |
|     30 |        |  0 |  1 |  1 |  2 |   0 | 2 |
|     50 |        |  0 |  1 |  1 |  2 |   0 | 2 |
|     60 |        |  0 |  1 |  1 |  2 |   0 | 1 |
|        | F      |  1 |  0 |  2 |  1 |   0 | 6 |
|        | M      |  1 |  0 |  2 |  1 |   0 | 3 |
|        |        |  0 |  1 |  1 |  2 |   0 | 1 |
+--------+--------+----+----+----+----+-----+---+
(17 rows)

!ok

# [CALCITE-1781] Allow expression in CUBE and ROLLUP
select deptno + 1 as d1, deptno + 1 - 1 as d0, count(*) as c
from emp
group by rollup(deptno + 1);
+----+----+---+
| D1 | D0 | C |
+----+----+---+
| 11 | 10 | 2 |
| 21 | 20 | 1 |
| 31 | 30 | 2 |
| 51 | 50 | 2 |
| 61 | 60 | 1 |
|    |    | 1 |
|    |    | 9 |
+----+----+---+
(7 rows)

!ok

select mod(deptno, 20) as d, count(*) as c, gender as g
from emp
group by cube(mod(deptno, 20), gender);
+----+---+---+
| D  | C | G |
+----+---+---+
|  0 | 1 | F |
|  0 | 1 | M |
|  0 | 2 |   |
| 10 | 2 | M |
| 10 | 4 | F |
| 10 | 6 |   |
|    | 1 | F |
|    | 1 |   |
|    | 3 | M |
|    | 6 | F |
|    | 9 |   |
+----+---+---+
(11 rows)

!ok

select mod(deptno, 20) as d, count(*) as c, gender as g
from emp
group by rollup(mod(deptno, 20), gender);
+----+---+---+
| D  | C | G |
+----+---+---+
|  0 | 1 | F |
|  0 | 1 | M |
|  0 | 2 |   |
| 10 | 2 | M |
| 10 | 4 | F |
| 10 | 6 |   |
|    | 1 | F |
|    | 1 |   |
|    | 9 |   |
+----+---+---+
(9 rows)

!ok

select count(*) as c
from emp
group by cube(1);
+---+
| C |
+---+
| 9 |
| 9 |
+---+
(2 rows)

!ok

select count(*) as c
from emp
group by rollup(1);
+---+
| C |
+---+
| 9 |
| 9 |
+---+
(2 rows)

!ok

!use scott

# When
#   [CALCITE-1824] GROUP_ID returns wrong result
# is fixed, there will be an extra row (null, 1, 14).
select deptno, group_id() as g, count(*) as c
from "scott".emp
group by grouping sets (deptno, (), ());

+--------+---+----+
| DEPTNO | G | C  |
+--------+---+----+
|     10 | 0 |  3 |
|     20 | 0 |  5 |
|     30 | 0 |  6 |
|        | 0 | 14 |
+--------+---+----+
(4 rows)

!ok

# From http://rwijk.blogspot.com/2008/12/groupid.html
select deptno
       , job
       , empno
       , ename
       , sum(sal) sumsal
       , case grouping_id(deptno,job,empno)
           when 0 then 'grouped by deptno,job,empno,ename'
           when 1 then 'grouped by deptno,job'
           when 3 then 'grouped by deptno'
           when 7 then 'grouped by ()'
         end gr_text
    from "scott".emp
   group by rollup(deptno,job,(empno,ename))
   order by deptno
       , job
       , empno;

+--------+-----------+-------+--------+----------+-----------------------------------+
| DEPTNO | JOB       | EMPNO | ENAME  | SUMSAL   | GR_TEXT                           |
+--------+-----------+-------+--------+----------+-----------------------------------+
|     10 | CLERK     |  7934 | MILLER |  1300.00 | grouped by deptno,job,empno,ename |
|     10 | CLERK     |       |        |  1300.00 | grouped by deptno,job             |
|     10 | MANAGER   |  7782 | CLARK  |  2450.00 | grouped by deptno,job,empno,ename |
|     10 | MANAGER   |       |        |  2450.00 | grouped by deptno,job             |
|     10 | PRESIDENT |  7839 | KING   |  5000.00 | grouped by deptno,job,empno,ename |
|     10 | PRESIDENT |       |        |  5000.00 | grouped by deptno,job             |
|     10 |           |       |        |  8750.00 | grouped by deptno                 |
|     20 | ANALYST   |  7788 | SCOTT  |  3000.00 | grouped by deptno,job,empno,ename |
|     20 | ANALYST   |  7902 | FORD   |  3000.00 | grouped by deptno,job,empno,ename |
|     20 | ANALYST   |       |        |  6000.00 | grouped by deptno,job             |
|     20 | CLERK     |  7369 | SMITH  |   800.00 | grouped by deptno,job,empno,ename |
|     20 | CLERK     |  7876 | ADAMS  |  1100.00 | grouped by deptno,job,empno,ename |
|     20 | CLERK     |       |        |  1900.00 | grouped by deptno,job             |
|     20 | MANAGER   |  7566 | JONES  |  2975.00 | grouped by deptno,job,empno,ename |
|     20 | MANAGER   |       |        |  2975.00 | grouped by deptno,job             |
|     20 |           |       |        | 10875.00 | grouped by deptno                 |
|     30 | CLERK     |  7900 | JAMES  |   950.00 | grouped by deptno,job,empno,ename |
|     30 | CLERK     |       |        |   950.00 | grouped by deptno,job             |
|     30 | MANAGER   |  7698 | BLAKE  |  2850.00 | grouped by deptno,job,empno,ename |
|     30 | MANAGER   |       |        |  2850.00 | grouped by deptno,job             |
|     30 | SALESMAN  |  7499 | ALLEN  |  1600.00 | grouped by deptno,job,empno,ename |
|     30 | SALESMAN  |  7521 | WARD   |  1250.00 | grouped by deptno,job,empno,ename |
|     30 | SALESMAN  |  7654 | MARTIN |  1250.00 | grouped by deptno,job,empno,ename |
|     30 | SALESMAN  |  7844 | TURNER |  1500.00 | grouped by deptno,job,empno,ename |
|     30 | SALESMAN  |       |        |  5600.00 | grouped by deptno,job             |
|     30 |           |       |        |  9400.00 | grouped by deptno                 |
|        |           |       |        | 29025.00 | grouped by ()                     |
+--------+-----------+-------+--------+----------+-----------------------------------+
(27 rows)

!ok

# From http://rwijk.blogspot.com/2008/12/groupid.html
# (replacing "to_char(...)" with "cast(... as varchar)")
# The current results are incorrect. When
#   [CALCITE-1824] GROUP_ID returns wrong result
# is fixed, there will be 4 more rows.
select deptno
       , job
       , empno
       , ename
       , sum(sal) sumsal
       , case grouping_id(deptno,job,empno)
           when 0 then 'grouped by deptno,job,empno,ename'
           when 1 then 'grouped by deptno,job'
           when 3 then 'grouped by deptno, grouping set ' || cast(3+group_id() as varchar)
           when 7 then 'grouped by (), grouping set ' || cast(5+group_id() as varchar)
         end gr_text
    from "scott".emp
   group by grouping sets
         ( (deptno,job,empno,ename)
         , (deptno,job)
         , deptno
         , deptno
         , ()
         , ()
         )
   order by deptno
       , job
       , empno;

+--------+-----------+-------+--------+----------+-----------------------------------+
| DEPTNO | JOB       | EMPNO | ENAME  | SUMSAL   | GR_TEXT                           |
+--------+-----------+-------+--------+----------+-----------------------------------+
|     10 | CLERK     |  7934 | MILLER |  1300.00 | grouped by deptno,job,empno,ename |
|     10 | CLERK     |       |        |  1300.00 | grouped by deptno,job             |
|     10 | MANAGER   |  7782 | CLARK  |  2450.00 | grouped by deptno,job,empno,ename |
|     10 | MANAGER   |       |        |  2450.00 | grouped by deptno,job             |
|     10 | PRESIDENT |  7839 | KING   |  5000.00 | grouped by deptno,job,empno,ename |
|     10 | PRESIDENT |       |        |  5000.00 | grouped by deptno,job             |
|     10 |           |       |        |  8750.00 | grouped by deptno, grouping set 3 |
|     20 | ANALYST   |  7788 | SCOTT  |  3000.00 | grouped by deptno,job,empno,ename |
|     20 | ANALYST   |  7902 | FORD   |  3000.00 | grouped by deptno,job,empno,ename |
|     20 | ANALYST   |       |        |  6000.00 | grouped by deptno,job             |
|     20 | CLERK     |  7369 | SMITH  |   800.00 | grouped by deptno,job,empno,ename |
|     20 | CLERK     |  7876 | ADAMS  |  1100.00 | grouped by deptno,job,empno,ename |
|     20 | CLERK     |       |        |  1900.00 | grouped by deptno,job             |
|     20 | MANAGER   |  7566 | JONES  |  2975.00 | grouped by deptno,job,empno,ename |
|     20 | MANAGER   |       |        |  2975.00 | grouped by deptno,job             |
|     20 |           |       |        | 10875.00 | grouped by deptno, grouping set 3 |
|     30 | CLERK     |  7900 | JAMES  |   950.00 | grouped by deptno,job,empno,ename |
|     30 | CLERK     |       |        |   950.00 | grouped by deptno,job             |
|     30 | MANAGER   |  7698 | BLAKE  |  2850.00 | grouped by deptno,job,empno,ename |
|     30 | MANAGER   |       |        |  2850.00 | grouped by deptno,job             |
|     30 | SALESMAN  |  7499 | ALLEN  |  1600.00 | grouped by deptno,job,empno,ename |
|     30 | SALESMAN  |  7521 | WARD   |  1250.00 | grouped by deptno,job,empno,ename |
|     30 | SALESMAN  |  7654 | MARTIN |  1250.00 | grouped by deptno,job,empno,ename |
|     30 | SALESMAN  |  7844 | TURNER |  1500.00 | grouped by deptno,job,empno,ename |
|     30 | SALESMAN  |       |        |  5600.00 | grouped by deptno,job             |
|     30 |           |       |        |  9400.00 | grouped by deptno, grouping set 3 |
|        |           |       |        | 29025.00 | grouped by (), grouping set 5     |
+--------+-----------+-------+--------+----------+-----------------------------------+
(27 rows)

!ok

# [KYLIN-751] Max on negative double values is not working
# [CALCITE-735] Primitive.DOUBLE.min should be large and negative
select max(v) as x, min(v) as n
from (values cast(-86.4 as double), cast(-100 as double)) as t(v);
+-------+--------+
| X     | N      |
+-------+--------+
| -86.4 | -100.0 |
+-------+--------+
(1 row)

!ok

select max(v) as x, min(v) as n
from (values cast(-86.4 as double), cast(-100 as double), cast(2 as double)) as t(v);
+-----+--------+
| X   | N      |
+-----+--------+
| 2.0 | -100.0 |
+-----+--------+
(1 row)

!ok

select max(v) as x, min(v) as n
from (values cast(-86.4 as float), cast(-100 as float)) as t(v);
+-------+--------+
| X     | N      |
+-------+--------+
| -86.4 | -100.0 |
+-------+--------+
(1 row)

!ok

# [CALCITE-551] Sub-query inside aggregate function
SELECT SUM(
  CASE WHEN deptno IN (SELECT deptno FROM "scott".dept) THEN 1
  ELSE 0 END) as s
FROM "scott".emp;
+----+
| S  |
+----+
| 14 |
+----+
(1 row)

!ok

SELECT SUM((select min(cast(deptno as integer)) from "scott".dept)) as s
FROM "scott".emp;
+-----+
| S   |
+-----+
| 140 |
+-----+
(1 row)

!ok

# As above, but with GROUP BY
SELECT SUM((select min(cast(deptno as integer)) from "scott".dept)) as s, deptno
FROM "scott".emp
GROUP BY deptno;
+----+--------+
| S  | DEPTNO |
+----+--------+
| 30 |     10 |
| 50 |     20 |
| 60 |     30 |
+----+--------+
(3 rows)

!ok

# As above, but with correlation
!if (fixed.calcite1045) {
SELECT SUM(
  (select char_length(dname) from "scott".dept where dept.deptno = emp.empno)) as s
FROM "scott".emp;
!ok
!}

# FUSION rolled up using CARDINALITY
select cardinality(fusion(empnos)) as f_empnos_length
from (
  select deptno, collect(empno) as empnos
  from "scott".emp
  group by deptno);
+-----------------+
| F_EMPNOS_LENGTH |
+-----------------+
|              14 |
+-----------------+
(1 row)

!ok

# FUSION
select cardinality(fusion(empnos)) as f_empnos_length from (select deptno, collect(empno) as empnos
from "scott".emp
group by deptno);
+-----------------+
| F_EMPNOS_LENGTH |
+-----------------+
|              14 |
+-----------------+
(1 row)

!ok

# FUSION on sub-total
select job, fusion(empnos) as empnos
from (
  select job, collect(empno) as empnos
  from "scott".emp
  group by deptno, job)
group by job;
+-----------+--------------------------+
| JOB       | EMPNOS                   |
+-----------+--------------------------+
| ANALYST   | [7788, 7902]             |
| CLERK     | [7934, 7369, 7876, 7900] |
| MANAGER   | [7782, 7566, 7698]       |
| PRESIDENT | [7839]                   |
| SALESMAN  | [7499, 7521, 7654, 7844] |
+-----------+--------------------------+
(5 rows)

!ok

# FUSION grand total
select fusion(deptnos) as deptnos
from (
  select collect(distinct deptno) as deptnos
  from "scott".emp
  group by deptno);
+--------------+
| DEPTNOS      |
+--------------+
| [20, 10, 30] |
+--------------+
(1 row)

!ok

# COLLECT
select deptno, collect(empno) as empnos
from "scott".emp
group by deptno;
+--------+--------------------------------------+
| DEPTNO | EMPNOS                               |
+--------+--------------------------------------+
|     10 | [7782, 7839, 7934]                   |
|     20 | [7369, 7566, 7788, 7876, 7902]       |
|     30 | [7499, 7521, 7654, 7698, 7844, 7900] |
+--------+--------------------------------------+
(3 rows)

!ok

# COLLECT DISTINCT
# Disabled in JDK 1.7 because order of values is different
!if (jdk18) {
select deptno, collect(distinct job) as jobs
from "scott".emp
group by deptno;
+--------+-----------------------------+
| DEPTNO | JOBS                        |
+--------+-----------------------------+
|     10 | [MANAGER, CLERK, PRESIDENT] |
|     20 | [CLERK, ANALYST, MANAGER]   |
|     30 | [SALESMAN, MANAGER, CLERK]  |
+--------+-----------------------------+
(3 rows)

!ok
!}

# COLLECT ... FILTER
select deptno, collect(empno) filter (where empno < 7550) as empnos
from "scott".emp
group by deptno;
+--------+--------------+
| DEPTNO | EMPNOS       |
+--------+--------------+
|     10 | []           |
|     20 | [7369]       |
|     30 | [7499, 7521] |
+--------+--------------+
(3 rows)

!ok

# Aggregate FILTER
select deptno,
  sum(sal) filter (where job = 'CLERK') c_sal,
  sum(sal) filter (where job = 'CLERK' and deptno > 10) c10_sal,
  max(sal) filter (where job = 'CLERK') as max_c,
  min(sal) filter (where job = 'CLERK') as min_c,
  max(sal) filter (where job = 'CLERK')
    - min(sal) filter (where job = 'CLERK') as range_c,
  max(sal) filter (where job = 'SALESMAN')
    - min(sal) filter (where job = 'SALESMAN') as range_m
from "scott".emp
group by deptno;
+--------+---------+---------+---------+---------+---------+---------+
| DEPTNO | C_SAL   | C10_SAL | MAX_C   | MIN_C   | RANGE_C | RANGE_M |
+--------+---------+---------+---------+---------+---------+---------+
|     10 | 1300.00 |         | 1300.00 | 1300.00 |    0.00 |         |
|     20 | 1900.00 | 1900.00 | 1100.00 |  800.00 |  300.00 |         |
|     30 |  950.00 |  950.00 |  950.00 |  950.00 |    0.00 |  350.00 |
+--------+---------+---------+---------+---------+---------+---------+
(3 rows)

!ok

# Aggregate FILTER on condition in GROUP BY
select deptno,
  sum(sal) filter (where deptno = 10) sal_10
from "scott".emp
group by deptno;
DEPTNO TINYINT(3)
SAL_10 DECIMAL(7, 2)
!type
+--------+---------+
| DEPTNO | SAL_10  |
+--------+---------+
|     10 | 8750.00 |
|     20 |         |
|     30 |         |
+--------+---------+
(3 rows)

!ok

# Aggregate FILTER with HAVING
select deptno
from "scott".emp
group by deptno
having sum(sal) filter (where job = 'CLERK') > 1000;
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
+--------+
(2 rows)

!ok

# Aggregate FILTER with ORDER BY
select deptno
from "scott".emp
group by deptno
order by sum(sal) filter (where job = 'CLERK');
+--------+
| DEPTNO |
+--------+
|     30 |
|     10 |
|     20 |
+--------+
(3 rows)

!ok

# Aggregate FILTER with JOIN
select dept.deptno,
  sum(sal) filter (where 1 < 2) as s,
  sum(sal) as s1,
  count(*) filter (where emp.ename < dept.dname) as c
from "scott".emp
join "scott".dept using (deptno)
group by dept.deptno;
+--------+----------+----------+---+
| DEPTNO | S        | S1       | C |
+--------+----------+----------+---+
|     10 |  8750.00 |  8750.00 | 0 |
|     20 | 10875.00 | 10875.00 | 3 |
|     30 |  9400.00 |  9400.00 | 4 |
+--------+----------+----------+---+
(3 rows)

!ok

# Aggregate FILTER with DISTINCT
select deptno,
 count(distinct job) as cdj
from "scott".emp
group by deptno;
+--------+-----+
| DEPTNO | CDJ |
+--------+-----+
|     10 |   3 |
|     20 |   3 |
|     30 |   3 |
+--------+-----+
(3 rows)

!ok

select deptno,
 count(distinct job) filter (where job <> 'SALESMAN') as cdj
from "scott".emp
group by deptno;
+--------+-----+
| DEPTNO | CDJ |
+--------+-----+
|     10 |   3 |
|     20 |   3 |
|     30 |   2 |
+--------+-----+
(3 rows)

!ok

# [CALCITE-1293] Bad code generated when argument to COUNT(DISTINCT) is a
# GROUP BY column
select count(distinct deptno) as cd, count(*) as c
from "scott".emp
group by deptno;
+----+---+
| CD | C |
+----+---+
|  1 | 3 |
|  1 | 5 |
|  1 | 6 |
+----+---+
(3 rows)

!ok

select count(distinct deptno) as cd, count(*) as c
from "scott".emp
group by cube(deptno);
+----+---+
| CD | C |
+----+---+
|  1 | 3 |
|  1 | 5 |
|  1 | 6 |
|  3 | 3 |
+----+---+
(4 rows)

!ok

select deptno, count(distinct deptno) as c
from "scott".emp
group by deptno;
+--------+---+
| DEPTNO | C |
+--------+---+
|     10 | 1 |
|     20 | 1 |
|     30 | 1 |
+--------+---+
(3 rows)

!ok

select count(distinct deptno) as c
from "scott".emp
group by deptno;
+---+
| C |
+---+
| 1 |
| 1 |
| 1 |
+---+
(3 rows)

!ok

# Multiple distinct count
select deptno,
 count(distinct job) as j, count(distinct mgr) as m
from "scott".emp
group by deptno;
+--------+---+---+
| DEPTNO | J | M |
+--------+---+---+
|     10 | 3 | 2 |
|     20 | 3 | 4 |
|     30 | 3 | 2 |
+--------+---+---+
(3 rows)

!ok

# Multiple distinct count and non-distinct aggregates
select deptno,
 count(distinct job) as dj,
 count(job) as j,
 count(distinct mgr) as m,
 sum(sal) as s
from "scott".emp
group by deptno;
+--------+----+---+---+----------+
| DEPTNO | DJ | J | M | S        |
+--------+----+---+---+----------+
|     10 |  3 | 3 | 2 |  8750.00 |
|     20 |  3 | 5 | 4 | 10875.00 |
|     30 |  3 | 6 | 2 |  9400.00 |
+--------+----+---+---+----------+
(3 rows)

!ok

# Multiple distinct count and non-distinct aggregates, no GROUP BY
select count(distinct job) as dj,
 count(job) as j,
 count(distinct mgr) as m,
 sum(sal) as s
from "scott".emp;
+----+----+---+----------+
| DJ | J  | M | S        |
+----+----+---+----------+
|  5 | 14 | 6 | 29025.00 |
+----+----+---+----------+
(1 row)

!ok

# [CALCITE-280] BigDecimal underflow
# Previously threw "java.lang.ArithmeticException: Non-terminating decimal
# expansion; no exact representable decimal result"
select avg(comm) as a, count(comm) as c from "scott".emp where empno < 7844;
+-------------------+---+
| A                 | C |
+-------------------+---+
| 733.3333333333333 | 3 |
+-------------------+---+
(1 row)

!ok

# [CALCITE-846] Push aggregate with FILTER through UNION ALL
select deptno, count(*) filter (where job = 'CLERK') as cf, count(*) as c
from (
  select * from "scott".emp where deptno < 20
  union all
  select * from "scott".emp where deptno > 20)
group by deptno;
+--------+----+---+
| DEPTNO | CF | C |
+--------+----+---+
|     10 |  1 | 3 |
|     30 |  1 | 6 |
+--------+----+---+
(2 rows)

!ok
EnumerableAggregate(group=[{0}], CF=[COUNT() FILTER $1], C=[COUNT()])
  EnumerableCalc(expr#0..1=[{inputs}], expr#2=['CLERK':VARCHAR(9)], expr#3=[=($t0, $t2)], expr#4=[IS TRUE($t3)], DEPTNO=[$t1], $f1=[$t4])
    EnumerableUnion(all=[true])
      EnumerableCalc(expr#0..7=[{inputs}], expr#8=[20], expr#9=[<($t7, $t8)], JOB=[$t2], DEPTNO=[$t7], $condition=[$t9])
        EnumerableTableScan(table=[[scott, EMP]])
      EnumerableCalc(expr#0..7=[{inputs}], expr#8=[20], expr#9=[>($t7, $t8)], JOB=[$t2], DEPTNO=[$t7], $condition=[$t9])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-751] Aggregate join transpose
select count(*)
from "scott".emp join "scott".dept using (deptno);
+--------+
| EXPR$0 |
+--------+
|     14 |
+--------+
(1 row)

!ok
EnumerableAggregate(group=[{}], EXPR$0=[COUNT()])
  EnumerableHashJoin(condition=[=($0, $2)], joinType=[inner])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
      EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push sum: splits into sum * count
select sum(sal)
from "scott".emp join "scott".dept using (deptno);
+----------+
| EXPR$0   |
+----------+
| 29025.00 |
+----------+
(1 row)

!ok
EnumerableAggregate(group=[{}], EXPR$0=[SUM($2)])
  EnumerableHashJoin(condition=[=($0, $3)], joinType=[inner])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
      EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push sum; no aggregate needed after join
select sum(sal)
from "scott".emp join "scott".dept using (deptno)
group by emp.deptno, dept.deptno;
+----------+
| EXPR$0   |
+----------+
| 10875.00 |
|  8750.00 |
|  9400.00 |
+----------+
(3 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], EXPR$0=[$t2])
  EnumerableAggregate(group=[{0, 3}], EXPR$0=[SUM($2)])
    EnumerableHashJoin(condition=[=($0, $3)], joinType=[inner])
      EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
        EnumerableTableScan(table=[[scott, DEPT]])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push sum; group by only one of the join keys
select sum(sal)
from "scott".emp join "scott".dept using (deptno)
group by emp.deptno;
+----------+
| EXPR$0   |
+----------+
| 10875.00 |
|  8750.00 |
|  9400.00 |
+----------+
(3 rows)

!ok
EnumerableCalc(expr#0..1=[{inputs}], EXPR$0=[$t1])
  EnumerableAggregate(group=[{3}], EXPR$0=[SUM($2)])
    EnumerableHashJoin(condition=[=($0, $3)], joinType=[inner])
      EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
        EnumerableTableScan(table=[[scott, DEPT]])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push min; Join-Aggregate is optimized to SemiJoin
select min(sal)
from "scott".emp join "scott".dept using (deptno)
group by emp.deptno;
+---------+
| EXPR$0  |
+---------+
| 1300.00 |
|  800.00 |
|  950.00 |
+---------+
(3 rows)

!ok
EnumerableCalc(expr#0..1=[{inputs}], EXPR$0=[$t1])
  EnumerableAggregate(group=[{3}], EXPR$0=[MIN($2)])
    EnumerableHashJoin(condition=[=($0, $3)], joinType=[inner])
      EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
        EnumerableTableScan(table=[[scott, DEPT]])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push sum and count
select count(*) as c, sum(sal) as s
from "scott".emp join "scott".dept using (deptno);
+----+----------+
| C  | S        |
+----+----------+
| 14 | 29025.00 |
+----+----------+
(1 row)

!ok
EnumerableAggregate(group=[{}], C=[COUNT()], S=[SUM($2)])
  EnumerableHashJoin(condition=[=($0, $3)], joinType=[inner])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
      EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push sum and count, group by join key
select count(*) as c, sum(sal) as s
from "scott".emp join "scott".dept using (deptno) group by emp.deptno;
+---+----------+
| C | S        |
+---+----------+
| 3 |  8750.00 |
| 5 | 10875.00 |
| 6 |  9400.00 |
+---+----------+
(3 rows)

!ok
# No aggregate on top, because output of join is unique
EnumerableCalc(expr#0..2=[{inputs}], C=[$t1], S=[$t2])
  EnumerableAggregate(group=[{3}], C=[COUNT()], S=[SUM($2)])
    EnumerableHashJoin(condition=[=($0, $3)], joinType=[inner])
      EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
        EnumerableTableScan(table=[[scott, DEPT]])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push sum and count, group by join key plus another column
select count(*) as c, sum(sal) as s
from "scott".emp join "scott".dept using (deptno) group by emp.job, dept.deptno;
+---+---------+
| C | S       |
+---+---------+
| 1 | 1300.00 |
| 1 | 2450.00 |
| 1 | 2850.00 |
| 1 | 2975.00 |
| 1 | 5000.00 |
| 1 |  950.00 |
| 2 | 1900.00 |
| 2 | 6000.00 |
| 4 | 5600.00 |
+---+---------+
(9 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], C=[$t2], S=[$t3])
  EnumerableAggregate(group=[{0, 2}], C=[COUNT()], S=[SUM($3)])
    EnumerableHashJoin(condition=[=($0, $4)], joinType=[inner])
      EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
        EnumerableTableScan(table=[[scott, DEPT]])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], JOB=[$t2], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push sum and count, group by non-join column
select count(*) as c, sum(sal) as s
from "scott".emp join "scott".dept using (deptno) group by emp.job;
+---+---------+
| C | S       |
+---+---------+
| 1 | 5000.00 |
| 2 | 6000.00 |
| 3 | 8275.00 |
| 4 | 4150.00 |
| 4 | 5600.00 |
+---+---------+
(5 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], C=[$t1], S=[$t2])
  EnumerableAggregate(group=[{2}], C=[COUNT()], S=[SUM($3)])
    EnumerableHashJoin(condition=[=($0, $4)], joinType=[inner])
      EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
        EnumerableTableScan(table=[[scott, DEPT]])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], JOB=[$t2], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push count and sum, group by superset of join key
select count(*) as c, sum(sal) as s
from "scott".emp join "scott".dept using (deptno) group by emp.job, dept.deptno;
+---+---------+
| C | S       |
+---+---------+
| 1 | 5000.00 |
| 2 | 6000.00 |
| 4 | 5600.00 |
| 1 | 1300.00 |
| 1 | 2450.00 |
| 1 | 2850.00 |
| 1 | 2975.00 |
| 1 |  950.00 |
| 2 | 1900.00 |
+---+---------+
(9 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], C=[$t2], S=[$t3])
  EnumerableAggregate(group=[{0, 2}], C=[COUNT()], S=[SUM($3)])
    EnumerableHashJoin(condition=[=($0, $4)], joinType=[inner])
      EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
        EnumerableTableScan(table=[[scott, DEPT]])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], JOB=[$t2], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push count and sum, group by a column being aggregated
select count(*) as c, sum(sal) as s
from "scott".emp join "scott".dept using (deptno) group by emp.sal;
+---+---------+
| C | S       |
+---+---------+
| 1 | 5000.00 |
| 2 | 6000.00 |
| 1 | 1100.00 |
| 1 | 1300.00 |
| 1 | 1500.00 |
| 1 | 1600.00 |
| 1 | 2450.00 |
| 1 | 2850.00 |
| 1 | 2975.00 |
| 1 |  800.00 |
| 1 |  950.00 |
| 2 | 2500.00 |
+---+---------+
(12 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], C=[$t1], S=[$t2])
  EnumerableAggregate(group=[{2}], C=[COUNT()], S=[SUM($2)])
    EnumerableHashJoin(condition=[=($0, $3)], joinType=[inner])
      EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
        EnumerableTableScan(table=[[scott, DEPT]])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# Push sum, self-join, returning one row with a null value
select sum(e.sal) as s
from "scott".emp e join "scott".emp m on e.mgr = e.empno;
+---+
| S |
+---+
|   |
+---+
(1 row)

!ok

# Push sum, self-join
select sum(e.sal) as s
from "scott".emp e join "scott".emp m on e.mgr = m.empno;
+----------+
| S        |
+----------+
| 24025.00 |
+----------+
(1 row)

!ok

# Push sum, self-join, cartesian product over nullable and non-nullable columns
select sum(e.sal) as ss, count(e.sal) as cs, count(e.mgr) as cm
from "scott".emp e
join "scott".emp m on e.deptno = m.deptno
group by e.deptno, m.deptno;
+----------+----+----+
| SS       | CS | CM |
+----------+----+----+
| 26250.00 |  9 |  6 |
| 54375.00 | 25 | 25 |
| 56400.00 | 36 | 36 |
+----------+----+----+
(3 rows)

!ok

# Push sum, self-join, aggregate by column on "many" side
select sum(e.sal) as s
from "scott".emp e join "scott".emp m on e.mgr = m.empno
group by m.empno;
+---------+
| S       |
+---------+
| 1100.00 |
| 1300.00 |
| 6000.00 |
| 6550.00 |
|  800.00 |
| 8275.00 |
+---------+
(6 rows)

!ok

# Push sum, self-join, aggregate by column on "one" side.
# Note inflated totals due to cartesian product.
select sum(m.sal) as s
from "scott".emp e join "scott".emp m on e.mgr = m.empno
group by m.empno;
+----------+
| S        |
+----------+
| 14250.00 |
| 15000.00 |
|  2450.00 |
|  3000.00 |
|  3000.00 |
|  5950.00 |
+----------+
(6 rows)

!ok

# Collation of LogicalAggregate ([CALCITE-783] and [CALCITE-822])
select  sum(x) as sum_cnt,
  count(distinct y) as cnt_dist
from
  (
  select
    count(*)                as x,
          t1.job      as y,
    t1.deptno as z
  from
    "scott".emp t1
  group by t1.job, t1.deptno
  order by t1.job, t1.deptno
) sq(x,y,z)
group by z
order by sum_cnt;

+---------+----------+
| SUM_CNT | CNT_DIST |
+---------+----------+
|       3 |        3 |
|       5 |        3 |
|       6 |        3 |
+---------+----------+
(3 rows)

!ok

# [CALCITE-938] Aggregate row count
select empno, d.deptno
from "scott".emp
join (select distinct deptno from "scott".dept) d
using (deptno);
+-------+--------+
| EMPNO | DEPTNO |
+-------+--------+
|  7369 |     20 |
|  7499 |     30 |
|  7521 |     30 |
|  7566 |     20 |
|  7654 |     30 |
|  7698 |     30 |
|  7782 |     10 |
|  7788 |     20 |
|  7839 |     10 |
|  7844 |     30 |
|  7876 |     20 |
|  7900 |     30 |
|  7902 |     20 |
|  7934 |     10 |
+-------+--------+
(14 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], EMPNO=[$t1], DEPTNO=[$t0])
  EnumerableHashJoin(condition=[=($0, $2)], joinType=[inner])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
      EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-1016] "GROUP BY constant" on empty relation should return 0 rows
# Should return 0 rows
select '1' from "scott".emp where false group by 1;
+--------+
| EXPR$0 |
+--------+
+--------+
(0 rows)

!ok

# Should return 0 rows
select count('1') from "scott".emp where false group by 1;
+--------+
| EXPR$0 |
+--------+
+--------+
(0 rows)

!ok

# Should return 1 row
select count('1') from "scott".emp where false group by ();
+--------+
| EXPR$0 |
+--------+
|      0 |
+--------+
(1 row)

!ok

# Should return 1 row
select count('1') from "scott".emp where false;
+--------+
| EXPR$0 |
+--------+
|      0 |
+--------+
(1 row)

!ok

# As above, but on VALUES rather than table
# Should return 0 rows
select '1' from (values (1, 2), (3, 4)) where false group by 1;
+--------+
| EXPR$0 |
+--------+
+--------+
(0 rows)

!ok

# Should return 0 rows
select count('1') from (values (1, 2), (3, 4)) where false group by 1;
+--------+
| EXPR$0 |
+--------+
+--------+
(0 rows)

!ok

# Should return 1 row
select count('1') from (values (1, 2), (3, 4)) where false group by ();
+--------+
| EXPR$0 |
+--------+
|      0 |
+--------+
(1 row)

!ok

# Should return 1 row
select count('1') from (values (1, 2), (3, 4)) where false;
+--------+
| EXPR$0 |
+--------+
|      0 |
+--------+
(1 row)

!ok

# As above, but on join
# Should return 0 rows
select '1' from "scott".emp join "scott".dept using (deptno) where false group by 1;
+--------+
| EXPR$0 |
+--------+
+--------+
(0 rows)

!ok

# Should return 0 rows
select count('1') from "scott".emp join "scott".dept using (deptno) where false group by 1;
+--------+
| EXPR$0 |
+--------+
+--------+
(0 rows)

!ok

# Should return 1 row
select count('1') from "scott".emp join "scott".dept using (deptno) where false group by ();
+--------+
| EXPR$0 |
+--------+
|      0 |
+--------+
(1 row)

!ok

# Should return 1 row
select count('1') from "scott".emp join "scott".dept using (deptno) where false;
+--------+
| EXPR$0 |
+--------+
|      0 |
+--------+
(1 row)

!ok

# [CALCITE-1023] Planner rule that removes Aggregate keys that are constant
select job, sum(sal) as sum_sal, deptno
from "scott".emp
where deptno = 10
group by deptno, job;
+-----------+---------+--------+
| JOB       | SUM_SAL | DEPTNO |
+-----------+---------+--------+
| CLERK     | 1300.00 |     10 |
| MANAGER   | 2450.00 |     10 |
| PRESIDENT | 5000.00 |     10 |
+-----------+---------+--------+
(3 rows)

!ok
!if (fixed.calcite1048) {
select job, sum(sal) as sum_sal, deptno
from "scott".emp
where deptno = 10
group by deptno, job;
EnumerableCalc(expr#0..2=[{inputs}], JOB=[$t0], SUM_SAL=[$t2], DEPTNO=[$t1])
  EnumerableAggregate(group=[{2, 7}], SUM_SAL=[SUM($5)])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t7):INTEGER], expr#9=[10], expr#10=[=($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
      EnumerableTableScan(table=[[scott, EMP]])
!plan
!}

!use orinoco

# FLOOR to achieve a 2-hour window
select floor(rowtime to hour) as rowtime, count(*) as c
from Orders
group by floor(rowtime to hour);
+---------------------+---+
| ROWTIME             | C |
+---------------------+---+
| 2015-02-15 10:00:00 | 4 |
| 2015-02-15 11:00:00 | 1 |
+---------------------+---+
(2 rows)

!ok

# FLOOR applied to intervals, to achieve a 2-hour window
select rowtime, count(*) as c
from (
  select timestamp '1970-1-1 0:0:0' + (floor(timestamp '1970-1-1 0:0:0' + ((rowtime - timestamp '1970-1-1 0:0:0') second) / 2 to hour) - timestamp '1970-1-1 0:0:0') second * 2 as rowtime
  from Orders)
group by rowtime;
+---------------------+---+
| ROWTIME             | C |
+---------------------+---+
| 2015-02-15 10:00:00 | 5 |
+---------------------+---+
(1 row)

!ok

# [CALCITE-729] IndexOutOfBoundsException in ROLLUP query on JDBC data source
!use jdbc_scott
select deptno, job, count(*) as c
from jdbc_scott.emp
group by rollup (deptno, job)
order by 1, 2;
+--------+-----------+----+
| DEPTNO | JOB       | C  |
+--------+-----------+----+
|     10 | CLERK     |  1 |
|     10 | MANAGER   |  1 |
|     10 | PRESIDENT |  1 |
|     10 |           |  3 |
|     20 | ANALYST   |  2 |
|     20 | CLERK     |  2 |
|     20 | MANAGER   |  1 |
|     20 |           |  5 |
|     30 | CLERK     |  1 |
|     30 | MANAGER   |  1 |
|     30 | SALESMAN  |  4 |
|     30 |           |  6 |
|        |           | 14 |
+--------+-----------+----+
(13 rows)

!ok

# [CALCITE-799] Incorrect result for "HAVING count(*) > 1"
select d.deptno, min(e.empid) as empid
from (values (100, 'Bill', 1),
             (200, 'Eric', 1),
             (150, 'Sebastian', 3)) as e(empid, name, deptno)
join (values (1, 'LeaderShip'),
             (2, 'TestGroup'),
             (3, 'Development')) as d(deptno, name)
on e.deptno = d.deptno
group by d.deptno
having count(*) > 1;
+--------+-------+
| DEPTNO | EMPID |
+--------+-------+
|      1 |   100 |
+--------+-------+
(1 row)

!ok

# Same, using USING (combining [CALCITE-799] and [CALCITE-801])
select d.deptno, min(e.empid) as empid
from (values (100, 'Bill', 1),
             (200, 'Eric', 1),
             (150, 'Sebastian', 3)) as e(empid, name, deptno)
join (values (1, 'LeaderShip'),
             (2, 'TestGroup'),
             (3, 'Development')) as d(deptno, name)
using (deptno)
group by d.deptno
having count(*) > 1;
+--------+-------+
| DEPTNO | EMPID |
+--------+-------+
|      1 |   100 |
+--------+-------+
(1 row)

!ok

# [CALCITE-886] System functions in the GROUP BY clause
# Calls to system functions do not have "()", which may confuse the validator.
select CURRENT_USER as CUSER
from jdbc_scott.emp
group by CURRENT_USER;
+-------+
| CUSER |
+-------+
| SCOTT |
+-------+
(1 row)

!ok

# [CALCITE-886] System functions in the GROUP BY clause
# System function inside a GROUPING SETS.
select CURRENT_USER as CUSER
from jdbc_scott.emp
group by grouping sets(CURRENT_USER);
+-------+
| CUSER |
+-------+
| SCOTT |
+-------+
(1 row)

!ok

# [CALCITE-1381] SqlCall.clone should retain function quantifier
select nullif(count(distinct '1'),0)
from (values (1,2),(3,4));
+--------+
| EXPR$0 |
+--------+
|      1 |
+--------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[0:BIGINT], expr#2=[=($t0, $t1)], expr#3=[null:BIGINT], expr#4=[CASE($t2, $t3, $t0)], EXPR$0=[$t4])
  EnumerableAggregate(group=[{}], agg#0=[COUNT($0)])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=['1'], $f0=[$t2])
        EnumerableValues(tuples=[[{ 1, 2 }, { 3, 4 }]])
!plan

!use scott

# [CALCITE-1930] AggregateExpandDistinctAggregateRules should handle multiple aggregate calls with same input ref
select count(distinct EMPNO), COUNT(SAL), MIN(SAL), MAX(SAL) from "scott".emp;
+--------+--------+--------+---------+
| EXPR$0 | EXPR$1 | EXPR$2 | EXPR$3  |
+--------+--------+--------+---------+
|     14 |     14 | 800.00 | 5000.00 |
+--------+--------+--------+---------+
(1 row)

!ok

EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t1):BIGINT NOT NULL], EXPR$0=[$t0], EXPR$1=[$t4], EXPR$2=[$t2], EXPR$3=[$t3])
  EnumerableAggregate(group=[{}], EXPR$0=[COUNT($0) FILTER $4], EXPR$1=[MIN($1) FILTER $5], EXPR$2=[MIN($2) FILTER $5], EXPR$3=[MIN($3) FILTER $5])
    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[0], expr#6=[=($t4, $t5)], expr#7=[1], expr#8=[=($t4, $t7)], proj#0..3=[{exprs}], $g_0=[$t6], $g_1=[$t8])
      EnumerableAggregate(group=[{0}], groups=[[{0}, {}]], EXPR$1=[COUNT($5)], EXPR$2=[MIN($5)], EXPR$3=[MAX($5)], $g=[GROUPING($0)])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-1930] AggregateExpandDistinctAggregateRules should handle multiple aggregate calls with same input ref
select count(distinct DEPTNO), COUNT(JOB), MIN(SAL), MAX(SAL) from "scott".emp;
+--------+--------+--------+---------+
| EXPR$0 | EXPR$1 | EXPR$2 | EXPR$3  |
+--------+--------+--------+---------+
|      3 |     14 | 800.00 | 5000.00 |
+--------+--------+--------+---------+
(1 row)

!ok

EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t1):BIGINT NOT NULL], EXPR$0=[$t0], EXPR$1=[$t4], EXPR$2=[$t2], EXPR$3=[$t3])
  EnumerableAggregate(group=[{}], EXPR$0=[COUNT($0) FILTER $4], EXPR$1=[MIN($1) FILTER $5], EXPR$2=[MIN($2) FILTER $5], EXPR$3=[MIN($3) FILTER $5])
    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[0], expr#6=[=($t4, $t5)], expr#7=[1], expr#8=[=($t4, $t7)], proj#0..3=[{exprs}], $g_0=[$t6], $g_1=[$t8])
      EnumerableAggregate(group=[{7}], groups=[[{7}, {}]], EXPR$1=[COUNT($2)], EXPR$2=[MIN($5)], EXPR$3=[MAX($5)], $g=[GROUPING($7)])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-1930] AggregateExpandDistinctAggregateRules should handle multiple aggregate calls with same input ref
select MGR, count(distinct DEPTNO), COUNT(JOB), MIN(SAL), MAX(SAL) from "scott".emp group by MGR;
+------+--------+--------+---------+---------+
| MGR  | EXPR$1 | EXPR$2 | EXPR$3  | EXPR$4  |
+------+--------+--------+---------+---------+
| 7566 |      1 |      2 | 3000.00 | 3000.00 |
| 7698 |      1 |      5 |  950.00 | 1600.00 |
| 7782 |      1 |      1 | 1300.00 | 1300.00 |
| 7788 |      1 |      1 | 1100.00 | 1100.00 |
| 7839 |      3 |      3 | 2450.00 | 2975.00 |
| 7902 |      1 |      1 |  800.00 |  800.00 |
|      |      1 |      1 | 5000.00 | 5000.00 |
+------+--------+--------+---------+---------+
(7 rows)

!ok

EnumerableCalc(expr#0..4=[{inputs}], expr#5=[CAST($t2):BIGINT NOT NULL], proj#0..1=[{exprs}], EXPR$2=[$t5], EXPR$3=[$t3], EXPR$4=[$t4])
  EnumerableAggregate(group=[{0}], EXPR$1=[COUNT($1) FILTER $5], EXPR$2=[MIN($2) FILTER $6], EXPR$3=[MIN($3) FILTER $6], EXPR$4=[MIN($4) FILTER $6])
    EnumerableCalc(expr#0..5=[{inputs}], expr#6=[0], expr#7=[=($t5, $t6)], expr#8=[1], expr#9=[=($t5, $t8)], proj#0..4=[{exprs}], $g_0=[$t7], $g_1=[$t9])
      EnumerableAggregate(group=[{3, 7}], groups=[[{3, 7}, {3}]], EXPR$2=[COUNT($2)], EXPR$3=[MIN($5)], EXPR$4=[MAX($5)], $g=[GROUPING($3, $7)])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-1930] AggregateExpandDistinctAggregateRules should handle multiple aggregate calls with same input ref
select MGR, count(distinct DEPTNO, JOB), MIN(SAL), MAX(SAL) from "scott".emp group by MGR;
+------+--------+---------+---------+
| MGR  | EXPR$1 | EXPR$2  | EXPR$3  |
+------+--------+---------+---------+
| 7566 |      1 | 3000.00 | 3000.00 |
| 7698 |      2 |  950.00 | 1600.00 |
| 7782 |      1 | 1300.00 | 1300.00 |
| 7788 |      1 | 1100.00 | 1100.00 |
| 7839 |      3 | 2450.00 | 2975.00 |
| 7902 |      1 |  800.00 |  800.00 |
|      |      1 | 5000.00 | 5000.00 |
+------+--------+---------+---------+
(7 rows)

!ok

EnumerableAggregate(group=[{0}], EXPR$1=[COUNT($1, $2) FILTER $5], EXPR$2=[MIN($3) FILTER $6], EXPR$3=[MIN($4) FILTER $6])
  EnumerableCalc(expr#0..5=[{inputs}], expr#6=[0], expr#7=[=($t5, $t6)], expr#8=[3], expr#9=[=($t5, $t8)], MGR=[$t1], DEPTNO=[$t2], JOB=[$t0], EXPR$2=[$t3], EXPR$3=[$t4], $g_0=[$t7], $g_3=[$t9])
    EnumerableAggregate(group=[{2, 3, 7}], groups=[[{2, 3, 7}, {3}]], EXPR$2=[MIN($5)], EXPR$3=[MAX($5)], $g=[GROUPING($3, $7, $2)])
      EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-2366] Add support for ANY_VALUE function
# Without GROUP BY clause
SELECT any_value(empno) as anyempno from "scott".emp;
+----------+
| ANYEMPNO |
+----------+
|     7934 |
+----------+
(1 row)

!ok

EnumerableAggregate(group=[{}], ANYEMPNO=[ANY_VALUE($0)])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-2366] Add support for ANY_VALUE function
# With GROUP BY clause
SELECT any_value(empno) as anyempno from "scott".emp group by sal;
+----------+
| ANYEMPNO |
+----------+
|     7369 |
|     7499 |
|     7566 |
|     7654 |
|     7698 |
|     7782 |
|     7839 |
|     7844 |
|     7876 |
|     7900 |
|     7902 |
|     7934 |
+----------+
(12 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], ANYEMPNO=[$t1])
  EnumerableAggregate(group=[{5}], ANYEMPNO=[ANY_VALUE($0)])
    EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-1776, CALCITE-2402] REGR_COUNT
SELECT regr_count(COMM, SAL) as "REGR_COUNT(COMM, SAL)",
   regr_count(EMPNO, SAL) as "REGR_COUNT(EMPNO, SAL)"
from "scott".emp;
+-----------------------+------------------------+
| REGR_COUNT(COMM, SAL) | REGR_COUNT(EMPNO, SAL) |
+-----------------------+------------------------+
|                     4 |                     14 |
+-----------------------+------------------------+
(1 row)

!ok

EnumerableAggregate(group=[{}], REGR_COUNT(COMM, SAL)=[REGR_COUNT($6, $5)], REGR_COUNT(EMPNO, SAL)=[REGR_COUNT($5)])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-1776, CALCITE-2402] REGR_SXX, REGR_SXY, REGR_SYY
SELECT
  regr_sxx(COMM, SAL) as "REGR_SXX(COMM, SAL)",
  regr_syy(COMM, SAL) as "REGR_SYY(COMM, SAL)",
  regr_sxx(SAL, COMM) as "REGR_SXX(SAL, COMM)",
  regr_syy(SAL, COMM) as "REGR_SYY(SAL, COMM)"
from "scott".emp;
+---------------------+---------------------+---------------------+---------------------+
| REGR_SXX(COMM, SAL) | REGR_SYY(COMM, SAL) | REGR_SXX(SAL, COMM) | REGR_SYY(SAL, COMM) |
+---------------------+---------------------+---------------------+---------------------+
|          95000.0000 |        1090000.0000 |        1090000.0000 |          95000.0000 |
+---------------------+---------------------+---------------------+---------------------+
(1 row)

!ok

# [CALCITE-1776, CALCITE-2402] COVAR_POP, COVAR_SAMP, VAR_SAMP, VAR_POP
SELECT
  covar_pop(COMM, COMM) as "COVAR_POP(COMM, COMM)",
  covar_samp(SAL, SAL) as "COVAR_SAMP(SAL, SAL)",
  var_pop(COMM) as "VAR_POP(COMM)",
  var_samp(SAL) as "VAR_SAMP(SAL)"
from "scott".emp;
+-----------------------+----------------------+---------------+-------------------+
| COVAR_POP(COMM, COMM) | COVAR_SAMP(SAL, SAL) | VAR_POP(COMM) | VAR_SAMP(SAL)     |
+-----------------------+----------------------+---------------+-------------------+
|           272500.0000 |    1398313.873626374 |   272500.0000 | 1398313.873626374 |
+-----------------------+----------------------+---------------+-------------------+
(1 row)

!ok

# [CALCITE-1776, CALCITE-2402] REGR_COUNT with group by
SELECT SAL, regr_count(COMM, SAL) as "REGR_COUNT(COMM, SAL)",
   regr_count(EMPNO, SAL) as "REGR_COUNT(EMPNO, SAL)"
from "scott".emp group by SAL;
+---------+-----------------------+------------------------+
| SAL     | REGR_COUNT(COMM, SAL) | REGR_COUNT(EMPNO, SAL) |
+---------+-----------------------+------------------------+
| 1100.00 |                     0 |                      1 |
| 1250.00 |                     2 |                      2 |
| 1300.00 |                     0 |                      1 |
| 1500.00 |                     1 |                      1 |
| 1600.00 |                     1 |                      1 |
| 2450.00 |                     0 |                      1 |
| 2850.00 |                     0 |                      1 |
| 2975.00 |                     0 |                      1 |
| 3000.00 |                     0 |                      2 |
| 5000.00 |                     0 |                      1 |
|  800.00 |                     0 |                      1 |
|  950.00 |                     0 |                      1 |
+---------+-----------------------+------------------------+
(12 rows)

!ok

# [CALCITE-1776, CALCITE-2402] COVAR_POP, COVAR_SAMP, VAR_SAMP, VAR_POP with group by
SELECT
  MONTH(HIREDATE) as "MONTH",
  covar_samp(SAL, COMM) as "COVAR_SAMP(SAL, COMM)",
  var_pop(COMM) as "VAR_POP(COMM)",
  var_samp(SAL) as "VAR_SAMP(SAL)"
from "scott".emp
group by MONTH(HIREDATE);
+-------+-----------------------+---------------+-------------------+
| MONTH | COVAR_SAMP(SAL, COMM) | VAR_POP(COMM) | VAR_SAMP(SAL)     |
+-------+-----------------------+---------------+-------------------+
|     1 |                       |               |      1201250.0000 |
|    11 |                       |               |                   |
|    12 |                       |               | 1510833.333333334 |
|     2 |           -35000.0000 |    10000.0000 |  831458.333333335 |
|     4 |                       |               |                   |
|     5 |                       |               |                   |
|     6 |                       |               |                   |
|     9 |          -175000.0000 |   490000.0000 |        31250.0000 |
+-------+-----------------------+---------------+-------------------+
(8 rows)

!ok

# [CALCITE-2224] WITHIN GROUP clause for aggregate functions
select deptno, collect(empno) within group (order by empno asc) as empnos
from "scott".emp
group by deptno;

+--------+--------------------------------------+
| DEPTNO | EMPNOS                               |
+--------+--------------------------------------+
|     10 | [7782, 7839, 7934]                   |
|     20 | [7369, 7566, 7788, 7876, 7902]       |
|     30 | [7499, 7521, 7654, 7698, 7844, 7900] |
+--------+--------------------------------------+
(3 rows)

!ok
EnumerableAggregate(group=[{7}], EMPNOS=[COLLECT($0) WITHIN GROUP ([0])])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

select deptno, collect(empno) within group (order by empno desc) as empnos
from "scott".emp
group by deptno;

+--------+--------------------------------------+
| DEPTNO | EMPNOS                               |
+--------+--------------------------------------+
|     10 | [7934, 7839, 7782]                   |
|     20 | [7902, 7876, 7788, 7566, 7369]       |
|     30 | [7900, 7844, 7698, 7654, 7521, 7499] |
+--------+--------------------------------------+
(3 rows)

!ok
EnumerableAggregate(group=[{7}], EMPNOS=[COLLECT($0) WITHIN GROUP ([0 DESC])])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

select
deptno,
collect(empno) as empnos_1,
collect(empno) within group (order by empno desc) as empnos_2
from "scott".emp
group by deptno;

+--------+--------------------------------------+--------------------------------------+
| DEPTNO | EMPNOS_1                             | EMPNOS_2                             |
+--------+--------------------------------------+--------------------------------------+
|     10 | [7782, 7839, 7934]                   | [7934, 7839, 7782]                   |
|     20 | [7369, 7566, 7788, 7876, 7902]       | [7902, 7876, 7788, 7566, 7369]       |
|     30 | [7499, 7521, 7654, 7698, 7844, 7900] | [7900, 7844, 7698, 7654, 7521, 7499] |
+--------+--------------------------------------+--------------------------------------+
(3 rows)

!ok
EnumerableAggregate(group=[{7}], EMPNOS_1=[COLLECT($0)], EMPNOS_2=[COLLECT($0) WITHIN GROUP ([0 DESC])])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

select deptno, collect(empno) within group (order by empno desc)
filter (where empno > 7500) as empnos
from "scott".emp
group by deptno;

+--------+--------------------------------+
| DEPTNO | EMPNOS                         |
+--------+--------------------------------+
|     10 | [7934, 7839, 7782]             |
|     20 | [7902, 7876, 7788, 7566]       |
|     30 | [7900, 7844, 7698, 7654, 7521] |
+--------+--------------------------------+
(3 rows)

!ok
EnumerableAggregate(group=[{0}], EMPNOS=[COLLECT($1) WITHIN GROUP ([1 DESC]) FILTER $2])
  EnumerableCalc(expr#0..7=[{inputs}], expr#8=[7500], expr#9=[>($t0, $t8)], DEPTNO=[$t7], EMPNO=[$t0], $f2=[$t9])
    EnumerableTableScan(table=[[scott, EMP]])
!plan

select deptno, collect(empno) within group (order by empno desc) as empnos1,
collect(empno) within group (order by empno asc) as empnos2
from "scott".emp
group by deptno;

+--------+--------------------------------------+--------------------------------------+
| DEPTNO | EMPNOS1                              | EMPNOS2                              |
+--------+--------------------------------------+--------------------------------------+
|     10 | [7934, 7839, 7782]                   | [7782, 7839, 7934]                   |
|     20 | [7902, 7876, 7788, 7566, 7369]       | [7369, 7566, 7788, 7876, 7902]       |
|     30 | [7900, 7844, 7698, 7654, 7521, 7499] | [7499, 7521, 7654, 7698, 7844, 7900] |
+--------+--------------------------------------+--------------------------------------+
(3 rows)

!ok
EnumerableAggregate(group=[{7}], EMPNOS1=[COLLECT($0) WITHIN GROUP ([0 DESC])], EMPNOS2=[COLLECT($0) WITHIN GROUP ([0])])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

# Aggregate WITHIN GROUP with JOIN
select dept.deptno,
  collect(sal) within group (order by sal desc) as s,
  collect(sal) within group (order by 1)as s1,
  collect(sal) within group (order by sal) filter (where sal > 2000) as s2
from "scott".emp
join "scott".dept using (deptno)
group by dept.deptno;

+--------+-------------------------------------------------------+-------------------------------------------------------+-----------------------------+
| DEPTNO | S                                                     | S1                                                    | S2                          |
+--------+-------------------------------------------------------+-------------------------------------------------------+-----------------------------+
|     10 | [5000.00, 2450.00, 1300.00]                           | [2450.00, 5000.00, 1300.00]                           | [2450.00, 5000.00]          |
|     20 | [3000.00, 3000.00, 2975.00, 1100.00, 800.00]          | [800.00, 2975.00, 3000.00, 1100.00, 3000.00]          | [2975.00, 3000.00, 3000.00] |
|     30 | [2850.00, 1600.00, 1500.00, 1250.00, 1250.00, 950.00] | [1600.00, 1250.00, 1250.00, 2850.00, 1500.00, 950.00] | [2850.00]                   |
+--------+-------------------------------------------------------+-------------------------------------------------------+-----------------------------+
(3 rows)

!ok
EnumerableAggregate(group=[{0}], S=[COLLECT($1) WITHIN GROUP ([1 DESC])], S1=[COLLECT($1) WITHIN GROUP ([2])], S2=[COLLECT($1) WITHIN GROUP ([1]) FILTER $3])
  EnumerableCalc(expr#0..3=[{inputs}], expr#4=[1], expr#5=[2000], expr#6=[>($t2, $t5)], expr#7=[IS TRUE($t6)], DEPTNO=[$t0], SAL=[$t2], $f2=[$t4], $f3=[$t7])
    EnumerableHashJoin(condition=[=($0, $3)], joinType=[inner])
      EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
        EnumerableTableScan(table=[[scott, DEPT]])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

select deptno, collect(empno + 1) within group (order by 1) as empnos
from "scott".emp
group by deptno;

+--------+--------------------------------------+
| DEPTNO | EMPNOS                               |
+--------+--------------------------------------+
|     10 | [7783, 7840, 7935]                   |
|     20 | [7370, 7567, 7789, 7877, 7903]       |
|     30 | [7500, 7522, 7655, 7699, 7845, 7901] |
+--------+--------------------------------------+
(3 rows)

!ok
EnumerableAggregate(group=[{0}], EMPNOS=[COLLECT($1) WITHIN GROUP ([2])])
  EnumerableCalc(expr#0..7=[{inputs}], expr#8=[1], expr#9=[+($t0, $t8)], DEPTNO=[$t7], $f1=[$t9], $f2=[$t8])
    EnumerableTableScan(table=[[scott, EMP]])
!plan

# BIT_AND, BIT_OR aggregate functions
select bit_and(deptno), bit_or(deptno) from "scott".emp;
+--------+--------+
| EXPR$0 | EXPR$1 |
+--------+--------+
|      0 |     30 |
+--------+--------+
(1 row)

!ok

select deptno, bit_and(empno), bit_or(empno) from "scott".emp group by deptno;
+--------+--------+--------+
| DEPTNO | EXPR$1 | EXPR$2 |
+--------+--------+--------+
|     10 |   7686 |   7935 |
|     20 |   7168 |   8191 |
|     30 |   7168 |   8191 |
+--------+--------+--------+
(3 rows)

!ok

# Based on [DRUID-7593] Exact distinct-COUNT with complex expression (CASE, IN) throws
# NullPointerException
WITH wikipedia AS (
  SELECT empno AS delta,
    CASE WHEN deptno = 10 THEN 'true' ELSE 'false' END AS isRobot,
    ename AS "user"
  FROM "scott".emp)
SELECT COUNT(DISTINCT
    CASE WHEN (((CASE WHEN wikipedia.delta IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
                      THEN REPLACE('Yes', 'Yes', 'Yes')
                      ELSE REPLACE('No', 'No', 'No') END) = 'No'))
         AND (wikipedia.isRobot = 'true')
         THEN (wikipedia."user")
         ELSE NULL END)
  - (MAX(CASE WHEN (((CASE WHEN wikipedia.delta IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
                           THEN REPLACE('Yes', 'Yes', 'Yes')
                           ELSE REPLACE('No', 'No', 'No') END) = 'No'))
              AND (wikipedia.isRobot = 'true')
              THEN NULL
              ELSE -9223372036854775807 END)
       + 9223372036854775807 + 1) AS "wikipedia.count_distinct_filters_that_dont_work"
FROM wikipedia
LIMIT 500;
+-------------------------------------------------+
| wikipedia.count_distinct_filters_that_dont_work |
+-------------------------------------------------+
|                                               2 |
+-------------------------------------------------+
(1 row)

!ok

# [CALCITE-2266] JSON_OBJECTAGG, JSON_ARRAYAGG
!use post

select gender, json_objectagg(ename: deptno absent on null) from emp group by gender;
+--------+-------------------------------------------------------+
| GENDER | EXPR$1                                                |
+--------+-------------------------------------------------------+
| F      | {"Eve":50,"Grace":60,"Susan":30,"Alice":30,"Jane":10} |
| M      | {"Adam":50,"Bob":10,"Eric":20}                        |
+--------+-------------------------------------------------------+
(2 rows)

!ok

select gender, json_arrayagg(json_object('ename': ename, 'deptno': deptno) format json) from emp group by gender;
+--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| GENDER | EXPR$1                                                                                                                                                                               |
+--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| F      | [{"ename":"Jane","deptno":10},{"ename":"Susan","deptno":30},{"ename":"Alice","deptno":30},{"ename":"Eve","deptno":50},{"ename":"Grace","deptno":60},{"ename":"Wilma","deptno":null}] |
| M      | [{"ename":"Bob","deptno":10},{"ename":"Eric","deptno":20},{"ename":"Adam","deptno":50}]                                                                                              |
+--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
(2 rows)

!ok

select json_object('deptno': deptno, 'employees': json_arrayagg(json_object('ename': ename, 'gender': gender) format json) format json) from emp group by deptno;
+-------------------------------------------------------------------------------------------+
| EXPR$0                                                                                    |
+-------------------------------------------------------------------------------------------+
| {"employees":[{"ename":"Adam","gender":"M"},{"ename":"Eve","gender":"F"}],"deptno":50}    |
| {"employees":[{"ename":"Eric","gender":"M"}],"deptno":20}                                 |
| {"employees":[{"ename":"Grace","gender":"F"}],"deptno":60}                                |
| {"employees":[{"ename":"Jane","gender":"F"},{"ename":"Bob","gender":"M"}],"deptno":10}    |
| {"employees":[{"ename":"Susan","gender":"F"},{"ename":"Alice","gender":"F"}],"deptno":30} |
| {"employees":[{"ename":"Wilma","gender":"F"}],"deptno":null}                              |
+-------------------------------------------------------------------------------------------+
(6 rows)

!ok

# [CALCITE-2786] Add order by clause support for JSON_ARRAYAGG
select gender,
json_arrayagg(deptno order by deptno),
json_arrayagg(deptno order by deptno desc)
from emp group by gender;
+--------+------------------+------------------+
| GENDER | EXPR$1           | EXPR$2           |
+--------+------------------+------------------+
| F      | [10,30,30,50,60] | [60,50,30,30,10] |
| M      | [10,20,50]       | [50,20,10]       |
+--------+------------------+------------------+
(2 rows)

!ok
EnumerableAggregate(group=[{1}], EXPR$1=[JSON_ARRAYAGG_ABSENT_ON_NULL($0) WITHIN GROUP ([0])], EXPR$2=[JSON_ARRAYAGG_ABSENT_ON_NULL($0) WITHIN GROUP ([0 DESC])])
  EnumerableUnion(all=[true])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[10], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[10], expr#2=['M'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[20], expr#2=['M'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[30], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[30], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[50], expr#2=['M'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[50], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[60], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[null:INTEGER], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
!plan

# [CALCITE-2787] Json aggregate calls with different null clause get incorrectly merged
# during converting from SQL to relational algebra
select gender,
json_arrayagg(deptno),
json_arrayagg(deptno null on null)
from emp group by gender;
+--------+------------------+-----------------------+
| GENDER | EXPR$1           | EXPR$2                |
+--------+------------------+-----------------------+
| F      | [10,30,30,50,60] | [10,30,30,50,60,null] |
| M      | [10,20,50]       | [10,20,50]            |
+--------+------------------+-----------------------+
(2 rows)

!ok
EnumerableAggregate(group=[{1}], EXPR$1=[JSON_ARRAYAGG_ABSENT_ON_NULL($0)], EXPR$2=[JSON_ARRAYAGG_NULL_ON_NULL($0)])
  EnumerableUnion(all=[true])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[10], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[10], expr#2=['M'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[20], expr#2=['M'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[30], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[30], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[50], expr#2=['M'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[50], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[60], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[null:INTEGER], expr#2=['F'], EXPR$1=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
!plan

select gender,
json_objectagg(ename: deptno),
json_objectagg(ename: deptno absent on null)
from emp group by gender;
+--------+--------------------------------------------------------------------+-------------------------------------------------------+
| GENDER | EXPR$1                                                             | EXPR$2                                                |
+--------+--------------------------------------------------------------------+-------------------------------------------------------+
| F      | {"Eve":50,"Grace":60,"Wilma":null,"Susan":30,"Alice":30,"Jane":10} | {"Eve":50,"Grace":60,"Susan":30,"Alice":30,"Jane":10} |
| M      | {"Adam":50,"Bob":10,"Eric":20}                                     | {"Adam":50,"Bob":10,"Eric":20}                        |
+--------+--------------------------------------------------------------------+-------------------------------------------------------+
(2 rows)

!ok
EnumerableAggregate(group=[{2}], EXPR$1=[JSON_OBJECTAGG_NULL_ON_NULL($0, $1)], EXPR$2=[JSON_OBJECTAGG_ABSENT_ON_NULL($0, $1)])
  EnumerableUnion(all=[true])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Jane'], expr#2=[10], expr#3=['F'], EXPR$0=[$t1], EXPR$1=[$t2], EXPR$2=[$t3])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Bob'], expr#2=[10], expr#3=['M'], EXPR$0=[$t1], EXPR$1=[$t2], EXPR$2=[$t3])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Eric'], expr#2=[20], expr#3=['M'], EXPR$0=[$t1], EXPR$1=[$t2], EXPR$2=[$t3])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Susan'], expr#2=[30], expr#3=['F'], EXPR$0=[$t1], EXPR$1=[$t2], EXPR$2=[$t3])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Alice'], expr#2=[30], expr#3=['F'], EXPR$0=[$t1], EXPR$1=[$t2], EXPR$2=[$t3])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Adam'], expr#2=[50], expr#3=['M'], EXPR$0=[$t1], EXPR$1=[$t2], EXPR$2=[$t3])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Eve'], expr#2=[50], expr#3=['F'], EXPR$0=[$t1], EXPR$1=[$t2], EXPR$2=[$t3])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Grace'], expr#2=[60], expr#3=['F'], EXPR$0=[$t1], EXPR$1=[$t2], EXPR$2=[$t3])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Wilma'], expr#2=[null:INTEGER], expr#3=['F'], EXPR$0=[$t1], EXPR$1=[$t2], EXPR$2=[$t3])
      EnumerableValues(tuples=[[{ 0 }]])
!plan

select listagg(ename) as combined_name from emp;
+------------------------------------------------+
| COMBINED_NAME                                  |
+------------------------------------------------+
| Jane,Bob,Eric,Susan,Alice,Adam,Eve,Grace,Wilma |
+------------------------------------------------+
(1 row)

!ok

select listagg(ename) within group(order by gender, ename) as combined_name from emp;
+------------------------------------------------+
| COMBINED_NAME                                  |
+------------------------------------------------+
| Alice,Eve,Grace,Jane,Susan,Wilma,Adam,Bob,Eric |
+------------------------------------------------+
(1 row)

!ok

EnumerableAggregate(group=[{}], COMBINED_NAME=[LISTAGG($0) WITHIN GROUP ([1, 0])])
  EnumerableUnion(all=[true])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Jane'], expr#2=['F'], EXPR$0=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Bob'], expr#2=['M'], EXPR$0=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Eric'], expr#2=['M'], EXPR$0=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Susan'], expr#2=['F'], EXPR$0=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Alice'], expr#2=['F'], EXPR$0=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Adam'], expr#2=['M'], EXPR$0=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Eve'], expr#2=['F'], EXPR$0=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Grace'], expr#2=['F'], EXPR$0=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=['Wilma'], expr#2=['F'], EXPR$0=[$t1], EXPR$2=[$t2])
      EnumerableValues(tuples=[[{ 0 }]])
!plan

select
  listagg(ename) within group(order by deptno, ename) as default_listagg_sep,
  listagg(ename, '; ') within group(order by deptno, ename desc) as custom_listagg_sep
from emp group by gender;
+----------------------------------+---------------------------------------+
| DEFAULT_LISTAGG_SEP              | CUSTOM_LISTAGG_SEP                    |
+----------------------------------+---------------------------------------+
| Bob,Eric,Adam                    | Bob; Eric; Adam                       |
| Jane,Alice,Susan,Eve,Grace,Wilma | Jane; Susan; Alice; Eve; Grace; Wilma |
+----------------------------------+---------------------------------------+
(2 rows)

!ok

# End agg.iq
