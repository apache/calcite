# set-op.iq - Queries involving INTERESECT, EXCEPT and UNION
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
!use blank
!set outputformat mysql

# Intersect all
select * from
(select x, y from (values (1, 'a'), (1, 'a'), (1, 'a'), (2, 'b'), (3, 'c')) as t(x, y))
intersect all
(select x, y from (values (1, 'a'), (1, 'a'), (2, 'c'), (4, 'x')) as t2(x, y));
+---+---+
| X | Y |
+---+---+
| 1 | a |
| 1 | a |
+---+---+
(2 rows)

!ok

# Intersect
select * from
(select x, y from (values (1, 'a'), (1, 'a'), (1, 'a'), (2, 'b'), (3, 'c')) as t(x, y))
intersect
(select x, y from (values (1, 'a'), (1, 'a'), (2, 'c'), (4, 'x')) as t2(x, y));
+---+---+
| X | Y |
+---+---+
| 1 | a |
+---+---+
(1 row)

!ok

!use scott

!set planner-rules "
-EnumerableRules.ENUMERABLE_INTERSECT_RULE,
-AGGREGATE_REMOVE"
# AGGREGATE_REMOVE is disabled as it would remove the inner COUNTs
# as the grouping columns are unique

# Intersect rewrite as aggregation + union with partial aggregation pushdown
select empno, ename from emp where deptno = 10
intersect
select empno, ename from emp where empno >= 150;

EnumerableCalc(expr#0..2=[{inputs}], expr#3=[2:BIGINT], expr#4=[=($t2, $t3)], proj#0..1=[{exprs}], $condition=[$t4])
  EnumerableAggregate(group=[{0, 1}], agg#0=[COUNT()])
    EnumerableUnion(all=[true])
      EnumerableAggregate(group=[{0, 1}], agg#0=[COUNT()])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t7):INTEGER], expr#9=[10], expr#10=[=($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
          EnumerableTableScan(table=[[scott, EMP]])
      EnumerableAggregate(group=[{0, 1}], agg#0=[COUNT()])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t0):INTEGER NOT NULL], expr#9=[150], expr#10=[>=($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
          EnumerableTableScan(table=[[scott, EMP]])
!plan
+-------+--------+
| EMPNO | ENAME  |
+-------+--------+
|  7782 | CLARK  |
|  7839 | KING   |
|  7934 | MILLER |
+-------+--------+
(3 rows)

!ok
!set planner-rules original

!use scott

!set planner-rules "
-CoreRules.INTERSECT_TO_DISTINCT,
-EnumerableRules.ENUMERABLE_INTERSECT_RULE,
+CoreRules.INTERSECT_TO_DISTINCT_NO_AGGREGATE_PUSHDOWN"

# Intersect rewrite as aggregation + union without partial aggregation pushdown
select empno, ename from emp where deptno = 10
intersect
select empno, ename from emp where empno >= 150;

EnumerableCalc(expr#0..3=[{inputs}], expr#4=[0], expr#5=[>($t2, $t4)], expr#6=[>($t3, $t4)], expr#7=[AND($t5, $t6)], proj#0..1=[{exprs}], $condition=[$t7])
  EnumerableAggregate(group=[{0, 1}], count_i0=[COUNT() FILTER $2], count_i1=[COUNT() FILTER $3])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[0], expr#4=[=($t2, $t3)], expr#5=[1], expr#6=[=($t2, $t5)], proj#0..1=[{exprs}], $f3=[$t4], $f4=[$t6])
      EnumerableUnion(all=[true])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[0], expr#9=[CAST($t7):INTEGER], expr#10=[10], expr#11=[=($t9, $t10)], proj#0..1=[{exprs}], i=[$t8], $condition=[$t11])
          EnumerableTableScan(table=[[scott, EMP]])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[1], expr#9=[CAST($t0):INTEGER NOT NULL], expr#10=[150], expr#11=[>=($t9, $t10)], proj#0..1=[{exprs}], i=[$t8], $condition=[$t11])
          EnumerableTableScan(table=[[scott, EMP]])
!plan
+-------+--------+
| EMPNO | ENAME  |
+-------+--------+
|  7782 | CLARK  |
|  7839 | KING   |
|  7934 | MILLER |
+-------+--------+
(3 rows)

!ok
!set planner-rules original

# Intersect all with null value rows
select * from
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1))), (cast(NULL as int), cast(NULL as varchar(1)))) as t(x, y))
intersect all
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1)))) as t2(x, y));
+---+---+
| X | Y |
+---+---+
|   |   |
|   |   |
+---+---+
(2 rows)

!ok

# Intersect with null value rows
select * from
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1))), (cast(NULL as int), cast(NULL as varchar(1)))) as t(x, y))
intersect
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1)))) as t2(x, y));
+---+---+
| X | Y |
+---+---+
|   |   |
+---+---+
(1 row)

!ok

# Union all
select * from
(select x, y from (values (1, 'a'), (1, 'a'), (2, 'b'), (3, 'c')) as t(x, y))
union all
(select x, y from (values (1, 'a'), (2, 'c'), (4, 'x')) as t2(x, y));
+---+---+
| X | Y |
+---+---+
| 1 | a |
| 1 | a |
| 1 | a |
| 2 | b |
| 2 | c |
| 3 | c |
| 4 | x |
+---+---+
(7 rows)

!ok

# Union
select * from
(select x, y from (values (1, 'a'), (1, 'a'), (2, 'b'), (3, 'c')) as t(x, y))
union
(select x, y from (values (1, 'a'), (2, 'c'), (4, 'x')) as t2(x, y));
+---+---+
| X | Y |
+---+---+
| 1 | a |
| 2 | b |
| 2 | c |
| 3 | c |
| 4 | x |
+---+---+
(5 rows)

!ok

# Union all with null value rows
select * from
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1))), (cast(NULL as int), cast(NULL as varchar(1)))) as t(x, y))
union all
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1)))) as t2(x, y));
+---+---+
| X | Y |
+---+---+
|   |   |
|   |   |
|   |   |
|   |   |
|   |   |
+---+---+
(5 rows)

!ok

# Union with null value rows
select * from
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1))), (cast(NULL as int), cast(NULL as varchar(1)))) as t(x, y))
union
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1)))) as t2(x, y));
+---+---+
| X | Y |
+---+---+
|   |   |
+---+---+
(1 row)

!ok

# Except all
select * from
(select x, y from (values (1, 'a'), (1, 'a'), (1, 'a'), (2, 'b'), (3, 'c')) as t(x, y))
except all
(select x, y from (values (1, 'a'), (2, 'c'), (4, 'x')) as t2(x, y));
+---+---+
| X | Y |
+---+---+
| 1 | a |
| 1 | a |
| 2 | b |
| 3 | c |
+---+---+
(4 rows)

!ok

# Except
select * from
(select x, y from (values (1, 'a'), (1, 'a'), (1, 'a'), (2, 'b'), (3, 'c')) as t(x, y))
except
(select x, y from (values (1, 'a'), (2, 'c'), (4, 'x')) as t2(x, y));
+---+---+
| X | Y |
+---+---+
| 2 | b |
| 3 | c |
+---+---+
(2 rows)

!ok

# Except all with null value rows
select * from
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1))), (cast(NULL as int), cast(NULL as varchar(1)))) as t(x, y))
except all
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1)))) as t2(x, y));
+---+---+
| X | Y |
+---+---+
|   |   |
+---+---+
(1 row)

!ok

# Except with null value rows
select * from
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1))), (cast(NULL as int), cast(NULL as varchar(1)))) as t(x, y))
except
(select x, y from (values (cast(NULL as int), cast(NULL as varchar(1))),
  (cast(NULL as int), cast(NULL as varchar(1)))) as t2(x, y));
+---+---+
| X | Y |
+---+---+
+---+---+
(0 rows)

!ok

!use scott

# Parentheses at top level
(select * from emp where deptno = 10
 union all
 select * from emp where job = 'CLERK')
intersect
select * from emp where job = 'CLERK';
+-------+--------+-------+------+------------+---------+------+--------+
| EMPNO | ENAME  | JOB   | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+--------+-------+------+------------+---------+------+--------+
|  7369 | SMITH  | CLERK | 7902 | 1980-12-17 |  800.00 |      |     20 |
|  7876 | ADAMS  | CLERK | 7788 | 1987-05-23 | 1100.00 |      |     20 |
|  7900 | JAMES  | CLERK | 7698 | 1981-12-03 |  950.00 |      |     30 |
|  7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 |      |     10 |
+-------+--------+-------+------+------------+---------+------+--------+
(4 rows)

!ok

# Join at top level is illegal
# (Postgres doesn't allow it either)
(emp natural join dept)
intersect
select * from emp natural join dept where job = 'CLERK';
Non-query expression encountered in illegal context
!error

# [CALCITE-6303] UNION with CTE(s) results in exception during query validation
(SELECT 123)
UNION
(WITH t (col) AS (VALUES (456)) SELECT col FROM t);
+--------+
| EXPR$0 |
+--------+
|    123 |
|    456 |
+--------+
(2 rows)

!ok

# [CALCITE-6955] PruneEmptyRules does not handle the all attribute of SetOp correctly
select * from (values (10, 1), (30, 3), (30, 3)) as t (x, y)
union
select * from (values (20, 2)) as t (x, y) where x > 30;
+----+---+
| X  | Y |
+----+---+
| 10 | 1 |
| 30 | 3 |
+----+---+
(2 rows)

!ok

EnumerableAggregate(group=[{0, 1}])
  EnumerableValues(tuples=[[{ 10, 1 }, { 30, 3 }, { 30, 3 }]])
!plan

# [CALCITE-6955] PruneEmptyRules does not handle the all attribute of SetOp correctly
select * from (values (30, 3), (30, 3)) as t (x, y)
except
select * from (values (20, 2)) as t (x, y) where x > 30;
+----+---+
| X  | Y |
+----+---+
| 30 | 3 |
+----+---+
(1 row)

!ok

EnumerableCalc(expr#0=[{inputs}], expr#1=[3], proj#0..1=[{exprs}])
  EnumerableAggregate(group=[{0}])
    EnumerableValues(tuples=[[{ 30, 3 }, { 30, 3 }]])
!plan

# End set-op.iq
