# scalar.iq - Scalar sub-queries
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
!set outputformat mysql
!use scott

select deptno, (select min(empno) from "scott".emp where deptno = dept.deptno) as x from "scott".dept;
+--------+------+
| DEPTNO | X    |
+--------+------+
|     10 | 7782 |
|     20 | 7369 |
|     30 | 7499 |
|     40 |      |
+--------+------+
(4 rows)

!ok

select deptno, (select count(*) from "scott".emp where deptno = dept.deptno) as x from "scott".dept;
+--------+---+
| DEPTNO | X |
+--------+---+
|     10 | 3 |
|     20 | 5 |
|     30 | 6 |
|     40 | 0 |
+--------+---+
(4 rows)

!ok

select deptno, (select count(*) from "scott".emp where deptno = dept.deptno group by deptno) as x from "scott".dept;
+--------+---+
| DEPTNO | X |
+--------+---+
|     10 | 3 |
|     20 | 5 |
|     30 | 6 |
|     40 |   |
+--------+---+
(4 rows)

!ok

# cast necessary to prevent overflow
select deptno, (select sum(cast(empno as int)) from "scott".emp where deptno = dept.deptno group by deptno) as x from "scott".dept;
+--------+-------+
| DEPTNO | X     |
+--------+-------+
|     10 | 23555 |
|     20 | 38501 |
|     30 | 46116 |
|     40 |       |
+--------+-------+
(4 rows)

!ok

select deptno, (select count(*) from "scott".emp where 1 = 0) as x from "scott".dept;
+--------+---+
| DEPTNO | X |
+--------+---+
|     10 | 0 |
|     20 | 0 |
|     30 | 0 |
|     40 | 0 |
+--------+---+
(4 rows)

!ok

select deptno, (select count(*) from "scott".emp where 1 = 0 group by ()) as x from "scott".dept;
+--------+---+
| DEPTNO | X |
+--------+---+
|     10 | 0 |
|     20 | 0 |
|     30 | 0 |
|     40 | 0 |
+--------+---+
(4 rows)

!ok

select deptno, (select sum(empno) from "scott".emp where 1 = 0) as x from "scott".dept;
+--------+---+
| DEPTNO | X |
+--------+---+
|     10 |   |
|     20 |   |
|     30 |   |
|     40 |   |
+--------+---+
(4 rows)

!ok

select deptno, (select empno from "scott".emp where 1 = 0) as x from "scott".dept;
+--------+---+
| DEPTNO | X |
+--------+---+
|     10 |   |
|     20 |   |
|     30 |   |
|     40 |   |
+--------+---+
(4 rows)

!ok

select deptno, (select empno from "scott".emp where emp.deptno = dept.deptno and job = 'PRESIDENT') as x from "scott".dept;
+--------+------+
| DEPTNO | X    |
+--------+------+
|     10 | 7839 |
|     20 |      |
|     30 |      |
|     40 |      |
+--------+------+
(4 rows)

!ok

select deptno, (select sum(empno) from "scott".emp where 1 = 0 group by ()) as x from "scott".dept;
+--------+---+
| DEPTNO | X |
+--------+---+
|     10 |   |
|     20 |   |
|     30 |   |
|     40 |   |
+--------+---+
(4 rows)

!ok

# [CALCITE-709] Errors with LIMIT inside scalar sub-query
select deptno, (select sum(cast(empno as bigint)) from "scott".emp where deptno = dept.deptno limit 1) as x from "scott".dept;
+--------+-------+
| DEPTNO | X     |
+--------+-------+
|     10 | 23555 |
|     20 | 38501 |
|     30 | 46116 |
|     40 |       |
+--------+-------+
(4 rows)

!ok

# [CALCITE-709] Errors with LIMIT inside scalar sub-query
select deptno, (select sum(cast(empno as bigint)) from "scott".emp where deptno = dept.deptno limit 0) as x from "scott".dept;
+--------+---+
| DEPTNO | X |
+--------+---+
|     10 |   |
|     20 |   |
|     30 |   |
|     40 |   |
+--------+---+
(4 rows)

!ok

# [CALCITE-709] Errors with LIMIT inside scalar sub-query
select deptno, (select deptno from "scott".emp where deptno = dept.deptno limit 1) as x from "scott".dept;
+--------+----+
| DEPTNO | X  |
+--------+----+
|     10 | 10 |
|     20 | 20 |
|     30 | 30 |
|     40 |    |
+--------+----+
(4 rows)

!ok

select deptno, (select deptno from "scott".emp where deptno = dept.deptno limit 0) as x from "scott".dept;
+--------+---+
| DEPTNO | X |
+--------+---+
|     10 |   |
|     20 |   |
|     30 |   |
|     40 |   |
+--------+---+
(4 rows)

!ok

# [CALCITE-709] Errors with LIMIT inside scalar sub-query
select deptno, (select empno from "scott".emp where deptno = dept.deptno order by empno limit 1) as x from "scott".dept;
+--------+------+
| DEPTNO | X    |
+--------+------+
|     10 | 7782 |
|     20 | 7369 |
|     30 | 7499 |
|     40 |      |
+--------+------+
(4 rows)

!ok

select deptno, (select empno from "scott".emp order by empno limit 1) as x from "scott".dept;
+--------+------+
| DEPTNO | X    |
+--------+------+
|     10 | 7369 |
|     20 | 7369 |
|     30 | 7369 |
|     40 | 7369 |
+--------+------+
(4 rows)

!ok

# Scalar subquery on VALUES; based on a query mentioned in
# [CALCITE-3244] RelDecorrelator unable to decorrelate expression with filter and aggregate on top
select
    (select count(t2.id)
        from (values (1), (2)) t2(id)
        where t2.id = t1.id) as c
from (values (1), (2)) t1(id);
+---+
| C |
+---+
| 1 |
| 1 |
+---+
(2 rows)

!ok

select
    (select count(t2.id)
        from (values (1), (2), (2), (4)) t2(id)
        where t2.id = t1.id) as c
from (values (1), (3)) t1(id);
+---+
| C |
+---+
| 1 |
| 0 |
+---+
(2 rows)

!ok

# Scalar subquery using EXISTS on VALUES
select exists (select count(t2.id)
               from (values (1), (2), (2), (4)) t2(id)
               where t2.id = t1.id) as e
from (values (1), (3)) t1(id);
+------+
| E    |
+------+
| true |
| true |
+------+
(2 rows)

!ok

# Variation on previous query
select exists (select *
               from (values (1), (2), (2), (4)) t2(id)
               where t2.id = t1.id) as e
from (values (1), (3)) t1(id);
+-------+
| E     |
+-------+
| false |
| true  |
+-------+
(2 rows)

!ok

# Several scalar sub-queries reference different tables in FROM list
select
    (select ename from emp where empno = empnos.empno) as emp_name,
    (select dname from dept where deptno = deptnos.deptno) as dept_name
  from (values (7369), (7499)) as empnos(empno), (values (10), (20)) as deptnos(deptno) order by 1, 2;
+----------+------------+
| EMP_NAME | DEPT_NAME  |
+----------+------------+
| ALLEN    | ACCOUNTING |
| ALLEN    | RESEARCH   |
| SMITH    | ACCOUNTING |
| SMITH    | RESEARCH   |
+----------+------------+
(4 rows)

!ok

# [CALCITE-7348] Remove redundant extraction correlation variables when Trim Project Fields

!set trimfields true

SELECT empno, (SELECT COUNT(*) AS c
FROM "scott".emp
WHERE mgr < "t".mgr) AS "$f1"
FROM "scott".emp as "t"
WHERE sal > 10;
+-------+-----+
| EMPNO | $f1 |
+-------+-----+
|  7369 |  12 |
|  7499 |   2 |
|  7521 |   2 |
|  7566 |   9 |
|  7654 |   2 |
|  7698 |   9 |
|  7782 |   9 |
|  7788 |   0 |
|  7839 |   0 |
|  7844 |   2 |
|  7876 |   8 |
|  7900 |   2 |
|  7902 |   0 |
|  7934 |   7 |
+-------+-----+
(14 rows)

!ok

!if (use_old_decorr) {
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], expr#5=[0:BIGINT], expr#6=[CASE($t4, $t5, $t3)], EMPNO=[$t0], $f1=[$t6])
  EnumerableHashJoin(condition=[IS NOT DISTINCT FROM($1, $2)], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], EMPNO=[$t0], MGR=[$t3], $condition=[$t10])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t2)], expr#4=[0], expr#5=[CASE($t3, $t2, $t4)], MGR0=[$t0], C=[$t5])
      EnumerableHashJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableAggregate(group=[{3}])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
            EnumerableTableScan(table=[[scott, EMP]])
        EnumerableAggregate(group=[{2}], C=[COUNT()])
          EnumerableNestedLoopJoin(condition=[<($1, $2)], joinType=[inner])
            EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], MGR=[$t3])
              EnumerableTableScan(table=[[scott, EMP]])
            EnumerableAggregate(group=[{3}])
              EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
                EnumerableTableScan(table=[[scott, EMP]])
!plan
!}

!if (use_new_decorr) {
EnumerableCalc(expr#0..3=[{inputs}], EMPNO=[$t0], $f1=[$t3])
  EnumerableHashJoin(condition=[IS NOT DISTINCT FROM($1, $2)], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], EMPNO=[$t0], MGR=[$t3], $condition=[$t10])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t2)], expr#4=[0], expr#5=[CASE($t3, $t2, $t4)], MGR=[$t0], $f2=[$t5])
      EnumerableHashJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableAggregate(group=[{3}])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
            EnumerableTableScan(table=[[scott, EMP]])
        EnumerableAggregate(group=[{2}], C=[COUNT()])
          EnumerableNestedLoopJoin(condition=[<($1, $2)], joinType=[inner])
            EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], MGR=[$t3])
              EnumerableTableScan(table=[[scott, EMP]])
            EnumerableAggregate(group=[{3}])
              EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
                EnumerableTableScan(table=[[scott, EMP]])
!plan
!}

!set trimfields false

SELECT empno, (SELECT COUNT(*) AS c
FROM "scott".emp
WHERE mgr < "t".mgr) AS "$f1"
FROM "scott".emp as "t"
WHERE sal > 10;
+-------+-----+
| EMPNO | $f1 |
+-------+-----+
|  7369 |  12 |
|  7499 |   2 |
|  7521 |   2 |
|  7566 |   9 |
|  7654 |   2 |
|  7698 |   9 |
|  7782 |   9 |
|  7788 |   0 |
|  7839 |   0 |
|  7844 |   2 |
|  7876 |   8 |
|  7900 |   2 |
|  7902 |   0 |
|  7934 |   7 |
+-------+-----+
(14 rows)

!ok

!if (use_old_decorr) {
EnumerableCalc(expr#0..9=[{inputs}], expr#10=[IS NULL($t9)], expr#11=[0:BIGINT], expr#12=[CASE($t10, $t11, $t9)], EMPNO=[$t0], $f1=[$t12])
  EnumerableHashJoin(condition=[IS NOT DISTINCT FROM($3, $8)], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t2)], expr#4=[0], expr#5=[CASE($t3, $t2, $t4)], MGR0=[$t0], C=[$t5])
      EnumerableHashJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableAggregate(group=[{3}])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
            EnumerableTableScan(table=[[scott, EMP]])
        EnumerableAggregate(group=[{8}], C=[COUNT()])
          EnumerableNestedLoopJoin(condition=[<($3, $8)], joinType=[inner])
            EnumerableTableScan(table=[[scott, EMP]])
            EnumerableAggregate(group=[{3}])
              EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
                EnumerableTableScan(table=[[scott, EMP]])
!plan
!}

!if (use_new_decorr) {
EnumerableCalc(expr#0..10=[{inputs}], EMPNO=[$t0], $f1=[$t10])
  EnumerableHashJoin(condition=[IS NOT DISTINCT FROM($3, $8)], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t2)], expr#4=[0], expr#5=[CASE($t3, $t2, $t4)], proj#0..1=[{exprs}], $f2=[$t5])
      EnumerableHashJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableAggregate(group=[{3}])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
            EnumerableTableScan(table=[[scott, EMP]])
        EnumerableAggregate(group=[{8}], C=[COUNT()])
          EnumerableNestedLoopJoin(condition=[<($3, $8)], joinType=[inner])
            EnumerableTableScan(table=[[scott, EMP]])
            EnumerableAggregate(group=[{3}])
              EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[10.00:DECIMAL(12, 2)], expr#10=[>($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
                EnumerableTableScan(table=[[scott, EMP]])
!plan
!}

# Reset to default value true
!set trimfields true

# [CALCITE-7057] NPE when decorrelating query containing nested correlated subqueries
# Nested scalar sub-queries
select
    (select ename || ' from dept '
                  || (select dname from dept where deptno = emp.deptno and emp.empno = empnos.empno)
       from emp
    ) as ename_from_dept
from (values (7369), (7499)) as empnos(empno) order by 1;
more than one value in agg SINGLE_VALUE
!error
# End scalar.iq
