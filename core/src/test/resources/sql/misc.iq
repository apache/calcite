# misc.iq - Miscellaneous queries
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
!use post
!set outputformat mysql

# [CALCITE-356] Allow column references of the form schema.table.column
select "hr"."emps"."empid"
from "hr"."emps";
+-------+
| empid |
+-------+
|   100 |
|   110 |
|   150 |
|   200 |
+-------+
(4 rows)

!ok

# [CALCITE-881] Allow schema.table.column references in GROUP BY
select "hr"."emps"."empid", count(*) as c
from "hr"."emps"
group by "hr"."emps"."empid";
+-------+---+
| empid | C |
+-------+---+
|   100 | 1 |
|   110 | 1 |
|   150 | 1 |
|   200 | 1 |
+-------+---+
(4 rows)

!ok

select distinct "hr"."emps"."empid" + 1 as e
from "hr"."emps"
group by "hr"."emps"."empid";
+-----+
| E   |
+-----+
| 101 |
| 111 |
| 151 |
| 201 |
+-----+
(4 rows)

!ok

# Case-sensitive errors
select empid from "hr"."emps";
Column 'EMPID' not found in any table; did you mean 'empid'?
!error

select empid from "hr".emps;
Object 'EMPS' not found within 'hr'; did you mean 'emps'?
!error

select empid from hr.emps;
Object 'HR' not found; did you mean 'hr'?
!error

select empid from bad_schema.bad_table;
Object 'BAD_SCHEMA' not found
!error

select empid from bad_cat.bad_schema.bad_table;
Object 'BAD_CAT' not found
!error

select empid from "catalog".bad_schema.bad_table;
Object 'catalog' not found
!error

select empid from catalog.bad_schema.bad_table;
Object 'CATALOG' not found
!error

select empid from catalog.HR.bad_table;
Object 'CATALOG' not found
!error

select empid from catalog."hr".bad_table;
Object 'CATALOG' not found
!error

select empid from catalog."hr".emp;
Object 'CATALOG' not found
!error

select empid from HR.bad_table;
Object 'HR' not found; did you mean 'hr'?
!error

select empid from "HR".bad_table;
Object 'HR' not found; did you mean 'hr'?
!error

select empid from HR."emps";
Object 'HR' not found; did you mean 'hr'?
!error

select empid from "hr".bad_table;
Object 'BAD_TABLE' not found within 'hr'
!error

select empid from "hr".emps;
Object 'EMPS' not found within 'hr'; did you mean 'emps'?
!error

select empid from "hr";
Object 'hr' not found
!error

# [CALCITE-307] CAST(timestamp AS DATE) gives ClassCastException
# Based on [DRILL-1051]
with data(c_row, c_timestamp) as (select * from (values
    (1, TIMESTAMP '1997-01-02 03:04:05'),
    (2, TIMESTAMP '1997-01-02 00:00:00'),
    (3, TIMESTAMP '2001-09-22 18:19:20'),
    (4, TIMESTAMP '1997-02-10 17:32:01'),
    (5, TIMESTAMP '1997-02-10 17:32:00'),
    (6, TIMESTAMP '1997-02-11 17:32:01'),
    (7, TIMESTAMP '1997-02-12 17:32:01'),
    (8, TIMESTAMP '1997-02-13 17:32:01'),
    (9, TIMESTAMP '1997-02-14 17:32:01'),
    (10, TIMESTAMP '1997-02-15 17:32:01'),
    (11, TIMESTAMP '1997-02-16 17:32:01'),
    (13, TIMESTAMP '0097-02-16 17:32:01'),
    (14, TIMESTAMP '0597-02-16 17:32:01'),
    (15, TIMESTAMP '1097-02-16 17:32:01'),
    (16, TIMESTAMP '1697-02-16 17:32:01'),
    (17, TIMESTAMP '1797-02-16 17:32:01'),
    (18, TIMESTAMP '1897-02-16 17:32:01'),
    (19, TIMESTAMP '1997-02-16 17:32:01'),
    (20, TIMESTAMP '2097-02-16 17:32:01'),
    (21, TIMESTAMP '1996-02-28 17:32:01'),
    (22, TIMESTAMP '1996-02-29 17:32:01'),
    (23, TIMESTAMP '1996-03-01 17:32:01')))
select cast(c_timestamp as varchar(20)), cast(c_timestamp as date) from data where c_row <> 12;

+---------------------+------------+
| EXPR_0              | EXPR_1     |
+---------------------+------------+
| 1997-01-02 03:04:05 | 1997-01-02 |
| 1997-01-02 00:00:00 | 1997-01-02 |
| 2001-09-22 18:19:20 | 2001-09-22 |
| 1997-02-10 17:32:01 | 1997-02-10 |
| 1997-02-10 17:32:00 | 1997-02-10 |
| 1997-02-11 17:32:01 | 1997-02-11 |
| 1997-02-12 17:32:01 | 1997-02-12 |
| 1997-02-13 17:32:01 | 1997-02-13 |
| 1997-02-14 17:32:01 | 1997-02-14 |
| 1997-02-15 17:32:01 | 1997-02-15 |
| 1997-02-16 17:32:01 | 1997-02-16 |
| 1697-02-16 17:32:01 | 1697-02-16 |
| 1797-02-16 17:32:01 | 1797-02-16 |
| 1897-02-16 17:32:01 | 1897-02-16 |
| 1997-02-16 17:32:01 | 1997-02-16 |
| 2097-02-16 17:32:01 | 2097-02-16 |
| 1996-02-28 17:32:01 | 1996-02-28 |
| 1996-02-29 17:32:01 | 1996-02-29 |
| 1996-03-01 17:32:01 | 1996-03-01 |
| 0097-02-16 17:32:01 | 0097-02-16 |
| 0597-02-16 17:32:01 | 0597-02-16 |
| 1097-02-16 17:32:01 | 1097-02-16 |
+---------------------+------------+
(22 rows)

!ok

# [DRILL-1149]
select *, upper("name")
from "hr"."emps";
+-------+--------+-----------+---------+------------+-----------+
| empid | deptno | name      | salary  | commission | EXPR_5    |
+-------+--------+-----------+---------+------------+-----------+
|   100 |     10 | Bill      | 10000.0 |       1000 | BILL      |
|   110 |     10 | Theodore  | 11500.0 |        250 | THEODORE  |
|   150 |     10 | Sebastian |  7000.0 |            | SEBASTIAN |
|   200 |     20 | Eric      |  8000.0 |        500 | ERIC      |
+-------+--------+-----------+---------+------------+-----------+
(4 rows)

!ok

# [DRILL-1199] Order by nested inside a where clause fails
# (Not that it's right, but Tableau does it.)
select * from (select * from "hr"."emps" order by "empid") where (0=1);
+-------+--------+------+--------+------------+
| empid | deptno | name | salary | commission |
+-------+--------+------+--------+------------+
+-------+--------+------+--------+------------+
(0 rows)

!ok

# [DRILL-1842] Tableau, again
select count(distinct "salary") as c
from "hr"."emps"
join "hr"."depts" on "emps"."deptno" = "depts"."deptno"
having count(1) > 0;
+---+
| C |
+---+
| 3 |
+---+
(1 row)

!ok

# [CALCITE-340] SqlToRelConverter fails with complex join condition
select e."deptno", d."deptno"
from "hr"."emps" as e
join "hr"."depts" as d
on ( e."deptno" + 1 - 1 = d."deptno" + 2 - 2  and e."deptno" + 10 - 10 = d."deptno" + 20 - 20);
+--------+--------+
| deptno | deptno |
+--------+--------+
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
+--------+--------+
(3 rows)

!ok

# [CALCITE-340] SqlToRelConverter fails with complex join condition. Switch LHS and RHS.
select e."deptno", d."deptno"
from "hr"."emps" as e
join "hr"."depts" as d
on ( d."deptno" + 2 - 2 = e."deptno" + 1 - 1  and d."deptno" + 20 - 20 = e."deptno" + 10 - 10);
+--------+--------+
| deptno | deptno |
+--------+--------+
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
+--------+--------+
(3 rows)

!ok

# [CALCITE-340] SqlToRelConverter fails with complex join condition. Switch LHS and RHS.
select e."deptno", d."deptno"
from "hr"."emps" as e
join "hr"."depts" as d
on ( d."deptno" + 2 - 2 = e."deptno" + 1 - 1  and e."deptno" + 10 - 10 = d."deptno" + 20 - 20);
+--------+--------+
| deptno | deptno |
+--------+--------+
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
+--------+--------+
(3 rows)

!ok

# [CALCITE-377] Mixed equi and non-equi join
select e."empid", d."name", e."name"
from "hr"."emps" as e
join "hr"."depts" as d
on e."deptno" = d."deptno"
and e."name" <> d."name";
+-------+-------+-----------+
| empid | name  | name      |
+-------+-------+-----------+
|   100 | Sales | Bill      |
|   110 | Sales | Theodore  |
|   150 | Sales | Sebastian |
+-------+-------+-----------+
(3 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], empid=[_t0], name=[_t4], name0=[_t2])
  EnumerableHashJoin(condition=[AND(=(_1, _3), <>(CAST(_2):VARCHAR, CAST(_4):VARCHAR))], joinType=[inner])
    EnumerableCalc(expr#0..4=[{inputs}], proj#0..2=[{exprs}])
      EnumerableTableScan(table=[[hr, emps]])
    EnumerableCalc(expr#0..3=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[hr, depts]])
!plan

# Same query, expressed using WHERE.
select e."empid", d."name", e."name"
from "hr"."emps" as e,
  "hr"."depts" as d
where e."deptno" = d."deptno"
and e."name" <> d."name";
+-------+-------+-----------+
| empid | name  | name      |
+-------+-------+-----------+
|   100 | Sales | Bill      |
|   110 | Sales | Theodore  |
|   150 | Sales | Sebastian |
+-------+-------+-----------+
(3 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], empid=[_t0], name=[_t4], name0=[_t2])
  EnumerableHashJoin(condition=[AND(=(_1, _3), <>(CAST(_2):VARCHAR, CAST(_4):VARCHAR))], joinType=[inner])
    EnumerableCalc(expr#0..4=[{inputs}], proj#0..2=[{exprs}])
      EnumerableTableScan(table=[[hr, emps]])
    EnumerableCalc(expr#0..3=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[hr, depts]])
!plan

# Un-correlated EXISTS
select "deptno" from "hr"."depts"
where exists (select 1 from "hr"."emps");
+--------+
| deptno |
+--------+
|     10 |
|     30 |
|     40 |
+--------+
(3 rows)

!ok
EnumerableCalc(expr#0..1=[{inputs}], deptno=[_t0])
  EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
    EnumerableCalc(expr#0..3=[{inputs}], deptno=[_t0])
      EnumerableTableScan(table=[[hr, depts]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[IS NOT NULL(_t0)], _f0=[_t0], _condition=[_t1])
      EnumerableAggregate(group=[{}], agg#0=[MIN(_0)])
        EnumerableCalc(expr#0..4=[{inputs}], expr#5=[true], _f0=[_t5])
          EnumerableTableScan(table=[[hr, emps]])
!plan

# Un-correlated NOT EXISTS
select "deptno" from "hr"."depts"
where not exists (select 1 from "hr"."emps");
+--------+
| deptno |
+--------+
+--------+
(0 rows)

!ok
EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL(_t1)], deptno=[_t0], _condition=[_t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..3=[{inputs}], deptno=[_t0])
      EnumerableTableScan(table=[[hr, depts]])
    EnumerableAggregate(group=[{}], agg#0=[MIN(_0)])
      EnumerableCalc(expr#0..4=[{inputs}], expr#5=[true], _f0=[_t5])
        EnumerableTableScan(table=[[hr, emps]])
!plan

# Un-correlated EXISTS (table empty)
select "deptno" from "hr"."depts"
where exists (select 1 from "hr"."emps" where "empid" < 0);
+--------+
| deptno |
+--------+
+--------+
(0 rows)

!ok
EnumerableCalc(expr#0..1=[{inputs}], deptno=[_t0])
  EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
    EnumerableCalc(expr#0..3=[{inputs}], deptno=[_t0])
      EnumerableTableScan(table=[[hr, depts]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[IS NOT NULL(_t0)], _f0=[_t0], _condition=[_t1])
      EnumerableAggregate(group=[{}], agg#0=[MIN(_0)])
        EnumerableCalc(expr#0..4=[{inputs}], expr#5=[true], expr#6=[0], expr#7=[<(_t0, _t6)], _f0=[_t5], _condition=[_t7])
          EnumerableTableScan(table=[[hr, emps]])
!plan

# Un-correlated NOT EXISTS (table empty)
select "deptno" from "hr"."depts"
where not exists (select 1 from "hr"."emps" where "empid" < 0);
+--------+
| deptno |
+--------+
|     10 |
|     30 |
|     40 |
+--------+
(3 rows)

!ok
EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL(_t1)], deptno=[_t0], _condition=[_t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..3=[{inputs}], deptno=[_t0])
      EnumerableTableScan(table=[[hr, depts]])
    EnumerableAggregate(group=[{}], agg#0=[MIN(_0)])
      EnumerableCalc(expr#0..4=[{inputs}], expr#5=[true], expr#6=[0], expr#7=[<(_t0, _t6)], _f0=[_t5], _condition=[_t7])
        EnumerableTableScan(table=[[hr, emps]])
!plan

# EXISTS
select * from "hr"."emps"
where exists (
  select 1 from "hr"."depts" where "depts"."deptno" = "emps"."deptno");
+-------+--------+-----------+---------+------------+
| empid | deptno | name      | salary  | commission |
+-------+--------+-----------+---------+------------+
|   100 |     10 | Bill      | 10000.0 |       1000 |
|   110 |     10 | Theodore  | 11500.0 |        250 |
|   150 |     10 | Sebastian |  7000.0 |            |
+-------+--------+-----------+---------+------------+
(3 rows)

!ok
EnumerableHashJoin(condition=[=(_1, _5)], joinType=[semi])
  EnumerableTableScan(table=[[hr, emps]])
  EnumerableTableScan(table=[[hr, depts]])
!plan

# NOT EXISTS
# Right results, but it would be better if the plan used EnumerableCorrelateRel; see [CALCITE-374]
select * from "hr"."emps"
where not exists (
  select 1 from "hr"."depts" where "depts"."deptno" = "emps"."deptno");
+-------+--------+------+--------+------------+
| empid | deptno | name | salary | commission |
+-------+--------+------+--------+------------+
|   200 |     20 | Eric | 8000.0 |        500 |
+-------+--------+------+--------+------------+
(1 row)

!ok
EnumerableCalc(expr#0..6=[{inputs}], expr#7=[IS NULL(_t6)], proj#0..4=[{exprs}], _condition=[_t7])
  EnumerableHashJoin(condition=[=(_1, _5)], joinType=[left])
    EnumerableTableScan(table=[[hr, emps]])
    EnumerableAggregate(group=[{0}], agg#0=[MIN(_1)])
      EnumerableCalc(expr#0..3=[{inputs}], expr#4=[true], deptno=[_t0], _f0=[_t4])
        EnumerableTableScan(table=[[hr, depts]])
!plan

# NOT EXISTS .. OR NOT EXISTS
# Right results, but it would be better if the plan used EnumerableCorrelateRel; see [CALCITE-374]
select * from "hr"."emps"
where not exists (
  select 1 from "hr"."depts" where "depts"."deptno" = "emps"."deptno")
or not exists (
  select 1 from "hr"."depts" where "depts"."deptno" + 90 = "emps"."empid");

+-------+--------+-----------+---------+------------+
| empid | deptno | name      | salary  | commission |
+-------+--------+-----------+---------+------------+
|   110 |     10 | Theodore  | 11500.0 |        250 |
|   150 |     10 | Sebastian |  7000.0 |            |
|   200 |     20 | Eric      |  8000.0 |        500 |
+-------+--------+-----------+---------+------------+
(3 rows)

!ok
EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NULL(_t5)], expr#9=[IS NULL(_t7)], expr#10=[OR(_t8, _t9)], proj#0..4=[{exprs}], _condition=[_t10])
  EnumerableHashJoin(condition=[=(_0, _6)], joinType=[left])
    EnumerableCalc(expr#0..6=[{inputs}], proj#0..4=[{exprs}], _f0=[_t6])
      EnumerableHashJoin(condition=[=(_1, _5)], joinType=[left])
        EnumerableTableScan(table=[[hr, emps]])
        EnumerableAggregate(group=[{0}], agg#0=[MIN(_1)])
          EnumerableCalc(expr#0..3=[{inputs}], expr#4=[true], deptno=[_t0], _f0=[_t4])
            EnumerableTableScan(table=[[hr, depts]])
    EnumerableAggregate(group=[{0}], agg#0=[MIN(_1)])
      EnumerableCalc(expr#0..3=[{inputs}], expr#4=[90], expr#5=[+(_t0, _t4)], expr#6=[true], _f4=[_t5], _f0=[_t6])
        EnumerableTableScan(table=[[hr, depts]])
!plan

# Left join to a relation with one row is recognized as a trivial semi-join
# and eliminated.
select e."deptno"
from "hr"."emps" as e
left join (select count(*) from "hr"."depts") on true;
+--------+
| deptno |
+--------+
|     10 |
|     10 |
|     10 |
|     20 |
+--------+
(4 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], deptno=[_t1])
  EnumerableTableScan(table=[[hr, emps]])
!plan

# Filter combined with an OR filter.
select * from (
  select * from "hr"."emps" as e
  where e."deptno" < 30) as e
where e."deptno" > 10 or e."name" = 'Sebastian';
+-------+--------+-----------+--------+------------+
| empid | deptno | name      | salary | commission |
+-------+--------+-----------+--------+------------+
|   150 |     10 | Sebastian | 7000.0 |            |
|   200 |     20 | Eric      | 8000.0 |        500 |
+-------+--------+-----------+--------+------------+
(2 rows)

!ok

# Filter combined with an AND filter. Test case for
# [CALCITE-389] MergeFilterRule should flatten AND condition
select * from (
  select * from "hr"."emps" as e
  where e."deptno" < 30) as e
where e."deptno" >= 10 and e."name" = 'Sebastian';
+-------+--------+-----------+--------+------------+
| empid | deptno | name      | salary | commission |
+-------+--------+-----------+--------+------------+
|   150 |     10 | Sebastian | 7000.0 |            |
+-------+--------+-----------+--------+------------+
(1 row)

!ok

# [CALCITE-393] If no fields are projected from a table, field trimmer should
# project a dummy expression
select 1 from "hr"."emps";
+--------+
| EXPR_0 |
+--------+
|      1 |
|      1 |
|      1 |
|      1 |
+--------+
(4 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], expr#5=[1], EXPR_0=[_t5])
  EnumerableTableScan(table=[[hr, emps]])
!plan

# [CALCITE-393] for table scan under join
select count(*) as c from "hr"."emps", "hr"."depts";
+----+
| C  |
+----+
| 12 |
+----+
(1 row)

!ok
EnumerableAggregate(group=[{}], C=[COUNT()])
  EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[0], DUMMY=[_t4])
      EnumerableTableScan(table=[[hr, depts]])
    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[0], DUMMY=[_t5])
      EnumerableTableScan(table=[[hr, emps]])
!plan

# [CALCITE-345] AssertionError in RexToLixTranslator comparing to date literal
!use catchall
select count(*) as c from "everyTypes" where "sqlDate" = DATE '1970-01-01';
+---+
| C |
+---+
| 1 |
+---+
(1 row)

!ok
select count(*) as c from "everyTypes" where "sqlDate" = DATE '1971-02-03';
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok
select count(*) as c from "everyTypes" where "sqlDate" > DATE '1970-01-01';
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok
select count(*) as c from "everyTypes" where "sqlTime" = TIME '01:23:45';
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok
select count(*) as c from "everyTypes" where "sqlTimestamp" = TIMESTAMP '1970-01-01 01:23:45';
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok
select count(*) as c from "everyTypes" where "utilDate" = TIMESTAMP '1970-01-01 01:23:45';
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok

# [CALCITE-715] Add PERIOD type constructor and period operators (CONTAINS, PRECEDES, etc.)
select period("sqlDate", INTERVAL '1' YEAR) as p
from "everyTypes";
+------------+
| P          |
+------------+
| {0, 12}    |
| {null, 12} |
+------------+
(2 rows)

!ok

!use foodmart

select count(*) as c
from "customer"
where period ("birthdate", DATE '1970-02-05') contains DATE '1964-01-01';
EnumerableAggregate(group=[{}], C=[COUNT()])
  EnumerableCalc(expr#0..28=[{inputs}], expr#29=[1970-02-05], expr#30=[<=(_t16, _t29)], expr#31=[CASE(_t30, _t16, _t29)], expr#32=[1964-01-01], expr#33=[<=(_t31, _t32)], expr#34=[CASE(_t30, _t29, _t16)], expr#35=[>=(_t34, _t32)], expr#36=[AND(_t33, _t35)], proj#0..28=[{exprs}], _condition=[_t36])
    EnumerableTableScan(table=[[foodmart2, customer]])
!plan
+------+
| C    |
+------+
| 7918 |
+------+
(1 row)

!ok

# [CALCITE-346] Add commutative join rule
#
# 3-way join that does not require bushy join.  Best plan is: sales_fact_1997 as
# left-most leaf, then customer (with filter), then product.
select *
from "sales_fact_1997" as s
  join "customer" as c on s."customer_id" = c."customer_id"
  join "product" as p on s."product_id" = p."product_id"
where c."city" = 'San Francisco';
EnumerableHashJoin(condition=[=(_0, _38)], joinType=[inner])
  EnumerableHashJoin(condition=[=(_2, _8)], joinType=[inner])
    EnumerableTableScan(table=[[foodmart2, sales_fact_1997]])
    EnumerableCalc(expr#0..28=[{inputs}], expr#29=['San Francisco':VARCHAR(30)], expr#30=[=(_t9, _t29)], proj#0..28=[{exprs}], _condition=[_t30])
      EnumerableTableScan(table=[[foodmart2, customer]])
  EnumerableTableScan(table=[[foodmart2, product]])
!plan

# 4-way join whose optimal plan requires bushy join.
#
# In the plan, note that filters on customer.city and product_department are
# pushed down. And the plan is a bushy join, with sub-joins (product_class,
# product) and (sales_fact_1997, customer).  However, scan(sales_fact_1997)
# should be left-most leaf, but is not because CommutativeJoinRule is currently
# disabled.
!use foodmart
select *
from "sales_fact_1997" as s
  join "customer" as c on s."customer_id" = c."customer_id"
  join "product" as p on s."product_id" = p."product_id"
  join "product_class" as pc on p."product_class_id" = pc."product_class_id"
where c."city" = 'San Francisco'
 and pc."product_department" = 'Snacks';
EnumerableCalc(expr#0..56=[{inputs}], product_id=[_t20], time_id=[_t21], customer_id=[_t22], promotion_id=[_t23], store_id=[_t24], store_sales=[_t25], store_cost=[_t26], unit_sales=[_t27], customer_id0=[_t28], account_num=[_t29], lname=[_t30], fname=[_t31], mi=[_t32], address1=[_t33], address2=[_t34], address3=[_t35], address4=[_t36], city=[_t37], state_province=[_t38], postal_code=[_t39], country=[_t40], customer_region_id=[_t41], phone1=[_t42], phone2=[_t43], birthdate=[_t44], marital_status=[_t45], yearly_income=[_t46], gender=[_t47], total_children=[_t48], num_children_at_home=[_t49], education=[_t50], date_accnt_opened=[_t51], member_card=[_t52], occupation=[_t53], houseowner=[_t54], num_cars_owned=[_t55], fullname=[_t56], product_class_id=[_t5], product_id0=[_t6], brand_name=[_t7], product_name=[_t8], SKU=[_t9], SRP=[_t10], gross_weight=[_t11], net_weight=[_t12], recyclable_package=[_t13], low_fat=[_t14], units_per_case=[_t15], cases_per_pallet=[_t16], shelf_width=[_t17], shelf_height=[_t18], shelf_depth=[_t19], product_class_id0=[_t0], product_subcategory=[_t1], product_category=[_t2], product_department=[_t3], product_family=[_t4])
  EnumerableHashJoin(condition=[=(_6, _20)], joinType=[inner])
    EnumerableHashJoin(condition=[=(_0, _5)], joinType=[inner])
      EnumerableCalc(expr#0..4=[{inputs}], expr#5=['Snacks':VARCHAR(30)], expr#6=[=(_t3, _t5)], proj#0..4=[{exprs}], _condition=[_t6])
        EnumerableTableScan(table=[[foodmart2, product_class]])
      EnumerableTableScan(table=[[foodmart2, product]])
    EnumerableHashJoin(condition=[=(_2, _8)], joinType=[inner])
      EnumerableTableScan(table=[[foodmart2, sales_fact_1997]])
      EnumerableCalc(expr#0..28=[{inputs}], expr#29=['San Francisco':VARCHAR(30)], expr#30=[=(_t9, _t29)], proj#0..28=[{exprs}], _condition=[_t30])
        EnumerableTableScan(table=[[foodmart2, customer]])
!plan

# Check that when filters are merged, duplicate conditions are eliminated.
select * from (
  select * from "days"
  where "day" = 1)
where "day" = 1;
EnumerableCalc(expr#0..1=[{inputs}], expr#2=[1], expr#3=[=(_t0, _t2)], proj#0..1=[{exprs}], _condition=[_t3])
  EnumerableTableScan(table=[[foodmart2, days]])
!plan

# [HIVE-5873] Semi-join to count sub-query
# [CALCITE-365] AssertionError while translating query with WITH and correlated sub-query
with parts (PNum, OrderOnHand)
     as (select * from (values (3, 6), (10, 1), (8, 0)) as t(PNum, OrderOnHand)),
  supply (PNum, Qty)
     as (select * from (values (3, 4), (3, 2), (10, 1)))
select pnum
from parts p
where orderOnHand
     in (select count(*) from supply s
          where s.pnum = p.pnum);
+------+
| PNUM |
+------+
|    8 |
|   10 |
+------+
(2 rows)

!ok

# [HIVE-7362]
# Just checking that HAVING-EXISTS works.
with src (key, "value")
  as (select * from (values (1, 'a'), (2, 'z')) as t(key, "value"))
select b.key, count(*) as c
from src b
group by b.key
having exists
  (select a.key
  from src a
  where a.key = b.key and a."value" > 'val_9');
+-----+---+
| KEY | C |
+-----+---+
|   2 | 1 |
+-----+---+
(1 row)

!ok

# [CALCITE-411] Duplicate aliases
select 1 as a, 2 as a from (values (true));
+---+---+
| A | A |
+---+---+
| 1 | 2 |
+---+---+
(1 row)

!ok

select "day", "day" from "days" where "day" < 3;
+-----+-----+
| day | day |
+-----+-----+
|   1 |   1 |
|   2 |   2 |
+-----+-----+
(2 rows)

!ok

# [DERBY-5313] CASE expression in GROUP BY clause
select case when a=1 then 1 else 2 end
from "days" t1(a,x) join "days" t2(b,x) on a=b
group by case when a=1 then 1 else 2 end;
+--------+
| EXPR_0 |
+--------+
|      1 |
|      2 |
+--------+
(2 rows)

!ok

# [DERBY-4450] GROUP BY in an IN-sub-query inside HAVING clause whose select
# list is subset of group by columns.
select sum("day") from "days" group by "week_day" having "week_day" in (
  select "week_day" from "days" group by "week_day", "day");
+--------+
| EXPR_0 |
+--------+
|      1 |
|      2 |
|      3 |
|      4 |
|      5 |
|      6 |
|      7 |
+--------+
(7 rows)

!ok

# [DERBY-4701] Aggregate function on a GROUP BY column also present in a HAVING
# clause
SELECT MAX("day") as m, COUNT(T."week_day") AS c
FROM "days" T
GROUP BY T."week_day"
HAVING COUNT(T."week_day") = 1;
+---+---+
| M | C |
+---+---+
| 1 | 1 |
| 2 | 1 |
| 3 | 1 |
| 4 | 1 |
| 5 | 1 |
| 6 | 1 |
| 7 | 1 |
+---+---+
(7 rows)

!ok

# [DERBY-3616] Combinations of DISTINCT and GROUP BY
!use post
select distinct gender from emp group by gender;
+--------+
| GENDER |
+--------+
| F      |
| M      |
+--------+
(2 rows)

!ok
select distinct gender from emp group by gender, deptno;
+--------+
| GENDER |
+--------+
| F      |
| M      |
+--------+
(2 rows)

!ok
select gender, deptno from emp;
+--------+--------+
| GENDER | DEPTNO |
+--------+--------+
| F      |     10 |
| F      |     30 |
| F      |     30 |
| F      |     50 |
| F      |     60 |
| F      |        |
| M      |     10 |
| M      |     20 |
| M      |     50 |
+--------+--------+
(9 rows)

!ok
select distinct gender, deptno from emp group by gender, deptno, ename;
+--------+--------+
| GENDER | DEPTNO |
+--------+--------+
| F      |     10 |
| F      |     30 |
| F      |     50 |
| F      |     60 |
| F      |        |
| M      |     10 |
| M      |     20 |
| M      |     50 |
+--------+--------+
(8 rows)

!ok
select distinct gender, deptno from emp group by gender, deptno;
+--------+--------+
| GENDER | DEPTNO |
+--------+--------+
| F      |     10 |
| F      |     30 |
| F      |     50 |
| F      |     60 |
| F      |        |
| M      |     10 |
| M      |     20 |
| M      |     50 |
+--------+--------+
(8 rows)

!ok
select distinct gender, deptno from emp group by gender, ename, deptno;
+--------+--------+
| GENDER | DEPTNO |
+--------+--------+
| F      |     10 |
| F      |     30 |
| F      |     50 |
| F      |     60 |
| F      |        |
| M      |     10 |
| M      |     20 |
| M      |     50 |
+--------+--------+
(8 rows)

!ok
select distinct gender, sum(deptno) as s from emp group by gender, deptno;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 50 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(7 rows)

!ok
select gender, sum(deptno) as s from emp group by gender, deptno;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 50 |
| F      | 60 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(8 rows)

!ok
select gender, sum(deptno) as s from emp group by gender, ename;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 30 |
| F      | 30 |
| F      | 50 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(9 rows)

!ok
select distinct gender, sum(deptno) as s from emp group by gender, ename;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 30 |
| F      | 50 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(8 rows)

!ok
select gender, sum(deptno) as s from emp group by gender, deptno, ename;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 30 |
| F      | 30 |
| F      | 50 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(9 rows)

!ok
select distinct gender, sum(deptno) as s from emp group by gender, deptno, ename;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 30 |
| F      | 50 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(8 rows)

!ok
select distinct gender, sum(deptno) as s from emp group by gender;
+--------+-----+
| GENDER | S   |
+--------+-----+
| F      | 180 |
| M      |  80 |
+--------+-----+
(2 rows)

!ok

select distinct gender, deptno from emp group by gender;
Expression 'DEPTNO' is not being grouped
!error

select distinct gender, deptno from emp group by gender, ename;
Expression 'DEPTNO' is not being grouped
!error

select distinct gender, deptno, sum(deptno) as s from emp group by gender;
Expression 'DEPTNO' is not being grouped
!error

!use scott

# ORDER BY expression with SELECT DISTINCT
select distinct deptno, job
from "scott".emp
order by substring(job from 2 for 1), -deptno;
+--------+-----------+
| DEPTNO | JOB       |
+--------+-----------+
|     30 | SALESMAN  |
|     30 | MANAGER   |
|     20 | MANAGER   |
|     10 | MANAGER   |
|     30 | CLERK     |
|     20 | CLERK     |
|     10 | CLERK     |
|     20 | ANALYST   |
|     10 | PRESIDENT |
+--------+-----------+
(9 rows)

!ok

# [CALCITE-2180] Invalid code generated for negative of byte and short values
select -deptno as d
from "scott".dept;
+-----+
| D   |
+-----+
| -40 |
| -30 |
| -20 |
| -10 |
+-----+
(4 rows)

!ok

# [CALCITE-2099] Incorrect code generated for UNION
select count(*) as c from "scott".emp group by deptno
union
select count(*) as c from "scott".emp group by deptno;
+---+
| C |
+---+
| 3 |
| 5 |
| 6 |
+---+
(3 rows)

!ok

# Similar
select count(*) as c from "scott".emp group by job
union all
select count(*) as c from "scott".dept group by deptno;
+---+
| C |
+---+
| 1 |
| 1 |
| 1 |
| 1 |
| 1 |
| 2 |
| 3 |
| 4 |
| 4 |
+---+
(9 rows)

!ok

# [CALCITE-1864] Allow NULL literal as argument
select count(*) as c from "scott".emp where empno > null;
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok

# [CALCITE-613] Implicitly convert strings in comparisons
select * from "scott".emp where hiredate < '1981-01-02';
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok
EnumerableCalc(expr#0..7=[{inputs}], expr#8=['1981-01-02'], expr#9=[CAST(_t8):DATE NOT NULL], expr#10=[<(_t4, _t9)], proj#0..7=[{exprs}], _condition=[_t10])
  EnumerableTableScan(table=[[scott, EMP]])
!plan
select * from "scott".emp where '1981-01-02' > hiredate;
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok
select * from "scott".emp where hiredate between '1981-01-02' and '1981-06-01';
+-------+-------+----------+------+------------+---------+--------+--------+
| EMPNO | ENAME | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |
+-------+-------+----------+------+------------+---------+--------+--------+
|  7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 |     30 |
|  7521 | WARD  | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 |     30 |
|  7566 | JONES | MANAGER  | 7839 | 1981-02-04 | 2975.00 |        |     20 |
|  7698 | BLAKE | MANAGER  | 7839 | 1981-01-05 | 2850.00 |        |     30 |
+-------+-------+----------+------+------------+---------+--------+--------+
(4 rows)

!ok
select * from "scott".emp where hiredate > '1986-01-02';
+-------+-------+---------+------+------------+---------+------+--------+
| EMPNO | ENAME | JOB     | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+-------+---------+------+------------+---------+------+--------+
|  7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 |      |     20 |
|  7876 | ADAMS | CLERK   | 7788 | 1987-05-23 | 1100.00 |      |     20 |
+-------+-------+---------+------+------------+---------+------+--------+
(2 rows)

!ok
select * from "scott".emp where '1986-01-02' < hiredate;
+-------+-------+---------+------+------------+---------+------+--------+
| EMPNO | ENAME | JOB     | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+-------+---------+------+------------+---------+------+--------+
|  7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 |      |     20 |
|  7876 | ADAMS | CLERK   | 7788 | 1987-05-23 | 1100.00 |      |     20 |
+-------+-------+---------+------+------------+---------+------+--------+
(2 rows)

!ok
select * from "scott".emp where '1986-' || '01-02' < hiredate;
+-------+-------+---------+------+------------+---------+------+--------+
| EMPNO | ENAME | JOB     | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+-------+---------+------+------------+---------+------+--------+
|  7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 |      |     20 |
|  7876 | ADAMS | CLERK   | 7788 | 1987-05-23 | 1100.00 |      |     20 |
+-------+-------+---------+------+------------+---------+------+--------+
(2 rows)

!ok
select * from "scott".emp where sal < '1100';
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
|  7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 |      |     30 |
+-------+-------+-------+------+------------+--------+------+--------+
(2 rows)

!ok
select * from "scott".emp where empno in ('7369', '7876');
+-------+-------+-------+------+------------+---------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+-------+-------+------+------------+---------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 |  800.00 |      |     20 |
|  7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 |      |     20 |
+-------+-------+-------+------+------------+---------+------+--------+
(2 rows)

!ok
select * from "scott".emp where empno between '7500' and '07600';
+-------+-------+----------+------+------------+---------+--------+--------+
| EMPNO | ENAME | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |
+-------+-------+----------+------+------------+---------+--------+--------+
|  7521 | WARD  | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 |     30 |
|  7566 | JONES | MANAGER  | 7839 | 1981-02-04 | 2975.00 |        |     20 |
+-------+-------+----------+------+------------+---------+--------+--------+
(2 rows)

!ok

# BETWEEN follows the PostgreSQL style to coerce STRING operand to type of the other
# NUMERIC operands, see TypeCoercionImpl#commonTypeForBinaryComparison.
select * from "scott".emp where deptno between '7369' and '7876';

Caused by: java.lang.NumberFormatException: Value out of range. Value:"7369" Radix:10
!error

select * from "scott".emp where '7369' between empno and '7876';
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok

# [CALCITE-546] Allow table, column and field called "*"
# See [DRILL-3859], [DRILL-3860].
SELECT * FROM (VALUES (0, 0)) AS T(A, "*");
+---+---+
| A | * |
+---+---+
| 0 | 0 |
+---+---+
(1 row)

!ok

SELECT a FROM (VALUES (0, 0)) AS T(A, "*");
+---+
| A |
+---+
| 0 |
+---+
(1 row)

!ok

SELECT b FROM (VALUES (0, 0)) AS T(A, "*");
Column 'B' not found in any table
!error

# See [DRILL-3860].
SELECT "a" FROM (VALUES (1, 2, 3, 4)) AS T("a", "A", ".", "*");
+---+
| a |
+---+
| 1 |
+---+
(1 row)

!ok

SELECT "A" FROM (VALUES (1, 2, 3, 4)) AS T("a", "A", ".", "*");
+---+
| A |
+---+
| 2 |
+---+
(1 row)

!ok

SELECT "." FROM (VALUES (1, 2, 3, 4)) AS T("a", "A", ".", "*");
+---+
| . |
+---+
| 3 |
+---+
(1 row)

!ok

SELECT "*" FROM (VALUES (1, 2, 3, 4)) AS T("a", "A", ".", "*");
+---+
| * |
+---+
| 4 |
+---+
(1 row)

!ok

SELECT * FROM (VALUES (1, 2, 3, 4)) AS T("a", "A", ".", "*");
+---+---+---+---+
| a | A | . | * |
+---+---+---+---+
| 1 | 2 | 3 | 4 |
+---+---+---+---+
(1 row)

!ok

# Implicit ROW
select deptno, (empno, deptno) as r
from "scott".emp;
+--------+------------+
| DEPTNO | R          |
+--------+------------+
|     10 | {7782, 10} |
|     10 | {7839, 10} |
|     10 | {7934, 10} |
|     20 | {7369, 20} |
|     20 | {7566, 20} |
|     20 | {7788, 20} |
|     20 | {7876, 20} |
|     20 | {7902, 20} |
|     30 | {7499, 30} |
|     30 | {7521, 30} |
|     30 | {7654, 30} |
|     30 | {7698, 30} |
|     30 | {7844, 30} |
|     30 | {7900, 30} |
+--------+------------+
(14 rows)

!ok

# Explicit ROW
select deptno, row (empno, deptno) as r
from "scott".emp;
+--------+------------+
| DEPTNO | R          |
+--------+------------+
|     10 | {7782, 10} |
|     10 | {7839, 10} |
|     10 | {7934, 10} |
|     20 | {7369, 20} |
|     20 | {7566, 20} |
|     20 | {7788, 20} |
|     20 | {7876, 20} |
|     20 | {7902, 20} |
|     30 | {7499, 30} |
|     30 | {7521, 30} |
|     30 | {7654, 30} |
|     30 | {7698, 30} |
|     30 | {7844, 30} |
|     30 | {7900, 30} |
+--------+------------+
(14 rows)

!ok

# [CALCITE-877] Allow ROW as argument to COLLECT
select deptno, collect(r) as empnos
from (select deptno, (empno, deptno) as r
  from "scott".emp)
group by deptno;
+--------+--------------------------------------------------------------------------+
| DEPTNO | EMPNOS                                                                   |
+--------+--------------------------------------------------------------------------+
|     10 | [{7782, 10}, {7839, 10}, {7934, 10}]                                     |
|     20 | [{7369, 20}, {7566, 20}, {7788, 20}, {7876, 20}, {7902, 20}]             |
|     30 | [{7499, 30}, {7521, 30}, {7654, 30}, {7698, 30}, {7844, 30}, {7900, 30}] |
+--------+--------------------------------------------------------------------------+
(3 rows)

!ok

# [CALCITE-922] Value of INTERVAL literal
select deptno * interval '2' day as d2,
 deptno * interval -'3' hour as h3,
 deptno * interval -'-4' hour as h4,
 deptno * interval -'4:30' hour to minute as h4_5,
 deptno * interval -'-1-3' year to month as y1_25
from "scott".dept;
+-----+------+------+---------+--------+
| D2  | H3   | H4   | H4_5    | Y1_25  |
+-----+------+------+---------+--------+
| +20 | -30  | +40  | -45:00  | +12-06 |
| +40 | -60  | +80  | -90:00  | +25-00 |
| +60 | -90  | +120 | -135:00 | +37-06 |
| +80 | -120 | +160 | -180:00 | +50-00 |
+-----+------+------+---------+--------+
(4 rows)

!ok

# [CALCITE-1486] Invalid "Invalid literal" error for complex expression
select 8388608/(60+27.39);
+-------------------+
| EXPR_0            |
+-------------------+
| 95990.47945989244 |
+-------------------+
(1 row)

!ok

# [CALCITE-1120] Support SELECT without FROM
select 2 + 2;
+--------+
| EXPR_0 |
+--------+
|      4 |
+--------+
(1 row)

!ok

select 2 + 2 as a, 'b' as b;
+---+---+
| A | B |
+---+---+
| 4 | b |
+---+---+
(1 row)

!ok

select distinct 2 as a, 'b' as b;
+---+---+
| A | B |
+---+---+
| 2 | b |
+---+---+
(1 row)

!ok

select distinct 2 as a, 'b' as b
order by 2;
+---+---+
| A | B |
+---+---+
| 2 | b |
+---+---+
(1 row)

!ok

select distinct 2 as a, 'b' as b
union all
select 3, 'c';
+---+---+
| A | B |
+---+---+
| 2 | b |
| 3 | c |
+---+---+
(2 rows)

!ok

# Composite UNION
select deptno, deptno from "scott".emp
union
select deptno, deptno from "scott".dept;
+--------+--------+
| DEPTNO | DEPTNO |
+--------+--------+
|     10 |     10 |
|     20 |     20 |
|     30 |     30 |
|     40 |     40 |
+--------+--------+
(4 rows)

!ok

# Composite MINUS
select deptno, deptno from "scott".emp
except
select deptno, deptno from "scott".dept where deptno = 10;
+--------+--------+
| DEPTNO | DEPTNO |
+--------+--------+
|     20 |     20 |
|     30 |     30 |
+--------+--------+
(2 rows)

!ok

select * from (
  select 2 as a, 3 as b)
where a < b;
+---+---+
| A | B |
+---+---+
| 2 | 3 |
+---+---+
(1 row)

!ok

select * from (
  select distinct 2 as a, 3 as b)
where a > b;
+---+---+
| A | B |
+---+---+
+---+---+
(0 rows)

!ok

select count(*) as c from "scott".dept where exists (select 1);
+---+
| C |
+---+
| 4 |
+---+
(1 row)

!ok

# INTERSECT
select deptno from "scott".emp
intersect
select deptno from "scott".dept;
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
+--------+
(3 rows)

!ok

# INTERSECT DISTINCT means the same as INTERSECT
select deptno from "scott".emp
intersect distinct
select deptno from "scott".dept;
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
+--------+
(3 rows)

!ok

# INTERSECT can return NULL values
select comm from "scott".emp where mgr = 7698
intersect
select comm from "scott".emp where deptno = 10;
+------+
| COMM |
+------+
|      |
+------+
(1 row)

!ok

# As above, composite
select job, comm from "scott".emp where mgr = 7698
intersect
select job, comm from "scott".emp where deptno = 10;
+-------+------+
| JOB   | COMM |
+-------+------+
| CLERK |      |
+-------+------+
(1 row)

!ok

# Make sure that IN does not compare the shorter of two strings.
# If it did, 'MARTIN' would be emitted.
select ename, deptno
from "scott".emp
where ename in ('MARTINGALE', 'WARD');
+-------+--------+
| ENAME | DEPTNO |
+-------+--------+
| WARD  |     30 |
+-------+--------+
(1 row)

!ok

# [DRILL-4906]
select (case when (true) then 1 end) from (values(1));
+--------+
| EXPR_0 |
+--------+
|      1 |
+--------+
(1 row)

!ok
EXPR_0 INTEGER(10)
!type

# Cast a character literal to a timestamp; note: the plan does not contain CAST
values cast('1969-07-21 12:34:56' as timestamp);
+---------------------+
| EXPR_0              |
+---------------------+
| 1969-07-21 12:34:56 |
+---------------------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[1969-07-21 12:34:56], EXPR_0=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# Cast a character literal without time to a timestamp; note: the plan does not contain CAST
values cast('1969-07-21' as timestamp);
+---------------------+
| EXPR_0              |
+---------------------+
| 1969-07-21 00:00:00 |
+---------------------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[1969-07-21 00:00:00], EXPR_0=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# Cast a character literal to a date; note: the plan does not contain CAST
values cast('1969-07-21' as date);
+------------+
| EXPR_0     |
+------------+
| 1969-07-21 |
+------------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[1969-07-21], EXPR_0=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# Slightly different format
# (Incidentally, this format is not allowed in date literals, per the standard)
values cast('1989-7-4' as date);
+------------+
| EXPR_0     |
+------------+
| 1989-07-04 |
+------------+
(1 row)

!ok

# Cast a character literal to an integer; note: the plan does not contain CAST
values cast('196907' as integer);
+--------+
| EXPR_0 |
+--------+
| 196907 |
+--------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[196907], EXPR_0=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# Cast an integer literal to a bigint; note: the plan does not contain CAST
values cast(123 as bigint);
+--------+
| EXPR_0 |
+--------+
|    123 |
+--------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[123:BIGINT], EXPR_0=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# Cast an integer literal to a decimal; note: the plan does not contain CAST
values cast('123.45' as decimal(4, 2));
+--------+
| EXPR_0 |
+--------+
| 123.45 |
+--------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[123.45:DECIMAL(4, 2)], EXPR_0=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# Cast a character literal to a decimal; note: the plan does not contain CAST
values cast('123.45' as decimal(4, 2));
+--------+
| EXPR_0 |
+--------+
| 123.45 |
+--------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[123.45:DECIMAL(4, 2)], EXPR_0=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# Cast a character literal to a double; note: the plan does not contain CAST
values cast('-123.45' as double);
+---------+
| EXPR_0  |
+---------+
| -123.45 |
+---------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[-1.2345E2:DOUBLE], EXPR_0=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

values cast('false' as boolean);
+--------+
| EXPR_0 |
+--------+
| false  |
+--------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[false], EXPR_0=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

values cast('TRUE' as boolean);
+--------+
| EXPR_0 |
+--------+
| true   |
+--------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[true], EXPR_0=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

values cast('TR' || 'UE' as boolean);
+--------+
| EXPR_0 |
+--------+
| true   |
+--------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=['TR'], expr#2=['UE'], expr#3=[||(_t1, _t2)], expr#4=[CAST(_t3):BOOLEAN NOT NULL], EXPR_0=[_t4])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

!if (fixed.calcite2539) {

# In the following, that we get an error at run time,
# and that the plan shows that the expression has not been reduced.
values cast('null' as boolean);
Invalid character for cast
!error
EnumerableCalc(expr#0=[{inputs}], expr#1=['null'], expr#2=[CAST(_t1):BOOLEAN NOT NULL], EXPR_0=[_t2])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# The following throw give an error (good!)
# but throw java.lang.ExceptionInInitializerError (not great).
values cast('' as date);
Caused by: java.lang.NumberFormatException: For input string: ""
!error

values cast('' as timestamp);
Caused by: java.lang.NumberFormatException: For input string: ""
!error

values cast('' as integer);
Caused by: java.lang.NumberFormatException: For input string: ""
!error

values cast('' as boolean);
Caused by: java.lang.RuntimeException: Invalid character for cast
!error

values cast('' as double);
Caused by: java.lang.NumberFormatException: empty String
!error

# Postgres fails:
#  ERROR:  invalid input syntax for integer: "1.56"
values cast('15.6' as integer);
Caused by: java.lang.NumberFormatException: For input string: "15.6"
!error

# Postgres fails:
#  ERROR:  invalid input syntax for integer: " - 5 "
values cast(' - 5 ' as double);
Caused by: java.lang.NumberFormatException: For input string: "- 5"
!error

# Out of TINYINT range (max 127)
values cast('200' as tinyint);
Caused by: java.lang.NumberFormatException: Value out of range. Value:"200" Radix:10
!error

# Out of SMALLINT range (max 32767)
values cast('50000' as smallint);
Caused by: java.lang.NumberFormatException: Value out of range. Value:"50000" Radix:10
!error

# Out of INTEGER range (max 2.1e9)
values cast('4567891234' as integer);
Caused by: java.lang.NumberFormatException: For input string: "4567891234"
!error

# Out of BIGINT range (max 9.2e18)
values cast('12345678901234567890' as bigint);
Caused by: java.lang.NumberFormatException: For input string: "12345678901234567890"
!error
!}

# Out of REAL range
# (Should give an error, not infinity.)
values cast('12.34e56' as real);
+----------+
| EXPR_0   |
+----------+
| Infinity |
+----------+
(1 row)

!ok

# Out of FLOAT range
# (Should give an error, not infinity.)
values cast('12.34e5678' as float);
+----------+
| EXPR_0   |
+----------+
| Infinity |
+----------+
(1 row)

!ok

# Out of DOUBLE range
# (Should give an error, not infinity.)
values cast('12.34e5678' as double);
+----------+
| EXPR_0   |
+----------+
| Infinity |
+----------+
(1 row)

!ok

# Postgres succeeds
values cast(' -5 ' as double);
+--------+
| EXPR_0 |
+--------+
|   -5.0 |
+--------+
(1 row)

!ok

# RAND_INTEGER with seed
select i, rand_integer(1, 5) as r
from (values 1, 2, 3, 4, 5) as t(i);
+---+---+
| I | R |
+---+---+
| 1 | 0 |
| 2 | 3 |
| 3 | 2 |
| 4 | 3 |
| 5 | 4 |
+---+---+
(5 rows)

!ok

# Same query, should yield same results
select i, rand_integer(1, 5) as r
from (values 1, 2, 3, 4, 5) as t(i);
+---+---+
| I | R |
+---+---+
| 1 | 0 |
| 2 | 3 |
| 3 | 2 |
| 4 | 3 |
| 5 | 4 |
+---+---+
(5 rows)

!ok

# Same query with different seed
select i, rand_integer(-1, 5) as r
from (values 1, 2, 3, 4, 5) as t(i);
+---+---+
| I | R |
+---+---+
| 1 | 3 |
| 2 | 0 |
| 3 | 4 |
| 4 | 4 |
| 5 | 4 |
+---+---+
(5 rows)

!ok

# Same query with different bound
select i, rand_integer(-1, 2) as r
from (values 1, 2, 3, 4, 5) as t(i);
+---+---+
| I | R |
+---+---+
| 1 | 0 |
| 2 | 0 |
| 3 | 0 |
| 4 | 1 |
| 5 | 1 |
+---+---+
(5 rows)

!ok

# RAND with seed
select i, rand(-1) as r
from (values 1, 2, 3, 4, 5) as t(i);
+---+---------------------+
| I | R                   |
+---+---------------------+
| 1 | 0.03305388522187047 |
| 2 |  0.6573104025344794 |
| 3 |  0.7450920948729041 |
| 4 |  0.6624972807480889 |
| 5 |  0.5532616835728703 |
+---+---------------------+
(5 rows)

!ok

# PI function
values pi;
+-------------------+
| PI                |
+-------------------+
| 3.141592653589793 |
+-------------------+
(1 row)

!ok

# DEGREES function
values (degrees(pi), degrees(-pi / 2));
+--------+--------+
| EXPR_0 | EXPR_1 |
+--------+--------+
|  180.0 |  -90.0 |
+--------+--------+
(1 row)

!ok

# [CALCITE-1592] SqlToRelConverter throws UnsupportedOperationException if query has NOT ... NOT IN
select * from "scott".emp where not (ename not in ('Fred'));
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

select count(*) as c from "scott".emp where not (ename in ('Fred'));
+----+
| C  |
+----+
| 14 |
+----+
(1 row)

!ok

# [CALCITE-1638] Simplify "$x = $x" to "$x is not null"
select count(*) as c from "scott".emp where deptno > deptno;
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok
EnumerableAggregate(group=[{}], C=[COUNT()])
  EnumerableValues(tuples=[[]])
!plan

# [CALCITE-1659] Simplifying CAST('YYYY-MM-DD hh:mm:ss.SSS' as TIMESTAMP)
# should round the sub-second fraction
select TIMESTAMP '2016-02-26 19:06:00.123456789',
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(0)),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(1)),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(2)),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(3)),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(6)),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(9));
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
| EXPR_0              | EXPR_1              | EXPR_2              | EXPR_3              | EXPR_4              | EXPR_5              | EXPR_6              | EXPR_7              |
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
| 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 |
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=[2016-02-26 19:06:00.123:TIMESTAMP(3)], expr#2=[2016-02-26 19:06:00], expr#3=[2016-02-26 19:06:00.1:TIMESTAMP(1)], expr#4=[2016-02-26 19:06:00.12:TIMESTAMP(2)], EXPR_0=[_t1], EXPR_1=[_t2], EXPR_2=[_t2], EXPR_3=[_t3], EXPR_4=[_t4], EXPR_5=[_t1], EXPR_6=[_t1], EXPR_7=[_t1])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# [CALCITE-1664] CAST('<string>' as TIMESTAMP) adds part of sub-second fraction to the value
select
  TIMESTAMP '2016-02-26 19:06:00.12345678',
  CAST('2016-02-26 19:06:00.12345678' as TIMESTAMP),
  TIMESTAMPDIFF(SECOND,
    TIMESTAMP '2016-02-26 19:06:00.123456789',
    CAST('2016-02-26 19:06:00.123456789' as TIMESTAMP));
+---------------------+---------------------+--------+
| EXPR_0              | EXPR_1              | EXPR_2 |
+---------------------+---------------------+--------+
| 2016-02-26 19:06:00 | 2016-02-26 19:06:00 |      0 |
+---------------------+---------------------+--------+
(1 row)

!ok

# ARRAY and MULTISET
select array[1,2] as a from (values (1));
+--------+
| A      |
+--------+
| [1, 2] |
+--------+
(1 row)

!ok

select array[1,null,2] as a from (values (1));
+--------------+
| A            |
+--------------+
| [1, null, 2] |
+--------------+
(1 row)

!ok

values array['a',null,'bcd'],
  array['efgh'];
+----------------+
| EXPR_0         |
+----------------+
| [a, null, bcd] |
| [efgh]         |
+----------------+
(2 rows)

!ok

select multiset[1,null,2,2-1] as m from (values (1));
+-----------------+
| M               |
+-----------------+
| [1, 1, null, 2] |
+-----------------+
(1 row)

!ok

!use catchall

# [CALCITE-1054] NPE caused by wrong code generation for Timestamp fields
select "sqlTimestamp" as T
from "everyTypes"
where "sqlTimestamp" >= {ts '1969-01-01 00:00:00'}
and "sqlTimestamp" < {ts '1998-01-01 00:00:00'};
+---------------------+
| T                   |
+---------------------+
| 1970-01-01 00:00:00 |
+---------------------+
(1 row)

!ok

# [CALCITE-1188] NullPointerException in EXTRACT with WHERE ... IN clause if field has null value
select "sqlTimestamp" T
from "everyTypes"
where extract(YEAR from "sqlTimestamp") IN (1969, 1970);
+---------------------+
| T                   |
+---------------------+
| 1970-01-01 00:00:00 |
+---------------------+
(1 row)

!ok

!if (false) {
# [CALCITE-2032] Error when implicitly converting character literal to date literal
select *
from "scott".emp
WHERE hiredate = '1980-12-17';
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok
!}

# [CALCITE-2002] DISTINCT applied to VALUES returns wrong result
SELECT DISTINCT T.B
FROM (VALUES (1, 'X'),(2, 'Y'),(3, 'X'),(4, 'X')) AS T(A, B);
+---+
| B |
+---+
| X |
| Y |
+---+
(2 rows)

!ok

# [CALCITE-2183] Implement RelSubset.copy
select *
from (values (1, 'a'), (2, 'b'), (1, 'b'), (2, 'c'), (2, 'c')) as t(x, y)
where false;
+---+---+
| X | Y |
+---+---+
+---+---+
(0 rows)

!ok

# [CALCITE-2447] POWER, ATAN2 functions fail with NoSuchMethodException
values power(0.5, 2);
+--------+
| EXPR_0 |
+--------+
|   0.25 |
+--------+
(1 row)

!ok

# [CALCITE-2447] POWER, ATAN2 functions fail with NoSuchMethodException
values atan2(0.5, 2);
+---------------------+
| EXPR_0              |
+---------------------+
| 0.24497866312686414 |
+---------------------+
(1 row)

!ok

!set outputformat csv

# [CALCITE-1167] OVERLAPS should match even if operands are in (high, low) order
values ((date '1999-12-01', date '2001-12-31') overlaps (date '2001-01-01' , date '2002-11-11'));
EXPR_0
true
!ok

values ((date '2001-12-31', date '1999-12-01') overlaps (date '2001-01-01' , date '2002-11-11'));
EXPR_0
true
!ok

values ((date '2001-12-31', date '1999-12-01') overlaps (date '2002-11-11', date '2001-01-01'));
EXPR_0
true
!ok

values ((date '2001-12-31', date '1999-12-01') overlaps (date '2002-01-01', date '2002-11-11'));
EXPR_0
false
!ok

# Sub-query returns a MAP, column is renamed, and enclosing query references the map.
select mycol['b'] as x
from (select map['a', false, 'b', true] from (values (2))) as t(mycol);
X
true
!ok

# JSON
values json_exists('{"foo":"bar"}', 'strict $.foo' false on error);
EXPR_0
true
!ok

# [CALCITE-2908] Implement SQL LAST_DAY function
with data(c_date, c_timestamp) as (select * from (values
    (DATE'1965-01-10', TIMESTAMP '1965-01-10 20:20:20'),
    (DATE'2019-01-01', TIMESTAMP '2019-01-01 18:19:20'),
    (DATE'2019-02-20', TIMESTAMP '2019-02-20 00:00:00'),
    (DATE'2019-02-28', TIMESTAMP '2019-02-28 03:04:05'),
    (DATE'2019-03-02', TIMESTAMP '2019-03-02 15:10:05'),
    (DATE'2019-06-28', TIMESTAMP '2019-06-28 17:32:01'),
    (DATE'2019-12-12', TIMESTAMP '2019-12-12 12:12:01')))
select last_day(c_date), last_day(c_timestamp) from data;

EXPR_0, EXPR_1
1965-01-31, 1965-01-31
2019-01-31, 2019-01-31
2019-02-28, 2019-02-28
2019-02-28, 2019-02-28
2019-03-31, 2019-03-31
2019-06-30, 2019-06-30
2019-12-31, 2019-12-31
!ok

# End misc.iq
