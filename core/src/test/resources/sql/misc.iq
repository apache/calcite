# misc.iq - Miscellaneous queries
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
!use post
!set outputformat mysql

# [CALCITE-356] Allow column references of the form schema.table.column
select "hr"."emps"."empid"
from "hr"."emps";
+-------+
| empid |
+-------+
|   100 |
|   110 |
|   150 |
|   200 |
+-------+
(4 rows)

!ok

# [CALCITE-881] Allow schema.table.column references in GROUP BY
select "hr"."emps"."empid", count(*) as c
from "hr"."emps"
group by "hr"."emps"."empid";
+-------+---+
| empid | C |
+-------+---+
|   100 | 1 |
|   110 | 1 |
|   150 | 1 |
|   200 | 1 |
+-------+---+
(4 rows)

!ok

select distinct "hr"."emps"."empid" + 1 as e
from "hr"."emps"
group by "hr"."emps"."empid";
+-----+
| E   |
+-----+
| 101 |
| 111 |
| 151 |
| 201 |
+-----+
(4 rows)

!ok

# [CALCITE-4258] SqlToRelConverter: SELECT 1 IS [NOT] DISTINCT FROM NULL fails with AssertionError
SELECT 1 IS DISTINCT FROM NULL;
+--------+
| EXPR$0 |
+--------+
| true   |
+--------+
(1 row)

!ok

# [CALCITE-4258] SqlToRelConverter: SELECT 1 IS [NOT] DISTINCT FROM NULL fails with AssertionError
SELECT 1 IS NOT DISTINCT FROM NULL;
+--------+
| EXPR$0 |
+--------+
| false  |
+--------+
(1 row)

!ok

# Case-sensitive errors
select empid from "hr"."emps";
Column 'EMPID' not found in any table; did you mean 'empid'?
!error

select empid from "hr".emps;
Object 'EMPS' not found within 'hr'; did you mean 'emps'?
!error

select empid from hr.emps;
Object 'HR' not found; did you mean 'hr'?
!error

select empid from bad_schema.bad_table;
Object 'BAD_SCHEMA' not found
!error

select empid from bad_cat.bad_schema.bad_table;
Object 'BAD_CAT' not found
!error

select empid from "catalog".bad_schema.bad_table;
Object 'catalog' not found
!error

select empid from catalog.bad_schema.bad_table;
Object 'CATALOG' not found
!error

select empid from catalog.HR.bad_table;
Object 'CATALOG' not found
!error

select empid from catalog."hr".bad_table;
Object 'CATALOG' not found
!error

select empid from catalog."hr".emp;
Object 'CATALOG' not found
!error

select empid from HR.bad_table;
Object 'HR' not found; did you mean 'hr'?
!error

select empid from "HR".bad_table;
Object 'HR' not found; did you mean 'hr'?
!error

select empid from HR."emps";
Object 'HR' not found; did you mean 'hr'?
!error

select empid from "hr".bad_table;
Object 'BAD_TABLE' not found within 'hr'
!error

select empid from "hr".emps;
Object 'EMPS' not found within 'hr'; did you mean 'emps'?
!error

select empid from "hr";
Object 'hr' not found
!error

# [CALCITE-307] CAST(timestamp AS DATE) gives ClassCastException
# Based on [DRILL-1051]
with data(c_row, c_timestamp) as (select * from (values
    (1, TIMESTAMP '1997-01-02 03:04:05'),
    (2, TIMESTAMP '1997-01-02 00:00:00'),
    (3, TIMESTAMP '2001-09-22 18:19:20'),
    (4, TIMESTAMP '1997-02-10 17:32:01'),
    (5, TIMESTAMP '1997-02-10 17:32:00'),
    (6, TIMESTAMP '1997-02-11 17:32:01'),
    (7, TIMESTAMP '1997-02-12 17:32:01'),
    (8, TIMESTAMP '1997-02-13 17:32:01'),
    (9, TIMESTAMP '1997-02-14 17:32:01'),
    (10, TIMESTAMP '1997-02-15 17:32:01'),
    (11, TIMESTAMP '1997-02-16 17:32:01'),
    (13, TIMESTAMP '0097-02-16 17:32:01'),
    (14, TIMESTAMP '0597-02-16 17:32:01'),
    (15, TIMESTAMP '1097-02-16 17:32:01'),
    (16, TIMESTAMP '1697-02-16 17:32:01'),
    (17, TIMESTAMP '1797-02-16 17:32:01'),
    (18, TIMESTAMP '1897-02-16 17:32:01'),
    (19, TIMESTAMP '1997-02-16 17:32:01'),
    (20, TIMESTAMP '2097-02-16 17:32:01'),
    (21, TIMESTAMP '1996-02-28 17:32:01'),
    (22, TIMESTAMP '1996-02-29 17:32:01'),
    (23, TIMESTAMP '1996-03-01 17:32:01')))
select cast(c_timestamp as varchar(20)), cast(c_timestamp as date) from data where c_row <> 12;

+---------------------+------------+
| EXPR$0              | EXPR$1     |
+---------------------+------------+
| 1997-01-02 03:04:05 | 1997-01-02 |
| 1997-01-02 00:00:00 | 1997-01-02 |
| 2001-09-22 18:19:20 | 2001-09-22 |
| 1997-02-10 17:32:01 | 1997-02-10 |
| 1997-02-10 17:32:00 | 1997-02-10 |
| 1997-02-11 17:32:01 | 1997-02-11 |
| 1997-02-12 17:32:01 | 1997-02-12 |
| 1997-02-13 17:32:01 | 1997-02-13 |
| 1997-02-14 17:32:01 | 1997-02-14 |
| 1997-02-15 17:32:01 | 1997-02-15 |
| 1997-02-16 17:32:01 | 1997-02-16 |
| 1697-02-16 17:32:01 | 1697-02-16 |
| 1797-02-16 17:32:01 | 1797-02-16 |
| 1897-02-16 17:32:01 | 1897-02-16 |
| 1997-02-16 17:32:01 | 1997-02-16 |
| 2097-02-16 17:32:01 | 2097-02-16 |
| 1996-02-28 17:32:01 | 1996-02-28 |
| 1996-02-29 17:32:01 | 1996-02-29 |
| 1996-03-01 17:32:01 | 1996-03-01 |
| 0097-02-16 17:32:01 | 0097-02-16 |
| 0597-02-16 17:32:01 | 0597-02-16 |
| 1097-02-16 17:32:01 | 1097-02-16 |
+---------------------+------------+
(22 rows)

!ok

# [DRILL-1149]
select *, upper("name")
from "hr"."emps";
+-------+--------+-----------+---------+------------+-----------+
| empid | deptno | name      | salary  | commission | EXPR$5    |
+-------+--------+-----------+---------+------------+-----------+
|   100 |     10 | Bill      | 10000.0 |       1000 | BILL      |
|   110 |     10 | Theodore  | 11500.0 |        250 | THEODORE  |
|   150 |     10 | Sebastian |  7000.0 |            | SEBASTIAN |
|   200 |     20 | Eric      |  8000.0 |        500 | ERIC      |
+-------+--------+-----------+---------+------------+-----------+
(4 rows)

!ok

# [DRILL-1199] Order by nested inside a where clause fails
# (Not that it's right, but Tableau does it.)
select * from (select * from "hr"."emps" order by "empid") where (0=1);
+-------+--------+------+--------+------------+
| empid | deptno | name | salary | commission |
+-------+--------+------+--------+------------+
+-------+--------+------+--------+------------+
(0 rows)

!ok

# [DRILL-1842] Tableau, again
select count(distinct "salary") as c
from "hr"."emps"
join "hr"."depts" on "emps"."deptno" = "depts"."deptno"
having count(1) > 0;
+---+
| C |
+---+
| 3 |
+---+
(1 row)

!ok

# [CALCITE-340] SqlToRelConverter fails with complex join condition
select e."deptno", d."deptno"
from "hr"."emps" as e
join "hr"."depts" as d
on ( e."deptno" + 1 - 1 = d."deptno" + 2 - 2  and e."deptno" + 10 - 10 = d."deptno" + 20 - 20);
+--------+--------+
| deptno | deptno |
+--------+--------+
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
+--------+--------+
(3 rows)

!ok

# [CALCITE-340] SqlToRelConverter fails with complex join condition. Switch LHS and RHS.
select e."deptno", d."deptno"
from "hr"."emps" as e
join "hr"."depts" as d
on ( d."deptno" + 2 - 2 = e."deptno" + 1 - 1  and d."deptno" + 20 - 20 = e."deptno" + 10 - 10);
+--------+--------+
| deptno | deptno |
+--------+--------+
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
+--------+--------+
(3 rows)

!ok

# [CALCITE-340] SqlToRelConverter fails with complex join condition. Switch LHS and RHS.
select e."deptno", d."deptno"
from "hr"."emps" as e
join "hr"."depts" as d
on ( d."deptno" + 2 - 2 = e."deptno" + 1 - 1  and e."deptno" + 10 - 10 = d."deptno" + 20 - 20);
+--------+--------+
| deptno | deptno |
+--------+--------+
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
+--------+--------+
(3 rows)

!ok

# [CALCITE-377] Mixed equi and non-equi join
select e."empid", d."name", e."name"
from "hr"."emps" as e
join "hr"."depts" as d
on e."deptno" = d."deptno"
and e."name" <> d."name";
+-------+-------+-----------+
| empid | name  | name      |
+-------+-------+-----------+
|   100 | Sales | Bill      |
|   110 | Sales | Theodore  |
|   150 | Sales | Sebastian |
+-------+-------+-----------+
(3 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], empid=[$t0], name=[$t4], name0=[$t2])
  EnumerableMergeJoin(condition=[AND(=($1, $3), <>(CAST($2):VARCHAR, CAST($4):VARCHAR))], joinType=[inner])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..4=[{inputs}], proj#0..2=[{exprs}])
        EnumerableTableScan(table=[[hr, emps]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableCalc(expr#0..3=[{inputs}], proj#0..1=[{exprs}])
        EnumerableTableScan(table=[[hr, depts]])
!plan

# Same query, expressed using WHERE.
select e."empid", d."name", e."name"
from "hr"."emps" as e,
  "hr"."depts" as d
where e."deptno" = d."deptno"
and e."name" <> d."name";
+-------+-------+-----------+
| empid | name  | name      |
+-------+-------+-----------+
|   100 | Sales | Bill      |
|   110 | Sales | Theodore  |
|   150 | Sales | Sebastian |
+-------+-------+-----------+
(3 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], empid=[$t0], name=[$t4], name0=[$t2])
  EnumerableMergeJoin(condition=[AND(=($1, $3), <>(CAST($2):VARCHAR, CAST($4):VARCHAR))], joinType=[inner])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..4=[{inputs}], proj#0..2=[{exprs}])
        EnumerableTableScan(table=[[hr, emps]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableCalc(expr#0..3=[{inputs}], proj#0..1=[{exprs}])
        EnumerableTableScan(table=[[hr, depts]])
!plan

# Un-correlated EXISTS
select "deptno" from "hr"."depts"
where exists (select 1 from "hr"."emps");
+--------+
| deptno |
+--------+
|     10 |
|     30 |
|     40 |
+--------+
(3 rows)

!ok
EnumerableNestedLoopJoin(condition=[true], joinType=[semi])
  EnumerableCalc(expr#0..3=[{inputs}], deptno=[$t0])
    EnumerableTableScan(table=[[hr, depts]])
  EnumerableCalc(expr#0=[{inputs}], expr#1=[IS NOT NULL($t0)], $f0=[$t0], $condition=[$t1])
    EnumerableAggregate(group=[{}], agg#0=[MIN($0)])
      EnumerableCalc(expr#0..4=[{inputs}], expr#5=[true], $f0=[$t5])
        EnumerableTableScan(table=[[hr, emps]])
!plan

# Un-correlated NOT EXISTS
select "deptno" from "hr"."depts"
where not exists (select 1 from "hr"."emps");
+--------+
| deptno |
+--------+
+--------+
(0 rows)

!ok
EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], deptno=[$t0], $condition=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..3=[{inputs}], deptno=[$t0])
      EnumerableTableScan(table=[[hr, depts]])
    EnumerableAggregate(group=[{}], agg#0=[MIN($0)])
      EnumerableCalc(expr#0..4=[{inputs}], expr#5=[true], $f0=[$t5])
        EnumerableTableScan(table=[[hr, emps]])
!plan

# Un-correlated EXISTS (table empty)
select "deptno" from "hr"."depts"
where exists (select 1 from "hr"."emps" where "empid" < 0);
+--------+
| deptno |
+--------+
+--------+
(0 rows)

!ok
EnumerableNestedLoopJoin(condition=[true], joinType=[semi])
  EnumerableCalc(expr#0..3=[{inputs}], deptno=[$t0])
    EnumerableTableScan(table=[[hr, depts]])
  EnumerableCalc(expr#0=[{inputs}], expr#1=[IS NOT NULL($t0)], $f0=[$t0], $condition=[$t1])
    EnumerableAggregate(group=[{}], agg#0=[MIN($0)])
      EnumerableCalc(expr#0..4=[{inputs}], expr#5=[true], expr#6=[0], expr#7=[<($t0, $t6)], $f0=[$t5], $condition=[$t7])
        EnumerableTableScan(table=[[hr, emps]])
!plan

# Un-correlated NOT EXISTS (table empty)
select "deptno" from "hr"."depts"
where not exists (select 1 from "hr"."emps" where "empid" < 0);
+--------+
| deptno |
+--------+
|     10 |
|     30 |
|     40 |
+--------+
(3 rows)

!ok
EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], deptno=[$t0], $condition=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..3=[{inputs}], deptno=[$t0])
      EnumerableTableScan(table=[[hr, depts]])
    EnumerableAggregate(group=[{}], agg#0=[MIN($0)])
      EnumerableCalc(expr#0..4=[{inputs}], expr#5=[true], expr#6=[0], expr#7=[<($t0, $t6)], $f0=[$t5], $condition=[$t7])
        EnumerableTableScan(table=[[hr, emps]])
!plan

# EXISTS
select * from "hr"."emps"
where exists (
  select 1 from "hr"."depts" where "depts"."deptno" = "emps"."deptno");
+-------+--------+-----------+---------+------------+
| empid | deptno | name      | salary  | commission |
+-------+--------+-----------+---------+------------+
|   100 |     10 | Bill      | 10000.0 |       1000 |
|   110 |     10 | Theodore  | 11500.0 |        250 |
|   150 |     10 | Sebastian |  7000.0 |            |
+-------+--------+-----------+---------+------------+
(3 rows)

!ok
EnumerableHashJoin(condition=[=($1, $5)], joinType=[semi])
  EnumerableTableScan(table=[[hr, emps]])
  EnumerableTableScan(table=[[hr, depts]])
!plan

# NOT EXISTS
# Right results, but it would be better if the plan used EnumerableCorrelateRel; see [CALCITE-374]
select * from "hr"."emps"
where not exists (
  select 1 from "hr"."depts" where "depts"."deptno" = "emps"."deptno");
+-------+--------+------+--------+------------+
| empid | deptno | name | salary | commission |
+-------+--------+------+--------+------------+
|   200 |     20 | Eric | 8000.0 |        500 |
+-------+--------+------+--------+------------+
(1 row)

!ok
EnumerableCalc(expr#0..6=[{inputs}], expr#7=[IS NULL($t6)], proj#0..4=[{exprs}], $condition=[$t7])
  EnumerableMergeJoin(condition=[=($1, $5)], joinType=[left])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableTableScan(table=[[hr, emps]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableAggregate(group=[{0}], agg#0=[MIN($1)])
        EnumerableCalc(expr#0..3=[{inputs}], expr#4=[true], deptno=[$t0], $f0=[$t4])
          EnumerableTableScan(table=[[hr, depts]])
!plan

# NOT EXISTS .. OR NOT EXISTS
# Right results, but it would be better if the plan used EnumerableCorrelateRel; see [CALCITE-374]
select * from "hr"."emps"
where not exists (
  select 1 from "hr"."depts" where "depts"."deptno" = "emps"."deptno")
or not exists (
  select 1 from "hr"."depts" where "depts"."deptno" + 90 = "emps"."empid");

+-------+--------+-----------+---------+------------+
| empid | deptno | name      | salary  | commission |
+-------+--------+-----------+---------+------------+
|   110 |     10 | Theodore  | 11500.0 |        250 |
|   150 |     10 | Sebastian |  7000.0 |            |
|   200 |     20 | Eric      |  8000.0 |        500 |
+-------+--------+-----------+---------+------------+
(3 rows)

!ok
EnumerableCalc(expr#0..8=[{inputs}], expr#9=[IS NULL($t5)], expr#10=[IS NULL($t8)], expr#11=[OR($t9, $t10)], proj#0..4=[{exprs}], $condition=[$t11])
  EnumerableMergeJoin(condition=[=($6, $7)], joinType=[left])
    EnumerableSort(sort0=[$6], dir0=[ASC])
      EnumerableCalc(expr#0..6=[{inputs}], expr#7=[CAST($t0):INTEGER NOT NULL], proj#0..4=[{exprs}], $f0=[$t6], empid0=[$t7])
        EnumerableMergeJoin(condition=[=($1, $5)], joinType=[left])
          EnumerableSort(sort0=[$1], dir0=[ASC])
            EnumerableTableScan(table=[[hr, emps]])
          EnumerableSort(sort0=[$0], dir0=[ASC])
            EnumerableAggregate(group=[{0}], agg#0=[MIN($1)])
              EnumerableCalc(expr#0..3=[{inputs}], expr#4=[true], deptno=[$t0], $f0=[$t4])
                EnumerableTableScan(table=[[hr, depts]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableAggregate(group=[{0}], agg#0=[MIN($1)])
        EnumerableCalc(expr#0..3=[{inputs}], expr#4=[90], expr#5=[+($t0, $t4)], expr#6=[true], $f4=[$t5], $f0=[$t6])
          EnumerableTableScan(table=[[hr, depts]])
!plan

# Left join to a relation with one row is recognized as a trivial semi-join
# and eliminated.
select e."deptno"
from "hr"."emps" as e
left join (select count(*) from "hr"."depts") on true;
+--------+
| deptno |
+--------+
|     10 |
|     10 |
|     10 |
|     20 |
+--------+
(4 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], deptno=[$t1])
  EnumerableTableScan(table=[[hr, emps]])
!plan

# Filter combined with an OR filter.
select * from (
  select * from "hr"."emps" as e
  where e."deptno" < 30) as e
where e."deptno" > 10 or e."name" = 'Sebastian';
+-------+--------+-----------+--------+------------+
| empid | deptno | name      | salary | commission |
+-------+--------+-----------+--------+------------+
|   150 |     10 | Sebastian | 7000.0 |            |
|   200 |     20 | Eric      | 8000.0 |        500 |
+-------+--------+-----------+--------+------------+
(2 rows)

!ok

# Filter combined with an AND filter. Test case for
# [CALCITE-389] MergeFilterRule should flatten AND condition
select * from (
  select * from "hr"."emps" as e
  where e."deptno" < 30) as e
where e."deptno" >= 10 and e."name" = 'Sebastian';
+-------+--------+-----------+--------+------------+
| empid | deptno | name      | salary | commission |
+-------+--------+-----------+--------+------------+
|   150 |     10 | Sebastian | 7000.0 |            |
+-------+--------+-----------+--------+------------+
(1 row)

!ok

# [CALCITE-393] If no fields are projected from a table, field trimmer should
# project a dummy expression
select 1 from "hr"."emps";
+--------+
| EXPR$0 |
+--------+
|      1 |
|      1 |
|      1 |
|      1 |
+--------+
(4 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], expr#5=[1], EXPR$0=[$t5])
  EnumerableTableScan(table=[[hr, emps]])
!plan

# [CALCITE-393] for table scan under join
select count(*) as c from "hr"."emps", "hr"."depts";
+----+
| C  |
+----+
| 12 |
+----+
(1 row)

!ok
EnumerableAggregate(group=[{}], C=[COUNT()])
  EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[0], DUMMY=[$t5])
      EnumerableTableScan(table=[[hr, emps]])
    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[0], DUMMY=[$t4])
      EnumerableTableScan(table=[[hr, depts]])
!plan

# [CALCITE-345] AssertionError in RexToLixTranslator comparing to date literal
!use catchall
select count(*) as c from "everyTypes" where "sqlDate" = DATE '1970-01-01';
+---+
| C |
+---+
| 1 |
+---+
(1 row)

!ok
select count(*) as c from "everyTypes" where "sqlDate" = DATE '1971-02-03';
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok
select count(*) as c from "everyTypes" where "sqlDate" > DATE '1970-01-01';
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok
select count(*) as c from "everyTypes" where "sqlTime" = TIME '01:23:45';
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok
select count(*) as c from "everyTypes" where "sqlTimestamp" = TIMESTAMP '1970-01-01 01:23:45';
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok
select count(*) as c from "everyTypes" where "utilDate" = TIMESTAMP '1970-01-01 01:23:45';
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok

# [CALCITE-715] Add PERIOD type constructor and period operators (CONTAINS, PRECEDES, etc.)
select period("sqlDate", INTERVAL '1' YEAR) as p
from "everyTypes";
+------------+
| P          |
+------------+
| {0, 12}    |
| {null, 12} |
+------------+
(2 rows)

!ok

!use foodmart

select count(*) as c
from "customer"
where period ("birthdate", DATE '1970-02-05') contains DATE '1964-01-01';
EnumerableAggregate(group=[{}], C=[COUNT()])
  EnumerableCalc(expr#0..28=[{inputs}], expr#29=[1964-01-01], expr#30=[<=($t16, $t29)], proj#0..28=[{exprs}], $condition=[$t30])
    EnumerableTableScan(table=[[foodmart2, customer]])
!plan
+------+
| C    |
+------+
| 7918 |
+------+
(1 row)

!ok

# [CALCITE-346] Add commutative join rule
#
# 3-way join that does not require bushy join.  Best plan is: sales_fact_1997 as
# left-most leaf, then customer (with filter), then product.
select *
from "sales_fact_1997" as s
  join "customer" as c on s."customer_id" = c."customer_id"
  join "product" as p on s."product_id" = p."product_id"
where c."city" = 'San Francisco';
EnumerableMergeJoin(condition=[=($0, $38)], joinType=[inner])
  EnumerableSort(sort0=[$0], dir0=[ASC])
    EnumerableMergeJoin(condition=[=($2, $8)], joinType=[inner])
      EnumerableSort(sort0=[$2], dir0=[ASC])
        EnumerableTableScan(table=[[foodmart2, sales_fact_1997]])
      EnumerableCalc(expr#0..28=[{inputs}], expr#29=['San Francisco':VARCHAR(30)], expr#30=[=($t9, $t29)], proj#0..28=[{exprs}], $condition=[$t30])
        EnumerableTableScan(table=[[foodmart2, customer]])
  EnumerableTableScan(table=[[foodmart2, product]])
!plan

# 4-way join whose optimal plan requires bushy join.
#
# In the plan, note that filters on customer.city and product_department are
# pushed down. And the plan is a bushy join, with sub-joins (product_class,
# product) and (sales_fact_1997, customer).  However, scan(sales_fact_1997)
# should be left-most leaf, but is not because CommutativeJoinRule is currently
# disabled.
!use foodmart
select *
from "sales_fact_1997" as s
  join "customer" as c on s."customer_id" = c."customer_id"
  join "product" as p on s."product_id" = p."product_id"
  join "product_class" as pc on p."product_class_id" = pc."product_class_id"
where c."city" = 'San Francisco'
 and pc."product_department" = 'Snacks';
EnumerableCalc(expr#0..56=[{inputs}], product_id0=[$t20], time_id=[$t21], customer_id=[$t22], promotion_id=[$t23], store_id=[$t24], store_sales=[$t25], store_cost=[$t26], unit_sales=[$t27], customer_id0=[$t28], account_num=[$t29], lname=[$t30], fname=[$t31], mi=[$t32], address1=[$t33], address2=[$t34], address3=[$t35], address4=[$t36], city=[$t37], state_province=[$t38], postal_code=[$t39], country=[$t40], customer_region_id=[$t41], phone1=[$t42], phone2=[$t43], birthdate=[$t44], marital_status=[$t45], yearly_income=[$t46], gender=[$t47], total_children=[$t48], num_children_at_home=[$t49], education=[$t50], date_accnt_opened=[$t51], member_card=[$t52], occupation=[$t53], houseowner=[$t54], num_cars_owned=[$t55], fullname=[$t56], product_class_id0=[$t5], product_id=[$t6], brand_name=[$t7], product_name=[$t8], SKU=[$t9], SRP=[$t10], gross_weight=[$t11], net_weight=[$t12], recyclable_package=[$t13], low_fat=[$t14], units_per_case=[$t15], cases_per_pallet=[$t16], shelf_width=[$t17], shelf_height=[$t18], shelf_depth=[$t19], product_class_id=[$t0], product_subcategory=[$t1], product_category=[$t2], product_department=[$t3], product_family=[$t4])
  EnumerableHashJoin(condition=[=($6, $20)], joinType=[inner])
    EnumerableHashJoin(condition=[=($0, $5)], joinType=[inner])
      EnumerableCalc(expr#0..4=[{inputs}], expr#5=['Snacks':VARCHAR(30)], expr#6=[=($t3, $t5)], proj#0..4=[{exprs}], $condition=[$t6])
        EnumerableTableScan(table=[[foodmart2, product_class]])
      EnumerableTableScan(table=[[foodmart2, product]])
    EnumerableMergeJoin(condition=[=($2, $8)], joinType=[inner])
      EnumerableSort(sort0=[$2], dir0=[ASC])
        EnumerableTableScan(table=[[foodmart2, sales_fact_1997]])
      EnumerableCalc(expr#0..28=[{inputs}], expr#29=['San Francisco':VARCHAR(30)], expr#30=[=($t9, $t29)], proj#0..28=[{exprs}], $condition=[$t30])
        EnumerableTableScan(table=[[foodmart2, customer]])
!plan

# Check that when filters are merged, duplicate conditions are eliminated.
select * from (
  select * from "days"
  where "day" = 1)
where "day" = 1;
EnumerableCalc(expr#0..1=[{inputs}], expr#2=[1], expr#3=[=($t0, $t2)], proj#0..1=[{exprs}], $condition=[$t3])
  EnumerableTableScan(table=[[foodmart2, days]])
!plan

# [HIVE-5873] Semi-join to count sub-query
# [CALCITE-365] AssertionError while translating query with WITH and correlated sub-query
with parts (PNum, OrderOnHand)
     as (select * from (values (3, 6), (10, 1), (8, 0)) as t(PNum, OrderOnHand)),
  supply (PNum, Qty)
     as (select * from (values (3, 4), (3, 2), (10, 1)))
select pnum
from parts p
where orderOnHand
     in (select count(*) from supply s
          where s.pnum = p.pnum);
+------+
| PNUM |
+------+
|    8 |
|   10 |
+------+
(2 rows)

!ok

# [HIVE-7362]
# Just checking that HAVING-EXISTS works.
with src (key, "value")
  as (select * from (values (1, 'a'), (2, 'z')) as t(key, "value"))
select b.key, count(*) as c
from src b
group by b.key
having exists
  (select a.key
  from src a
  where a.key = b.key and a."value" > 'val_9');
+-----+---+
| KEY | C |
+-----+---+
|   2 | 1 |
+-----+---+
(1 row)

!ok

# [CALCITE-411] Duplicate aliases
select 1 as a, 2 as a from (values (true));
+---+---+
| A | A |
+---+---+
| 1 | 2 |
+---+---+
(1 row)

!ok

select "day", "day" from "days" where "day" < 3;
+-----+-----+
| day | day |
+-----+-----+
|   1 |   1 |
|   2 |   2 |
+-----+-----+
(2 rows)

!ok

# [DERBY-5313] CASE expression in GROUP BY clause
select case when a=1 then 1 else 2 end
from "days" t1(a,x) join "days" t2(b,x) on a=b
group by case when a=1 then 1 else 2 end;
+--------+
| EXPR$0 |
+--------+
|      1 |
|      2 |
+--------+
(2 rows)

!ok

# [DERBY-4450] GROUP BY in an IN-sub-query inside HAVING clause whose select
# list is subset of group by columns.
select sum("day") from "days" group by "week_day" having "week_day" in (
  select "week_day" from "days" group by "week_day", "day");
+--------+
| EXPR$0 |
+--------+
|      1 |
|      2 |
|      3 |
|      4 |
|      5 |
|      6 |
|      7 |
+--------+
(7 rows)

!ok

# [DERBY-4701] Aggregate function on a GROUP BY column also present in a HAVING
# clause
SELECT MAX("day") as m, COUNT(T."week_day") AS c
FROM "days" T
GROUP BY T."week_day"
HAVING COUNT(T."week_day") = 1;
+---+---+
| M | C |
+---+---+
| 1 | 1 |
| 2 | 1 |
| 3 | 1 |
| 4 | 1 |
| 5 | 1 |
| 6 | 1 |
| 7 | 1 |
+---+---+
(7 rows)

!ok

# [DERBY-3616] Combinations of DISTINCT and GROUP BY
!use post
select distinct gender from emp group by gender;
+--------+
| GENDER |
+--------+
| F      |
| M      |
+--------+
(2 rows)

!ok
select distinct gender from emp group by gender, deptno;
+--------+
| GENDER |
+--------+
| F      |
| M      |
+--------+
(2 rows)

!ok
select gender, deptno from emp;
+--------+--------+
| GENDER | DEPTNO |
+--------+--------+
| F      |     10 |
| F      |     30 |
| F      |     30 |
| F      |     50 |
| F      |     60 |
| F      |        |
| M      |     10 |
| M      |     20 |
| M      |     50 |
+--------+--------+
(9 rows)

!ok
select distinct gender, deptno from emp group by gender, deptno, ename;
+--------+--------+
| GENDER | DEPTNO |
+--------+--------+
| F      |     10 |
| F      |     30 |
| F      |     50 |
| F      |     60 |
| F      |        |
| M      |     10 |
| M      |     20 |
| M      |     50 |
+--------+--------+
(8 rows)

!ok
select distinct gender, deptno from emp group by gender, deptno;
+--------+--------+
| GENDER | DEPTNO |
+--------+--------+
| F      |     10 |
| F      |     30 |
| F      |     50 |
| F      |     60 |
| F      |        |
| M      |     10 |
| M      |     20 |
| M      |     50 |
+--------+--------+
(8 rows)

!ok
select distinct gender, deptno from emp group by gender, ename, deptno;
+--------+--------+
| GENDER | DEPTNO |
+--------+--------+
| F      |     10 |
| F      |     30 |
| F      |     50 |
| F      |     60 |
| F      |        |
| M      |     10 |
| M      |     20 |
| M      |     50 |
+--------+--------+
(8 rows)

!ok
select distinct gender, sum(deptno) as s from emp group by gender, deptno;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 50 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(7 rows)

!ok
select gender, sum(deptno) as s from emp group by gender, deptno;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 50 |
| F      | 60 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(8 rows)

!ok
select gender, sum(deptno) as s from emp group by gender, ename;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 30 |
| F      | 30 |
| F      | 50 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(9 rows)

!ok
select distinct gender, sum(deptno) as s from emp group by gender, ename;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 30 |
| F      | 50 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(8 rows)

!ok
select gender, sum(deptno) as s from emp group by gender, deptno, ename;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 30 |
| F      | 30 |
| F      | 50 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(9 rows)

!ok
select distinct gender, sum(deptno) as s from emp group by gender, deptno, ename;
+--------+----+
| GENDER | S  |
+--------+----+
| F      | 10 |
| F      | 30 |
| F      | 50 |
| F      | 60 |
| F      |    |
| M      | 10 |
| M      | 20 |
| M      | 50 |
+--------+----+
(8 rows)

!ok
select distinct gender, sum(deptno) as s from emp group by gender;
+--------+-----+
| GENDER | S   |
+--------+-----+
| F      | 180 |
| M      |  80 |
+--------+-----+
(2 rows)

!ok

select distinct gender, deptno from emp group by gender;
Expression 'DEPTNO' is not being grouped
!error

select distinct gender, deptno from emp group by gender, ename;
Expression 'DEPTNO' is not being grouped
!error

select distinct gender, deptno, sum(deptno) as s from emp group by gender;
Expression 'DEPTNO' is not being grouped
!error

!use scott

# In Quidem's "scott" schema, we allow CREATE VIEW
create view v as
  select * from (values (1, 'a'), (2, 'b')) as t (x, y);
(0 rows modified)

!update

select count(*) as c
from v;
+---+
| C |
+---+
| 2 |
+---+
(1 row)

!ok

# ORDER BY expression with SELECT DISTINCT
select distinct deptno, job
from "scott".emp
order by substring(job from 2 for 1), -deptno;
+--------+-----------+
| DEPTNO | JOB       |
+--------+-----------+
|     30 | SALESMAN  |
|     30 | MANAGER   |
|     20 | MANAGER   |
|     10 | MANAGER   |
|     30 | CLERK     |
|     20 | CLERK     |
|     10 | CLERK     |
|     20 | ANALYST   |
|     10 | PRESIDENT |
+--------+-----------+
(9 rows)

!ok

# [CALCITE-2180] Invalid code generated for negative of byte and short values
select -deptno as d
from "scott".dept;
+-----+
| D   |
+-----+
| -40 |
| -30 |
| -20 |
| -10 |
+-----+
(4 rows)

!ok

# [CALCITE-2099] Incorrect code generated for UNION
select count(*) as c from "scott".emp group by deptno
union
select count(*) as c from "scott".emp group by deptno;
+---+
| C |
+---+
| 3 |
| 5 |
| 6 |
+---+
(3 rows)

!ok

# Similar
select count(*) as c from "scott".emp group by job
union all
select count(*) as c from "scott".dept group by deptno;
+---+
| C |
+---+
| 1 |
| 1 |
| 1 |
| 1 |
| 1 |
| 2 |
| 3 |
| 4 |
| 4 |
+---+
(9 rows)

!ok

# [CALCITE-1864] Allow NULL literal as argument
select count(*) as c from "scott".emp where empno > null;
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok

# [CALCITE-613] Implicitly convert strings in comparisons
select * from "scott".emp where hiredate < '1981-01-02';
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok
EnumerableCalc(expr#0..7=[{inputs}], expr#8=[1981-01-02], expr#9=[<($t4, $t8)], proj#0..7=[{exprs}], $condition=[$t9])
  EnumerableTableScan(table=[[scott, EMP]])
!plan
select * from "scott".emp where '1981-01-02' > hiredate;
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok
select * from "scott".emp where hiredate between '1981-01-02' and '1981-06-01';
+-------+-------+----------+------+------------+---------+--------+--------+
| EMPNO | ENAME | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |
+-------+-------+----------+------+------------+---------+--------+--------+
|  7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 |     30 |
|  7521 | WARD  | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 |     30 |
|  7566 | JONES | MANAGER  | 7839 | 1981-02-04 | 2975.00 |        |     20 |
|  7698 | BLAKE | MANAGER  | 7839 | 1981-01-05 | 2850.00 |        |     30 |
+-------+-------+----------+------+------------+---------+--------+--------+
(4 rows)

!ok
select * from "scott".emp where hiredate > '1986-01-02';
+-------+-------+---------+------+------------+---------+------+--------+
| EMPNO | ENAME | JOB     | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+-------+---------+------+------------+---------+------+--------+
|  7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 |      |     20 |
|  7876 | ADAMS | CLERK   | 7788 | 1987-05-23 | 1100.00 |      |     20 |
+-------+-------+---------+------+------------+---------+------+--------+
(2 rows)

!ok
select * from "scott".emp where '1986-01-02' < hiredate;
+-------+-------+---------+------+------------+---------+------+--------+
| EMPNO | ENAME | JOB     | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+-------+---------+------+------------+---------+------+--------+
|  7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 |      |     20 |
|  7876 | ADAMS | CLERK   | 7788 | 1987-05-23 | 1100.00 |      |     20 |
+-------+-------+---------+------+------------+---------+------+--------+
(2 rows)

!ok
select * from "scott".emp where '1986-' || '01-02' < hiredate;
+-------+-------+---------+------+------------+---------+------+--------+
| EMPNO | ENAME | JOB     | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+-------+---------+------+------------+---------+------+--------+
|  7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 |      |     20 |
|  7876 | ADAMS | CLERK   | 7788 | 1987-05-23 | 1100.00 |      |     20 |
+-------+-------+---------+------+------------+---------+------+--------+
(2 rows)

!ok
select * from "scott".emp where sal < '1100';
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
|  7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 |      |     30 |
+-------+-------+-------+------+------------+--------+------+--------+
(2 rows)

!ok
select * from "scott".emp where empno in ('7369', '7876');
+-------+-------+-------+------+------------+---------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+-------+-------+------+------------+---------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 |  800.00 |      |     20 |
|  7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 |      |     20 |
+-------+-------+-------+------+------------+---------+------+--------+
(2 rows)

!ok
select * from "scott".emp where empno between '7500' and '07600';
+-------+-------+----------+------+------------+---------+--------+--------+
| EMPNO | ENAME | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |
+-------+-------+----------+------+------------+---------+--------+--------+
|  7521 | WARD  | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 |     30 |
|  7566 | JONES | MANAGER  | 7839 | 1981-02-04 | 2975.00 |        |     20 |
+-------+-------+----------+------+------------+---------+--------+--------+
(2 rows)

!ok

# BETWEEN follows the PostgreSQL style to coerce STRING operand to type of the other
# NUMERIC operands, see TypeCoercionImpl#commonTypeForBinaryComparison.
select * from "scott".emp where deptno between '7369' and '7876';

Caused by: java.lang.NumberFormatException: Value out of range. Value:"7369" Radix:10
!error

select * from "scott".emp where '7369' between empno and '7876';
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok

# [CALCITE-546] Allow table, column and field called "*"
# See [DRILL-3859], [DRILL-3860].
SELECT * FROM (VALUES (0, 0)) AS T(A, "*");
+---+---+
| A | * |
+---+---+
| 0 | 0 |
+---+---+
(1 row)

!ok

SELECT a FROM (VALUES (0, 0)) AS T(A, "*");
+---+
| A |
+---+
| 0 |
+---+
(1 row)

!ok

SELECT b FROM (VALUES (0, 0)) AS T(A, "*");
Column 'B' not found in any table
!error

# See [DRILL-3860].
SELECT "a" FROM (VALUES (1, 2, 3, 4)) AS T("a", "A", ".", "*");
+---+
| a |
+---+
| 1 |
+---+
(1 row)

!ok

SELECT "A" FROM (VALUES (1, 2, 3, 4)) AS T("a", "A", ".", "*");
+---+
| A |
+---+
| 2 |
+---+
(1 row)

!ok

SELECT "." FROM (VALUES (1, 2, 3, 4)) AS T("a", "A", ".", "*");
+---+
| . |
+---+
| 3 |
+---+
(1 row)

!ok

SELECT "*" FROM (VALUES (1, 2, 3, 4)) AS T("a", "A", ".", "*");
+---+
| * |
+---+
| 4 |
+---+
(1 row)

!ok

SELECT * FROM (VALUES (1, 2, 3, 4)) AS T("a", "A", ".", "*");
+---+---+---+---+
| a | A | . | * |
+---+---+---+---+
| 1 | 2 | 3 | 4 |
+---+---+---+---+
(1 row)

!ok

# Implicit ROW
select deptno, (empno, deptno) as r
from "scott".emp;
+--------+------------+
| DEPTNO | R          |
+--------+------------+
|     10 | {7782, 10} |
|     10 | {7839, 10} |
|     10 | {7934, 10} |
|     20 | {7369, 20} |
|     20 | {7566, 20} |
|     20 | {7788, 20} |
|     20 | {7876, 20} |
|     20 | {7902, 20} |
|     30 | {7499, 30} |
|     30 | {7521, 30} |
|     30 | {7654, 30} |
|     30 | {7698, 30} |
|     30 | {7844, 30} |
|     30 | {7900, 30} |
+--------+------------+
(14 rows)

!ok

# Explicit ROW
select deptno, row (empno, deptno) as r
from "scott".emp;
+--------+------------+
| DEPTNO | R          |
+--------+------------+
|     10 | {7782, 10} |
|     10 | {7839, 10} |
|     10 | {7934, 10} |
|     20 | {7369, 20} |
|     20 | {7566, 20} |
|     20 | {7788, 20} |
|     20 | {7876, 20} |
|     20 | {7902, 20} |
|     30 | {7499, 30} |
|     30 | {7521, 30} |
|     30 | {7654, 30} |
|     30 | {7698, 30} |
|     30 | {7844, 30} |
|     30 | {7900, 30} |
+--------+------------+
(14 rows)

!ok

# [CALCITE-877] Allow ROW as argument to COLLECT
select deptno, collect(r) as empnos
from (select deptno, (empno, deptno) as r
  from "scott".emp)
group by deptno;
+--------+--------------------------------------------------------------------------+
| DEPTNO | EMPNOS                                                                   |
+--------+--------------------------------------------------------------------------+
|     10 | [{7782, 10}, {7839, 10}, {7934, 10}]                                     |
|     20 | [{7369, 20}, {7566, 20}, {7788, 20}, {7876, 20}, {7902, 20}]             |
|     30 | [{7499, 30}, {7521, 30}, {7654, 30}, {7698, 30}, {7844, 30}, {7900, 30}] |
+--------+--------------------------------------------------------------------------+
(3 rows)

!ok

# [CALCITE-922] Value of INTERVAL literal
select deptno * interval '2' day as d2,
 deptno * interval -'3' hour as h3,
 deptno * interval -'-4' hour as h4,
 deptno * interval -'4:30' hour to minute as h4_5,
 deptno * interval -'-1-3' year to month as y1_25
from "scott".dept;
+-----+------+------+---------+--------+
| D2  | H3   | H4   | H4_5    | Y1_25  |
+-----+------+------+---------+--------+
| +20 | -30  | +40  | -45:00  | +12-06 |
| +40 | -60  | +80  | -90:00  | +25-00 |
| +60 | -90  | +120 | -135:00 | +37-06 |
| +80 | -120 | +160 | -180:00 | +50-00 |
+-----+------+------+---------+--------+
(4 rows)

!ok

# [CALCITE-4091] Interval expressions
select empno, mgr, date '1970-01-01' + interval empno day as d,
  timestamp '1970-01-01 00:00:00' + interval (mgr / 100) minute as ts
from "scott".emp
order by empno;
+-------+------+------------+---------------------+
| EMPNO | MGR  | D          | TS                  |
+-------+------+------------+---------------------+
|  7369 | 7902 | 1990-03-06 | 1970-01-01 01:19:00 |
|  7499 | 7698 | 1990-07-14 | 1970-01-01 01:16:00 |
|  7521 | 7698 | 1990-08-05 | 1970-01-01 01:16:00 |
|  7566 | 7839 | 1990-09-19 | 1970-01-01 01:18:00 |
|  7654 | 7698 | 1990-12-16 | 1970-01-01 01:16:00 |
|  7698 | 7839 | 1991-01-29 | 1970-01-01 01:18:00 |
|  7782 | 7839 | 1991-04-23 | 1970-01-01 01:18:00 |
|  7788 | 7566 | 1991-04-29 | 1970-01-01 01:15:00 |
|  7839 |      | 1991-06-19 |                     |
|  7844 | 7698 | 1991-06-24 | 1970-01-01 01:16:00 |
|  7876 | 7788 | 1991-07-26 | 1970-01-01 01:17:00 |
|  7900 | 7698 | 1991-08-19 | 1970-01-01 01:16:00 |
|  7902 | 7566 | 1991-08-21 | 1970-01-01 01:15:00 |
|  7934 | 7782 | 1991-09-22 | 1970-01-01 01:17:00 |
+-------+------+------------+---------------------+
(14 rows)

!ok

# [CALCITE-1486] Invalid "Invalid literal" error for complex expression
select 8388608/(60+27.39);
+-------------------+
| EXPR$0            |
+-------------------+
| 95990.47945989244 |
+-------------------+
(1 row)

!ok

# [CALCITE-1120] Support SELECT without FROM
select 2 + 2;
+--------+
| EXPR$0 |
+--------+
|      4 |
+--------+
(1 row)

!ok

select 2 + 2 as a, 'b' as b;
+---+---+
| A | B |
+---+---+
| 4 | b |
+---+---+
(1 row)

!ok

select distinct 2 as a, 'b' as b;
+---+---+
| A | B |
+---+---+
| 2 | b |
+---+---+
(1 row)

!ok

select distinct 2 as a, 'b' as b
order by 2;
+---+---+
| A | B |
+---+---+
| 2 | b |
+---+---+
(1 row)

!ok

select distinct 2 as a, 'b' as b
union all
select 3, 'c';
+---+---+
| A | B |
+---+---+
| 2 | b |
| 3 | c |
+---+---+
(2 rows)

!ok

# Composite UNION
select deptno, deptno from "scott".emp
union
select deptno, deptno from "scott".dept;
+--------+--------+
| DEPTNO | DEPTNO |
+--------+--------+
|     10 |     10 |
|     20 |     20 |
|     30 |     30 |
|     40 |     40 |
+--------+--------+
(4 rows)

!ok

# Composite MINUS
select deptno, deptno from "scott".emp
except
select deptno, deptno from "scott".dept where deptno = 10;
+--------+--------+
| DEPTNO | DEPTNO |
+--------+--------+
|     20 |     20 |
|     30 |     30 |
+--------+--------+
(2 rows)

!ok

select * from (
  select 2 as a, 3 as b)
where a < b;
+---+---+
| A | B |
+---+---+
| 2 | 3 |
+---+---+
(1 row)

!ok

select * from (
  select distinct 2 as a, 3 as b)
where a > b;
+---+---+
| A | B |
+---+---+
+---+---+
(0 rows)

!ok

select count(*) as c from "scott".dept where exists (select 1);
+---+
| C |
+---+
| 4 |
+---+
(1 row)

!ok

# INTERSECT
select deptno from "scott".emp
intersect
select deptno from "scott".dept;
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
+--------+
(3 rows)

!ok

# INTERSECT DISTINCT means the same as INTERSECT
select deptno from "scott".emp
intersect distinct
select deptno from "scott".dept;
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
+--------+
(3 rows)

!ok

# INTERSECT can return NULL values
select comm from "scott".emp where mgr = 7698
intersect
select comm from "scott".emp where deptno = 10;
+------+
| COMM |
+------+
|      |
+------+
(1 row)

!ok

# As above, composite
select job, comm from "scott".emp where mgr = 7698
intersect
select job, comm from "scott".emp where deptno = 10;
+-------+------+
| JOB   | COMM |
+-------+------+
| CLERK |      |
+-------+------+
(1 row)

!ok

# Make sure that IN does not compare the shorter of two strings.
# If it did, 'MARTIN' would be emitted.
select ename, deptno
from "scott".emp
where ename in ('MARTINGALE', 'WARD');
+-------+--------+
| ENAME | DEPTNO |
+-------+--------+
| WARD  |     30 |
+-------+--------+
(1 row)

!ok

# [DRILL-4906]
select (case when (true) then 1 end) from (values(1));
+--------+
| EXPR$0 |
+--------+
|      1 |
+--------+
(1 row)

!ok
EXPR$0 INTEGER(10)
!type

# Cast a character literal to a timestamp; note: the plan does not contain CAST
values cast('1969-07-21 12:34:56' as timestamp);
+---------------------+
| EXPR$0              |
+---------------------+
| 1969-07-21 12:34:56 |
+---------------------+
(1 row)

!ok
EnumerableValues(tuples=[[{ 1969-07-21 12:34:56 }]])
!plan

# Cast a character literal without time to a timestamp; note: the plan does not contain CAST
values cast('1969-07-21' as timestamp);
+---------------------+
| EXPR$0              |
+---------------------+
| 1969-07-21 00:00:00 |
+---------------------+
(1 row)

!ok
EnumerableValues(tuples=[[{ 1969-07-21 00:00:00 }]])
!plan

# Cast a character literal to a date; note: the plan does not contain CAST
values cast('1969-07-21' as date);
+------------+
| EXPR$0     |
+------------+
| 1969-07-21 |
+------------+
(1 row)

!ok
EnumerableValues(tuples=[[{ 1969-07-21 }]])
!plan

# Slightly different format
# (Incidentally, this format is not allowed in date literals, per the standard)
values cast('1989-7-4' as date);
+------------+
| EXPR$0     |
+------------+
| 1989-07-04 |
+------------+
(1 row)

!ok

# Cast a character literal to an integer; note: the plan does not contain CAST
values cast('196907' as integer);
+--------+
| EXPR$0 |
+--------+
| 196907 |
+--------+
(1 row)

!ok
EnumerableValues(tuples=[[{ 196907 }]])
!plan

# Cast an integer literal to a bigint; note: the plan does not contain CAST
values cast(123 as bigint);
+--------+
| EXPR$0 |
+--------+
|    123 |
+--------+
(1 row)

!ok
EnumerableValues(tuples=[[{ 123 }]])
!plan

# Cast an integer literal to a decimal; note: the plan does not contain CAST
values cast('123.45' as decimal(5, 2));
+--------+
| EXPR$0 |
+--------+
| 123.45 |
+--------+
(1 row)

!ok
EnumerableValues(tuples=[[{ 123.45 }]])
!plan

# Cast a character literal to a decimal; note: the plan does not contain CAST
values cast('123.45' as decimal(5, 2));
+--------+
| EXPR$0 |
+--------+
| 123.45 |
+--------+
(1 row)

!ok
EnumerableValues(tuples=[[{ 123.45 }]])
!plan

# Cast a character literal to a double; note: the plan does not contain CAST
values cast('-123.45' as double);
+---------+
| EXPR$0  |
+---------+
| -123.45 |
+---------+
(1 row)

!ok
EnumerableValues(tuples=[[{ -1.2345E2 }]])
!plan

values cast('false' as boolean);
+--------+
| EXPR$0 |
+--------+
| false  |
+--------+
(1 row)

!ok
EnumerableValues(tuples=[[{ false }]])
!plan

values cast('TRUE' as boolean);
+--------+
| EXPR$0 |
+--------+
| true   |
+--------+
(1 row)

!ok
EnumerableValues(tuples=[[{ true }]])
!plan

values cast('TR' || 'UE' as boolean);
+--------+
| EXPR$0 |
+--------+
| true   |
+--------+
(1 row)

!ok
EnumerableCalc(expr#0=[{inputs}], expr#1=['TR'], expr#2=['UE'], expr#3=[||($t1, $t2)], expr#4=[CAST($t3):BOOLEAN NOT NULL], EXPR$0=[$t4])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

!if (fixed.calcite2539) {

# In the following, that we get an error at run time,
# and that the plan shows that the expression has not been reduced.
values cast('null' as boolean);
Invalid character for cast
!error
EnumerableCalc(expr#0=[{inputs}], expr#1=['null'], expr#2=[CAST($t1):BOOLEAN NOT NULL], EXPR$0=[$t2])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# The following throw give an error (good!)
# but throw java.lang.ExceptionInInitializerError (not great).
values cast('' as date);
Caused by: java.lang.NumberFormatException: For input string: ""
!error

values cast('' as timestamp);
Caused by: java.lang.NumberFormatException: For input string: ""
!error

values cast('' as integer);
Caused by: java.lang.NumberFormatException: For input string: ""
!error

values cast('' as boolean);
Caused by: java.lang.RuntimeException: Invalid character for cast
!error

values cast('' as double);
Caused by: java.lang.NumberFormatException: empty String
!error

# Postgres fails:
#  ERROR:  invalid input syntax for integer: "1.56"
values cast('15.6' as integer);
Caused by: java.lang.NumberFormatException: For input string: "15.6"
!error

# Postgres fails:
#  ERROR:  invalid input syntax for integer: " - 5 "
values cast(' - 5 ' as double);
Caused by: java.lang.NumberFormatException: For input string: "- 5"
!error

# Out of TINYINT range (max 127)
values cast('200' as tinyint);
Caused by: java.lang.NumberFormatException: Value out of range. Value:"200" Radix:10
!error

# Out of SMALLINT range (max 32767)
values cast('50000' as smallint);
Caused by: java.lang.NumberFormatException: Value out of range. Value:"50000" Radix:10
!error

# Out of INTEGER range (max 2.1e9)
values cast('4567891234' as integer);
Caused by: java.lang.NumberFormatException: For input string: "4567891234"
!error

# Out of BIGINT range (max 9.2e18)
values cast('12345678901234567890' as bigint);
Caused by: java.lang.NumberFormatException: For input string: "12345678901234567890"
!error
!}

# Out of REAL range
# (Should give an error, not infinity.)
values cast('12.34e56' as real);
+----------+
| EXPR$0   |
+----------+
| Infinity |
+----------+
(1 row)

!ok

# Out of FLOAT range
# (Should give an error, not infinity.)
values cast('12.34e5678' as float);
+----------+
| EXPR$0   |
+----------+
| Infinity |
+----------+
(1 row)

!ok

# Out of DOUBLE range
# (Should give an error, not infinity.)
values cast('12.34e5678' as double);
+----------+
| EXPR$0   |
+----------+
| Infinity |
+----------+
(1 row)

!ok

# Postgres succeeds
values cast(' -5 ' as double);
+--------+
| EXPR$0 |
+--------+
|   -5.0 |
+--------+
(1 row)

!ok

# RAND_INTEGER with seed
select i, rand_integer(1, 5) as r
from (values 1, 2, 3, 4, 5) as t(i);
+---+---+
| I | R |
+---+---+
| 1 | 0 |
| 2 | 3 |
| 3 | 2 |
| 4 | 3 |
| 5 | 4 |
+---+---+
(5 rows)

!ok

# Same query, should yield same results
select i, rand_integer(1, 5) as r
from (values 1, 2, 3, 4, 5) as t(i);
+---+---+
| I | R |
+---+---+
| 1 | 0 |
| 2 | 3 |
| 3 | 2 |
| 4 | 3 |
| 5 | 4 |
+---+---+
(5 rows)

!ok

# Same query with different seed
select i, rand_integer(-1, 5) as r
from (values 1, 2, 3, 4, 5) as t(i);
+---+---+
| I | R |
+---+---+
| 1 | 3 |
| 2 | 0 |
| 3 | 4 |
| 4 | 4 |
| 5 | 4 |
+---+---+
(5 rows)

!ok

# Same query with different bound
select i, rand_integer(-1, 2) as r
from (values 1, 2, 3, 4, 5) as t(i);
+---+---+
| I | R |
+---+---+
| 1 | 0 |
| 2 | 0 |
| 3 | 0 |
| 4 | 1 |
| 5 | 1 |
+---+---+
(5 rows)

!ok

# RAND with seed
select i, rand(-1) as r
from (values 1, 2, 3, 4, 5) as t(i);
+---+---------------------+
| I | R                   |
+---+---------------------+
| 1 | 0.03305388522187047 |
| 2 |  0.6573104025344794 |
| 3 |  0.7450920948729041 |
| 4 |  0.6624972807480889 |
| 5 |  0.5532616835728703 |
+---+---------------------+
(5 rows)

!ok

# PI function
values pi;
+-------------------+
| PI                |
+-------------------+
| 3.141592653589793 |
+-------------------+
(1 row)

!ok

# DEGREES function
values (degrees(pi), degrees(-pi / 2));
+--------+--------+
| EXPR$0 | EXPR$1 |
+--------+--------+
|  180.0 |  -90.0 |
+--------+--------+
(1 row)

!ok

# [CALCITE-1592] SqlToRelConverter throws UnsupportedOperationException if query has NOT ... NOT IN
select * from "scott".emp where not (ename not in ('Fred'));
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

select count(*) as c from "scott".emp where not (ename in ('Fred'));
+----+
| C  |
+----+
| 14 |
+----+
(1 row)

!ok

# [CALCITE-1638] Simplify "$x = $x" to "$x is not null"
select count(*) as c from "scott".emp where deptno > deptno;
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok
EnumerableAggregate(group=[{}], C=[COUNT()])
  EnumerableValues(tuples=[[]])
!plan

# [CALCITE-1659] Simplifying CAST('YYYY-MM-DD hh:mm:ss.SSS' as TIMESTAMP)
# should round the sub-second fraction
select TIMESTAMP '2016-02-26 19:06:00.123456789',
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(0)),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(1)),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(2)),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(3)),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(6)),
  CAST('2016-02-26 19:06:00.123' as TIMESTAMP(9));
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
| EXPR$0              | EXPR$1              | EXPR$2              | EXPR$3              | EXPR$4              | EXPR$5              | EXPR$6              | EXPR$7              |
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
| 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 | 2016-02-26 19:06:00 |
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
(1 row)

!ok
EnumerableValues(tuples=[[{ 2016-02-26 19:06:00.123, 2016-02-26 19:06:00, 2016-02-26 19:06:00, 2016-02-26 19:06:00.1, 2016-02-26 19:06:00.12, 2016-02-26 19:06:00.123, 2016-02-26 19:06:00.123, 2016-02-26 19:06:00.123 }]])
!plan

# [CALCITE-1664] CAST('<string>' as TIMESTAMP) adds part of sub-second fraction to the value
select
  TIMESTAMP '2016-02-26 19:06:00.12345678',
  CAST('2016-02-26 19:06:00.12345678' as TIMESTAMP),
  TIMESTAMPDIFF(SECOND,
    TIMESTAMP '2016-02-26 19:06:00.123456789',
    CAST('2016-02-26 19:06:00.123456789' as TIMESTAMP));
+---------------------+---------------------+--------+
| EXPR$0              | EXPR$1              | EXPR$2 |
+---------------------+---------------------+--------+
| 2016-02-26 19:06:00 | 2016-02-26 19:06:00 |      0 |
+---------------------+---------------------+--------+
(1 row)

!ok

# ARRAY and MULTISET
select array[1,2] as a from (values (1));
+--------+
| A      |
+--------+
| [1, 2] |
+--------+
(1 row)

!ok

select array[1,null,2] as a from (values (1));
+--------------+
| A            |
+--------------+
| [1, null, 2] |
+--------------+
(1 row)

!ok

values array['a',null,'bcd'],
  array['efgh'];
+----------------+
| EXPR$0         |
+----------------+
| [a, null, bcd] |
| [efgh]         |
+----------------+
(2 rows)

!ok

select multiset[1,null,2,2-1] as m from (values (1));
+-----------------+
| M               |
+-----------------+
| [1, 1, null, 2] |
+-----------------+
(1 row)

!ok

!use catchall

# [CALCITE-1054] NPE caused by wrong code generation for Timestamp fields
select "sqlTimestamp" as T
from "everyTypes"
where "sqlTimestamp" >= {ts '1969-01-01 00:00:00'}
and "sqlTimestamp" < {ts '1998-01-01 00:00:00'};
+---------------------+
| T                   |
+---------------------+
| 1970-01-01 00:00:00 |
+---------------------+
(1 row)

!ok

# [CALCITE-1188] NullPointerException in EXTRACT with WHERE ... IN clause if field has null value
select "sqlTimestamp" T
from "everyTypes"
where extract(YEAR from "sqlTimestamp") IN (1969, 1970);
+---------------------+
| T                   |
+---------------------+
| 1970-01-01 00:00:00 |
+---------------------+
(1 row)

!ok

!if (false) {
# [CALCITE-2032] Error when implicitly converting character literal to date literal
select *
from "scott".emp
WHERE hiredate = '1980-12-17';
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok
!}

# [CALCITE-2002] DISTINCT applied to VALUES returns wrong result
SELECT DISTINCT T.B
FROM (VALUES (1, 'X'),(2, 'Y'),(3, 'X'),(4, 'X')) AS T(A, B);
+---+
| B |
+---+
| X |
| Y |
+---+
(2 rows)

!ok

# [CALCITE-2183] Implement RelSubset.copy
select *
from (values (1, 'a'), (2, 'b'), (1, 'b'), (2, 'c'), (2, 'c')) as t(x, y)
where false;
+---+---+
| X | Y |
+---+---+
+---+---+
(0 rows)

!ok

# [CALCITE-2447] POWER, ATAN2 functions fail with NoSuchMethodException
values power(0.5, 2);
+--------+
| EXPR$0 |
+--------+
|   0.25 |
+--------+
(1 row)

!ok

# [CALCITE-2447] POWER, ATAN2 functions fail with NoSuchMethodException
values atan2(0.5, 2);
+---------------------+
| EXPR$0              |
+---------------------+
| 0.24497866312686414 |
+---------------------+
(1 row)

!ok

!set outputformat csv

# [CALCITE-1167] OVERLAPS should match even if operands are in (high, low) order
values ((date '1999-12-01', date '2001-12-31') overlaps (date '2001-01-01' , date '2002-11-11'));
EXPR$0
true
!ok

values ((date '2001-12-31', date '1999-12-01') overlaps (date '2001-01-01' , date '2002-11-11'));
EXPR$0
true
!ok

values ((date '2001-12-31', date '1999-12-01') overlaps (date '2002-11-11', date '2001-01-01'));
EXPR$0
true
!ok

values ((date '2001-12-31', date '1999-12-01') overlaps (date '2002-01-01', date '2002-11-11'));
EXPR$0
false
!ok

# Sub-query returns a MAP, column is renamed, and enclosing query references the map.
select mycol['b'] as x
from (select map['a', false, 'b', true] from (values (2))) as t(mycol);
X
true
!ok

# JSON
values json_exists('{"foo":"bar"}', 'strict $.foo' false on error);
EXPR$0
true
!ok

# [CALCITE-2908] Implement SQL LAST_DAY function
with data(c_date, c_timestamp) as (select * from (values
    (DATE'1965-01-10', TIMESTAMP '1965-01-10 20:20:20'),
    (DATE'2019-01-01', TIMESTAMP '2019-01-01 18:19:20'),
    (DATE'2019-02-20', TIMESTAMP '2019-02-20 00:00:00'),
    (DATE'2019-02-28', TIMESTAMP '2019-02-28 03:04:05'),
    (DATE'2019-03-02', TIMESTAMP '2019-03-02 15:10:05'),
    (DATE'2019-06-28', TIMESTAMP '2019-06-28 17:32:01'),
    (DATE'2019-12-12', TIMESTAMP '2019-12-12 12:12:01')))
select last_day(c_date), last_day(c_timestamp) from data;

EXPR$0, EXPR$1
1965-01-31, 1965-01-31
2019-01-31, 2019-01-31
2019-02-28, 2019-02-28
2019-02-28, 2019-02-28
2019-03-31, 2019-03-31
2019-06-30, 2019-06-30
2019-12-31, 2019-12-31
!ok

# [CALCITE-3142] An NPE when rounding a nullable numeric
SELECT ROUND(CAST((X/Y) AS NUMERIC), 2)
FROM (VALUES (1, 2), (NULLIF(5, 5), NULLIF(5, 5))) A(X, Y);
EXPR$0
0.00
null
!ok

# [CALCITE-3143]Dividing NULLIF clause may cause Division by zero error
SELECT CASE WHEN "Z" < 77 AND "Z" > 0 THEN 99 ELSE 88 END
FROM (
  SELECT SUM("X") / NULLIF(SUM(0),0) AS Z
  FROM (VALUES (1.1, 2.5), (4.51, 32.5)) A(X, Y)
  GROUP BY "Y");
EXPR$0
88
88
!ok

# [CALCITE-3150] NPE in UPPER when repeated and combine with LIKE
SELECT "NAME"
FROM (VALUES ('Bill'), NULLIF('x', 'x'), ('Eric')) A(NAME)
WHERE UPPER("NAME") LIKE 'B%' AND UPPER("NAME") LIKE '%L';
NAME
Bill
!ok

# [CALCITE-3717] Query fails with "division by zero" exception
SELECT
  CASE WHEN A=0 THEN (B+C+D)*1.0
  WHEN B=0 THEN 1.0/A+(C+D)*1.0
  WHEN C=0 THEN 1.0/A+1.0/B+D*1.0
  WHEN D=0 THEN 1.0/A+1.0/B+1.0/C
  ELSE 1.0/A+1.0/B+1.0/C+1.0/D
  END AS V
FROM (VALUES (0, 2, 4, 8),
   (1, 0, 4, 8),
   (1, 2, 0, 8),
   (1, 2, 4, 0),
   (0, 0, 0, 0),
   (1, 2, 4, 8),
   (CAST(null as int), CAST(null as int), CAST(null as int), CAST(null as int))) AS T(A,B,C,D);
V
13.0
9.5
1.75
1.875
null
0
14
!ok

# End misc.iq
