# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Tests planner rules related to aggregates with constants and values
# (AGGREGATE_ANY_PULL_UP_CONSTANTS and AGGREGATE_VALUES rules).
#
# Ensure that tests occur in alphabetical order:
# // lint: sort where '^[#] test'
#

!use scott
!set outputformat mysql

# testAggregateConstantKeyRule -------------------------------------------------
# AGGREGATE_ANY_PULL_UP_CONSTANTS removes constant group keys and adds a
# Project above to restore them.
# [CALCITE-1023]

select count(*) as c
from emp
where deptno = 10
group by deptno, sal;
+---+
| C |
+---+
| 1 |
| 1 |
| 1 |
+---+
(3 rows)

!ok
LogicalProject(C=[$2])
  LogicalAggregate(group=[{0, 1}], C=[COUNT()])
    LogicalProject(DEPTNO=[$7], SAL=[$5])
      LogicalFilter(condition=[=($7, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(C=[$2])
  LogicalProject(DEPTNO=[10], SAL=[$0], C=[$1])
    LogicalAggregate(group=[{0}], C=[COUNT()])
      LogicalProject(SAL=[$5])
        LogicalFilter(condition=[=($7, 10)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_ANY_PULL_UP_CONSTANTS"

# testAggregateConstantKeyRule2 ------------------------------------------------
# AGGREGATE_ANY_PULL_UP_CONSTANTS should not fire when the only group key is a
# constant, because there must be at least one remaining non-constant key.

select count(*) as c
from emp
where deptno = 10
group by deptno;
+---+
| C |
+---+
| 3 |
+---+
(1 row)

!ok
LogicalProject(C=[$1])
  LogicalAggregate(group=[{0}], C=[COUNT()])
    LogicalProject(DEPTNO=[$7])
      LogicalFilter(condition=[=($7, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(C=[$1])
  LogicalAggregate(group=[{0}], C=[COUNT()])
    LogicalProject(DEPTNO=[$7])
      LogicalFilter(condition=[=($7, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_ANY_PULL_UP_CONSTANTS"

# testAggregateConstantKeyRule3 ------------------------------------------------
# AGGREGATE_ANY_PULL_UP_CONSTANTS removes the null key (mgr IS NULL) but keeps
# the non-constant key (job = 'Clerk') which is a literal, not removed because
# it is the only remaining key.

select job
from emp
where mgr is null and job = 'Clerk'
group by mgr, job
having count(*) > 3;
+-----+
| JOB |
+-----+
+-----+
(0 rows)

!ok
LogicalProject(JOB=[$1])
  LogicalFilter(condition=[>($2, 3)])
    LogicalAggregate(group=[{0, 1}], agg#0=[COUNT()])
      LogicalProject(MGR=[$3], JOB=[$2])
        LogicalFilter(condition=[AND(IS NULL($3), =($2, 'Clerk'))])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(JOB=[$1])
  LogicalFilter(condition=[>($2, 3)])
    LogicalProject(MGR=[$0], JOB=['Clerk':VARCHAR(10)], $f2=[$1])
      LogicalAggregate(group=[{0}], agg#0=[COUNT()])
        LogicalProject(MGR=[$3])
          LogicalFilter(condition=[AND(IS NULL($3), =($2, 'Clerk'))])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_ANY_PULL_UP_CONSTANTS"

# testAggregateDynamicFunction -------------------------------------------------
# AGGREGATE_ANY_PULL_UP_CONSTANTS removes the null key (mgr IS NULL) but keeps
# the dynamic function key (hiredate = CURRENT_TIMESTAMP) because
# SqlAbstractTimeFunction is not treated as a constant.

select hiredate
from emp
where mgr is null and hiredate = current_timestamp
group by mgr, hiredate
having count(*) > 3;
+----------+
| HIREDATE |
+----------+
+----------+
(0 rows)

!ok
LogicalProject(HIREDATE=[$1])
  LogicalFilter(condition=[>($2, 3)])
    LogicalAggregate(group=[{0, 1}], agg#0=[COUNT()])
      LogicalProject(MGR=[$3], HIREDATE=[$4])
        LogicalFilter(condition=[AND(IS NULL($3), =($4, CURRENT_TIMESTAMP))])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(HIREDATE=[$1])
  LogicalFilter(condition=[>($2, 3)])
    LogicalProject(MGR=[$0], HIREDATE=[CURRENT_TIMESTAMP], $f2=[$1])
      LogicalAggregate(group=[{0}], agg#0=[COUNT()])
        LogicalProject(MGR=[$3])
          LogicalFilter(condition=[AND(IS NULL($3), =($4, CURRENT_TIMESTAMP))])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_ANY_PULL_UP_CONSTANTS"

# testAggregateProjectPullUpConstants ------------------------------------------
# AGGREGATE_ANY_PULL_UP_CONSTANTS removes the constant group key (empno = 10)
# from the aggregate and adds a Project above to restore it.

select job, empno, sal, sum(sal) as s
from emp where empno = 10
group by job, empno, sal;
+-----+-------+-----+---+
| JOB | EMPNO | SAL | S |
+-----+-------+-----+---+
+-----+-------+-----+---+
(0 rows)

!ok
LogicalAggregate(group=[{0, 1, 2}], S=[SUM($2)])
  LogicalProject(JOB=[$2], EMPNO=[$0], SAL=[$5])
    LogicalFilter(condition=[=($0, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(JOB=[$0], EMPNO=[10], SAL=[$1], S=[$2])
  LogicalAggregate(group=[{0, 1}], S=[SUM($1)])
    LogicalProject(JOB=[$2], SAL=[$5])
      LogicalFilter(condition=[=($0, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_ANY_PULL_UP_CONSTANTS"

# testAggregateProjectPullUpConstants2 -----------------------------------------
# After AGGREGATE_PROJECT_MERGE merges the inner project into the aggregate,
# AGGREGATE_ANY_PULL_UP_CONSTANTS removes the constant ename key (ename = 'John').

select ename, sal
from (select '1', ename, sal from emp where ename = 'John') subq
group by ename, sal;
+-------+-----+
| ENAME | SAL |
+-------+-----+
+-------+-----+
(0 rows)

!ok
LogicalAggregate(group=[{0, 1}])
  LogicalProject(ENAME=[$1], SAL=[$5])
    LogicalFilter(condition=[=($1, 'John')])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{1, 5}])
  LogicalFilter(condition=[=($1, 'John')])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_PROJECT_MERGE"
LogicalProject(ENAME=['John':VARCHAR(20)], SAL=[$0])
  LogicalAggregate(group=[{5}])
    LogicalFilter(condition=[=($1, 'John')])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_PROJECT_MERGE, AGGREGATE_ANY_PULL_UP_CONSTANTS"

# testAggregateValuesRuleWithInRepeatingValues ---------------------------------
# AGGREGATE_VALUES deduplicates Values tuples when a filter IN clause has
# repeating values. FILTER_SUB_QUERY_TO_CORRELATE is applied first to expand
# the IN subquery to a Join over Values.
# [CALCITE-6887]

SELECT deptno, sal
FROM emp
WHERE deptno IN (1,1,3,1,2,1,1,1,1,1,1,1,null,null,1,1,1,1,1,1,1);
+--------+-----+
| DEPTNO | SAL |
+--------+-----+
+--------+-----+
(0 rows)

!ok
LogicalProject(DEPTNO=[$7], SAL=[$5])
  LogicalFilter(condition=[IN($7, {
LogicalValues(tuples=[[{ 1 }, { 1 }, { 3 }, { 1 }, { 2 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { null }, { null }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }]])
})])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$7], SAL=[$5])
  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
    LogicalJoin(condition=[=($7, $9)], joinType=[inner])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalAggregate(group=[{0}])
        LogicalValues(tuples=[[{ 1 }, { 1 }, { 3 }, { 1 }, { 2 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { null }, { null }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }]])
!sub-plan "NONE, FILTER_SUB_QUERY_TO_CORRELATE"
LogicalProject(DEPTNO=[$7], SAL=[$5])
  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
    LogicalJoin(condition=[=($7, $9)], joinType=[inner])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalValues(tuples=[[{ 1 }, { 3 }, { 2 }, { null }]])
!sub-plan "NONE, FILTER_SUB_QUERY_TO_CORRELATE, AGGREGATE_VALUES"

# testEmptyAggregateEmptyKeyWithAggregateValuesRule ----------------------------
# AGGREGATE_VALUES replaces an empty-key Aggregate over empty Values with a
# single-row Values containing identity values (0 for COUNT, null for SUM).
# Note: The Java test uses PruneEmptyRules.PROJECT_INSTANCE as a pre-rule to
# remove the Project between Aggregate and Values. Since that rule is not in
# CoreRules, this .iq file shows the intermediate state: FILTER_REDUCE_EXPRESSIONS
# converts 'WHERE false' to empty Values, but AGGREGATE_VALUES cannot fire
# because a Project remains above the Values.

select count(*), sum(empno) from emp where false;
+--------+--------+
| EXPR$0 | EXPR$1 |
+--------+--------+
|      0 |        |
+--------+--------+
(1 row)

!ok
LogicalAggregate(group=[{}], EXPR$0=[COUNT()], EXPR$1=[SUM($0)])
  LogicalProject(EMPNO=[$0])
    LogicalFilter(condition=[false])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{}], EXPR$0=[COUNT()], EXPR$1=[SUM($0)])
  LogicalProject(EMPNO=[$0])
    LogicalValues(tuples=[[]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"
LogicalAggregate(group=[{}], EXPR$0=[COUNT()], EXPR$1=[SUM($0)])
  LogicalProject(EMPNO=[$0])
    LogicalValues(tuples=[[]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS, AGGREGATE_VALUES"

# testReduceInValuesNonOrdered -------------------------------------------------
# AGGREGATE_VALUES does not fire when the IN list is small enough that the
# query planner does not convert it to a Join over Values (the IN list is
# converted to OR conditions instead).

SELECT deptno, sal
FROM emp
WHERE deptno IN (1,1,3,1,2);
+--------+-----+
| DEPTNO | SAL |
+--------+-----+
+--------+-----+
(0 rows)

!ok
LogicalProject(DEPTNO=[$7], SAL=[$5])
  LogicalFilter(condition=[OR(=($7, 1), =($7, 3), =($7, 2))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$7], SAL=[$5])
  LogicalFilter(condition=[OR(=($7, 1), =($7, 3), =($7, 2))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_SUB_QUERY_TO_CORRELATE"
LogicalProject(DEPTNO=[$7], SAL=[$5])
  LogicalFilter(condition=[OR(=($7, 1), =($7, 3), =($7, 2))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_SUB_QUERY_TO_CORRELATE, AGGREGATE_VALUES"

# End aggregate-constants.iq
