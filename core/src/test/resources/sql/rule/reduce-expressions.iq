# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Tests for rules related to reducing constant expressions
# (FILTER_REDUCE_EXPRESSIONS, PROJECT_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS rules).
#
# Ensure that tests occur in alphabetical order:
# // lint: sort where '^[#] test'
#

!use scott
!set outputformat mysql

# testAlreadyFalseEliminatesFilter -------------------------------------------------------
# Tests that a filter with a false condition is eliminated.

select * from (values (1,2)) where false;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EXPR$0=[$0], EXPR$1=[$1])
  LogicalFilter(condition=[false])
    LogicalValues(tuples=[[{ 1, 2 }]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$0], EXPR$1=[$1])
  LogicalValues(tuples=[[]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testAsofOpt -------------------------------------------------------
# PROJECT_REDUCE_EXPRESSIONS does not modify an ASOF join plan (checkUnchanged).

SELECT *
FROM (VALUES (NULL, 0), (1, NULL), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (2, 3), (3, 4)) AS t1(k, t)
ASOF JOIN (VALUES (1, NULL), (1, 2), (1, 3), (2, 10), (2, 0)) AS t2(k, t)
MATCH_CONDITION t2.t < t1.t
ON t1.k = t2.k;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(K=[$0], T=[$1], K0=[$2], T0=[$3])
  LogicalAsofJoin(condition=[=($0, $2)], joinType=[asof], matchCondition=[<($3, $1)])
    LogicalValues(tuples=[[{ null, 0 }, { 1, null }, { 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 }, { 1, 4 }, { 2, 3 }, { 3, 4 }]])
    LogicalValues(tuples=[[{ 1, null }, { 1, 2 }, { 1, 3 }, { 2, 10 }, { 2, 0 }]])
!sub-plan "NONE"
LogicalProject(K=[$0], T=[$1], K0=[$2], T0=[$3])
  LogicalAsofJoin(condition=[=($0, $2)], joinType=[asof], matchCondition=[<($3, $1)])
    LogicalValues(tuples=[[{ null, 0 }, { 1, null }, { 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 }, { 1, 4 }, { 2, 3 }, { 3, 4 }]])
    LogicalValues(tuples=[[{ 1, null }, { 1, 2 }, { 1, 3 }, { 2, 10 }, { 2, 0 }]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS"

# testCastRemove -------------------------------------------------------
# PROJECT_REDUCE_EXPRESSIONS does not remove a CAST in a complex CASE with
# COALESCE (checkUnchanged).

select
case when cast(ename as double) < 5 then 0.0
     else coalesce(cast(ename as double), 1.0)
     end as t
 from (
       select
          case when ename > 'abc' then ename
               else null
               end as ename from emp
 );
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(T=[CASE(<(CAST(CASE(>($1, 'abc'), $1, null:VARCHAR(20))):DOUBLE, 5.0E0), 0.0E0:DOUBLE, CASE(IS NOT NULL(CAST(CASE(>($1, 'abc'), $1, null:VARCHAR(20))):DOUBLE), CAST(CAST(CASE(>($1, 'abc'), $1, null:VARCHAR(20))):DOUBLE):DOUBLE NOT NULL, 1.0E0:DOUBLE))])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(T=[CASE(<(CAST(CASE(>($1, 'abc'), $1, null:VARCHAR(20))):DOUBLE, 5.0E0), 0.0E0:DOUBLE, CASE(IS NOT NULL(CAST(CASE(>($1, 'abc'), $1, null:VARCHAR(20))):DOUBLE), CAST(CAST(CASE(>($1, 'abc'), $1, null:VARCHAR(20))):DOUBLE):DOUBLE NOT NULL, 1.0E0:DOUBLE))])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS"

# testExpressionPreceding -------------------------------------------------------
# PROJECT_REDUCE_EXPRESSIONS does not modify a plan when applied after a window
# function has already been expanded (checkUnchanged).

select COUNT(*) over (
  ORDER BY empno
  ROWS BETWEEN 5 + 5 PRECEDING AND 1 PRECEDING) AS w_count
from emp;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(W_COUNT=[$1])
  LogicalWindow(window#0=[window(order by [0] rows between $1 PRECEDING and $2 PRECEDING aggs [COUNT()])], constants=[[10, 1]])
    LogicalProject(EMPNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW"
LogicalProject(W_COUNT=[$1])
  LogicalWindow(window#0=[window(order by [0] rows between $1 PRECEDING and $2 PRECEDING aggs [COUNT()])], constants=[[10, 1]])
    LogicalProject(EMPNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW, PROJECT_REDUCE_EXPRESSIONS"

# testExpressionSimplification1 -------------------------------------------------------
# [CALCITE-5169] 'xx < 1 OR xx > 1' cannot be simplified to 'xx <> 1'.
# ename <> '' and ename <> '3' should be simplified to Sarg.

select * from emp
where ename <> '' and ename <> '3';
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[AND(<>($1, ''), <>($1, '3'))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[SEARCH($1, Sarg[(-∞..'':VARCHAR(20)), ('':VARCHAR(20)..'3':VARCHAR(20)), ('3':VARCHAR(20)..+∞)]:VARCHAR(20))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testExpressionSimplification2 -------------------------------------------------------
# [CALCITE-5169] 'xx < 1 OR xx > 1' cannot be simplified to 'xx <> 1'.
# (ename < '' or ename > '') and (ename < '3' or ename > '3') should be simplified to Sarg too.

select * from emp
where (ename < '' or ename > '') and (ename < '3' or ename > '3');
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[AND(OR(<($1, ''), >($1, '')), OR(<($1, '3'), >($1, '3')))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[SEARCH($1, Sarg[(-∞..'':VARCHAR(20)), ('':VARCHAR(20)..'3':VARCHAR(20)), ('3':VARCHAR(20)..+∞)]:VARCHAR(20))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testFilterReduceCrash -------------------------------------------------------
# [CALCITE-7070] FILTER_REDUCE_EXPRESSIONS crashes on expression BETWEEN ( NULL) AND X.

SELECT + 54 FROM emp WHERE NOT CAST ( CAST(empno AS DOUBLE) AS INTEGER ) NOT BETWEEN ( NULL ) AND 89;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EXPR$0=[54])
  LogicalFilter(condition=[NOT(NOT(AND(>=(CAST(CAST($0):DOUBLE NOT NULL):INTEGER NOT NULL, null), <=(CAST(CAST($0):DOUBLE NOT NULL):INTEGER NOT NULL, 89))))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[54])
  LogicalValues(tuples=[[]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testNoOversimplificationBelowIsNull -------------------------------------------------------
# [CALCITE-2726] FILTER_REDUCE_EXPRESSIONS should not oversimplify conditions
# below IS NULL.

select *
from emp
where ( (empno=1 and mgr=1) or (empno=null and mgr=1) ) is null;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[IS NULL(OR(AND(=($0, 1), =($3, 1)), AND(=($0, null), =($3, 1))))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[IS NULL(OR(AND(=($0, 1), =($3, 1)), AND(null, =($3, 1))))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testOrAlwaysTrue -------------------------------------------------------
# Tests that "sal is null or sal is not null" is always true and the filter is removed.

select * from EMPNULLABLES_20
where sal is null or sal is not null;
# Not using !ok: query uses EMPNULLABLES, which is not in the scott database.

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], SLACKER=[$7])
  LogicalFilter(condition=[OR(IS NULL($5), IS NOT NULL($5))])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], SLACKER=[$8])
      LogicalFilter(condition=[AND(=($7, 20), >($5, 1000))])
        LogicalTableScan(table=[[CATALOG, SALES, EMPNULLABLES]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], SLACKER=[$7])
  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], SLACKER=[$8])
    LogicalFilter(condition=[AND(=($7, 20), >($5, 1000))])
      LogicalTableScan(table=[[CATALOG, SALES, EMPNULLABLES]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testOrAlwaysTrue2 -------------------------------------------------------
# Tests that "sal is not null or sal is null" is always true and the filter is removed.

select * from EMPNULLABLES_20
where sal is not null or sal is null;
# Not using !ok: query uses EMPNULLABLES, which is not in the scott database.

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], SLACKER=[$7])
  LogicalFilter(condition=[OR(IS NOT NULL($5), IS NULL($5))])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], SLACKER=[$8])
      LogicalFilter(condition=[AND(=($7, 20), >($5, 1000))])
        LogicalTableScan(table=[[CATALOG, SALES, EMPNULLABLES]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], SLACKER=[$7])
  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], SLACKER=[$8])
    LogicalFilter(condition=[AND(=($7, 20), >($5, 1000))])
      LogicalTableScan(table=[[CATALOG, SALES, EMPNULLABLES]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testOversimplifiedCaseStatement -------------------------------------------------------
# [CALCITE-2726] FILTER_REDUCE_EXPRESSIONS should not oversimplify CASE in a
# compound WHERE condition.

select * from emp where MGR > 0 and case when MGR > 0 then deptno / MGR else null end > 1;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[AND(>($3, 0), >(CASE(>($3, 0), /($7, $3), null:INTEGER), 1))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[AND(>($3, 0), CASE(>($3, 0), >(/($7, $3), 1), false))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testPredicatePull -------------------------------------------------------
# PROJECT_REDUCE_EXPRESSIONS pulls constants from filter predicates into a
# rollup aggregate's project.

select deptno, sal from emp where deptno = 10 group by rollup(sal, deptno);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(DEPTNO=[$1], SAL=[$0])
  LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {}]])
    LogicalProject(SAL=[$5], DEPTNO=[$7])
      LogicalFilter(condition=[=($7, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$1], SAL=[$0])
  LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {}]])
    LogicalProject(SAL=[$5], DEPTNO=[10])
      LogicalFilter(condition=[=($7, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS"

# testPullNull -------------------------------------------------------
# Tests that constant values are pulled into the project when they are known from the filter.

select *
from emp
where deptno=7
and empno = 10 and mgr is null and empno = 10;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[AND(=($7, 7), =($0, 10), IS NULL($3))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[10], ENAME=[$1], JOB=[$2], MGR=[null:INTEGER], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[7], SLACKER=[$8])
  LogicalFilter(condition=[AND(=($7, 7), =($0, 10), IS NULL($3))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testPullUpPredicatesFromProject1 -------------------------------------------------------
# PROJECT_REDUCE_EXPRESSIONS reduces expressions in a project using constants
# inferred from the filter (comm <> 2 becomes false, comm = 2 becomes true).

select comm <> 2, comm = 2 from emp where comm = 2;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EXPR$0=[<>($6, 2)], EXPR$1=[=($6, 2)])
  LogicalFilter(condition=[=($6, 2)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[false], EXPR$1=[true])
  LogicalFilter(condition=[=($6, 2)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, PROJECT_REDUCE_EXPRESSIONS"

# testRand -------------------------------------------------------
# PROJECT_REDUCE_EXPRESSIONS reduces ROUND(RAND()) but preserves it when used
# in a filter with BETWEEN/IN conditions.

SELECT * FROM (SELECT 1, ROUND(RAND()) AS A)
WHERE A BETWEEN 1 AND 10 OR A IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EXPR$0=[$0], A=[$1])
  LogicalFilter(condition=[OR(AND(>=($1, CAST(1):DOUBLE NOT NULL), <=($1, CAST(10):DOUBLE NOT NULL)), =($1, CAST(1):DOUBLE NOT NULL), =($1, CAST(2):DOUBLE NOT NULL), =($1, CAST(3):DOUBLE NOT NULL), =($1, CAST(4):DOUBLE NOT NULL), =($1, CAST(5):DOUBLE NOT NULL), =($1, CAST(6):DOUBLE NOT NULL), =($1, CAST(7):DOUBLE NOT NULL), =($1, CAST(8):DOUBLE NOT NULL), =($1, CAST(9):DOUBLE NOT NULL), =($1, CAST(10):DOUBLE NOT NULL))])
    LogicalProject(EXPR$0=[1], A=[ROUND(RAND())])
      LogicalValues(tuples=[[{ 0 }]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[1], A=[$1])
  LogicalFilter(condition=[OR(AND(>=($1, CAST(1):DOUBLE NOT NULL), <=($1, CAST(10):DOUBLE NOT NULL)), =($1, CAST(1):DOUBLE NOT NULL), =($1, CAST(2):DOUBLE NOT NULL), =($1, CAST(3):DOUBLE NOT NULL), =($1, CAST(4):DOUBLE NOT NULL), =($1, CAST(5):DOUBLE NOT NULL), =($1, CAST(6):DOUBLE NOT NULL), =($1, CAST(7):DOUBLE NOT NULL), =($1, CAST(8):DOUBLE NOT NULL), =($1, CAST(9):DOUBLE NOT NULL), =($1, CAST(10):DOUBLE NOT NULL))])
    LogicalProject(EXPR$0=[1], A=[ROUND(RAND())])
      LogicalValues(tuples=[[{ 0 }]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS"

# testReduceCase -------------------------------------------------------
# PROJECT_REDUCE_EXPRESSIONS reduces a CASE expression with a false condition
# to the else branch, unifying numeric types.

select
  case when false then cast(2.1 as float)
   else cast(1 as integer) end as newcol
from emp;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(NEWCOL=[CASE(false, CAST(2.1:DECIMAL(2, 1)):FLOAT NOT NULL, CAST(1):FLOAT NOT NULL)])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "relBuilderSimplify=false, NONE"
LogicalProject(NEWCOL=[1.0E0:FLOAT])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "relBuilderSimplify=false, NONE, PROJECT_REDUCE_EXPRESSIONS"

# testReduceCaseNullabilityChange -------------------------------------------------------
# PROJECT_REDUCE_EXPRESSIONS reduces a CASE expression that has a constant
# condition (1 IS NOT NULL is always true), changing nullability.

select case when empno = 1 then 1
when 1 IS NOT NULL then 2
else null end as qx from emp;
# Not using !ok: query uses the sales schema, which is not in the scott database.

LogicalProject(QX=[CASE(=($0, 1), 1, IS NOT NULL(1), 2, null:INTEGER)])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "relBuilderSimplify=false, NONE"
LogicalProject(QX=[CAST(CASE(=($0, 1), 1, 2)):INTEGER])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "relBuilderSimplify=false, NONE, FILTER_REDUCE_EXPRESSIONS, PROJECT_REDUCE_EXPRESSIONS"

# testReduceCastAndConsts -------------------------------------------------------
# Tests that constant expressions inside a cast can be reduced.

select * from emp
where cast((empno + (10/2)) as int) = 13;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[=(CAST(+($0, /(10, 2))):INTEGER NOT NULL, 13)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[=(+($0, 5), 13)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceCasts -------------------------------------------------------
# PROJECT_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS, and FILTER_REDUCE_EXPRESSIONS
# remove redundant casts (e.g., CAST(integer AS integer) becomes the column itself).

select cast(d.dname as varchar(128)), cast(e.empno as integer)
from dept as d inner join emp as e
on cast(d.deptno as integer) = cast(e.deptno as integer)
where cast(e.job as varchar(1)) = 'Manager';
# Not using !ok: query uses the sales schema, which is not in the scott database.

LogicalProject(EXPR$0=[CAST($1):VARCHAR(128) NOT NULL], EXPR$1=[CAST($2):INTEGER NOT NULL])
  LogicalFilter(condition=[=(CAST(CAST($4):VARCHAR(1) NOT NULL):VARCHAR(7) NOT NULL, 'Manager')])
    LogicalProject(DEPTNO=[$0], DNAME=[$1], EMPNO=[$3], ENAME=[$4], JOB=[$5], MGR=[$6], HIREDATE=[$7], SAL=[$8], COMM=[$9], DEPTNO1=[$10], SLACKER=[$11])
      LogicalJoin(condition=[=($2, $12)], joinType=[inner])
        LogicalProject(DEPTNO=[$0], DNAME=[$1], DEPTNO0=[CAST($0):INTEGER NOT NULL])
          LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
        LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[CAST($7):INTEGER NOT NULL])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "relBuilderSimplify=false, NONE"
LogicalProject(EXPR$0=[CAST($1):VARCHAR(128) NOT NULL], EXPR$1=[$2])
  LogicalFilter(condition=[=(CAST(CAST($4):VARCHAR(1) NOT NULL):VARCHAR(7) NOT NULL, 'Manager')])
    LogicalProject(DEPTNO=[$0], DNAME=[$1], EMPNO=[$3], ENAME=[$4], JOB=[$5], MGR=[$6], HIREDATE=[$7], SAL=[$8], COMM=[$9], DEPTNO1=[$10], SLACKER=[$11])
      LogicalJoin(condition=[=($2, $12)], joinType=[inner])
        LogicalProject(DEPTNO=[$0], DNAME=[$1], DEPTNO0=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
        LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$7])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "relBuilderSimplify=false, NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testReduceCastTimeUnchanged -------------------------------------------------------
# Tests that a cast from a TIME to a TIMESTAMP is not reduced (depends on current date).

select cast(time '12:34:56' as timestamp) from emp as e;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EXPR$0=[CAST(12:34:56):TIMESTAMP(0) NOT NULL])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[CAST(12:34:56):TIMESTAMP(0) NOT NULL])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testReduceCompositeInSubQuery -------------------------------------------------------
# [CALCITE-6887] FILTER_REDUCE_EXPRESSIONS reduces a constant expression in an
# OR condition that contains a composite IN subquery.

select *
from emp
where (empno, deptno) in (
  select empno, deptno from (
    select empno, deptno
    from emp
    group by empno, deptno))
or deptno < 40 + 60;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[OR(IN($0, $7, {
LogicalProject(EMPNO=[$0], DEPTNO=[$1])
  LogicalAggregate(group=[{0, 1}])
    LogicalProject(EMPNO=[$0], DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
}), <($7, +(40, 60)))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "aggregateUnique=true, NONE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[OR(IN($0, $7, {
LogicalProject(EMPNO=[$0], DEPTNO=[$1])
  LogicalAggregate(group=[{0, 1}])
    LogicalProject(EMPNO=[$0], DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
}), <($7, 100))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "aggregateUnique=true, NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstants2 -------------------------------------------------------
# PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, and
# JOIN_REDUCE_EXPRESSIONS do not change the plan when simplifyValues is false
# (checkUnchanged).

select p1 is not distinct from p0
from (values (2, cast(null as integer))) as t(p0, p1);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EXPR$0=[false])
  LogicalValues(tuples=[[{ 0 }]])
!sub-plan "simplifyValues=false, NONE"
LogicalProject(EXPR$0=[false])
  LogicalValues(tuples=[[{ 0 }]])
!sub-plan "simplifyValues=false, NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testReduceConstants3 -------------------------------------------------------
# Tests reduction of IS NOT DISTINCT FROM when mgr is known null.

select e.mgr is not distinct from f.mgr from emp e join emp f on (e.mgr=f.mgr) where e.mgr is null;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EXPR$0=[OR(AND(IS NULL($3), IS NULL($12)), IS TRUE(=($3, $12)))])
  LogicalFilter(condition=[IS NULL($3)])
    LogicalJoin(condition=[=($3, $12)], joinType=[inner])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[IS NULL($12)])
  LogicalFilter(condition=[IS NULL($3)])
    LogicalJoin(condition=[=($3, $12)], joinType=[inner])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testReduceConstantsCaseEquals -------------------------------------------------------
# [HIVE-9644] Reduces a CASE expression to a simpler condition.
# Equivalent to 'deptno = 10'.

select count(1) from emp
where case deptno
  when 20 then 2
  when 10 then 1
  else 3 end = 1;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[1])
    LogicalFilter(condition=[=(CASE(=($7, 20), 2, =($7, 10), 1, 3), 1)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[1])
    LogicalFilter(condition=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testReduceConstantsCaseEquals2 -------------------------------------------------------
# Reduces a CASE expression with null else branch.
# Equivalent to 'case when deptno = 20 then false when deptno = 10 then true else null end'.

select count(1) from emp
where case deptno
  when 20 then 2
  when 10 then 1
  else cast(null as integer) end = 1;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[1])
    LogicalFilter(condition=[=(CASE(=($7, 20), 2, =($7, 10), 1, null:INTEGER), 1)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[1])
    LogicalFilter(condition=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testReduceConstantsCaseEquals3 -------------------------------------------------------
# Reduces a CASE expression with duplicate WHEN branches.
# Equivalent to 'deptno = 30 or deptno = 10'.

select count(1) from emp
where case deptno
  when 30 then 1
  when 20 then 2
  when 10 then 1
  when 30 then 111
  else 0 end = 1;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[1])
    LogicalFilter(condition=[=(CASE(=($7, 30), 1, =($7, 20), 2, =($7, 10), 1, =($7, 30), 111, 0), 1)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[1])
    LogicalFilter(condition=[SEARCH($7, Sarg[10, 30])])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testReduceConstantsDup -------------------------------------------------------
# [CALCITE-570] ReduceExpressionsRule throws "duplicate key" exception.

select d.deptno from dept d where d.deptno=7 and d.deptno=8;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(DEPTNO=[$0])
  LogicalFilter(condition=[AND(=($0, 7), =($0, 8))])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$0])
  LogicalValues(tuples=[[]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsDup2 -------------------------------------------------------
# [CALCITE-935] Improve how ReduceExpressionsRule handles duplicate constraints.

select *
from emp
where deptno=7 and deptno=8
and empno = 10 and mgr is null and empno = 10;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalFilter(condition=[AND(=($7, 7), =($7, 8), =($0, 10), IS NULL($3))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[10], ENAME=[$1], JOB=[$2], MGR=[null:INTEGER], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
  LogicalValues(tuples=[[]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsDup3 -------------------------------------------------------
# [CALCITE-3198] Enhance RexSimplify to handle (x<>a or x<>b).

select d.deptno from dept d where d.deptno<>7 or d.deptno<>8;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(DEPTNO=[$0])
  LogicalFilter(condition=[OR(<>($0, 7), <>($0, 8))])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$0])
  LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsDup3Null -------------------------------------------------------
# [CALCITE-3198] Enhance RexSimplify to handle (x<>a or x<>b), with nullable column.

select e.empno from emp e where e.mgr<>7 or e.mgr<>8;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[OR(<>($3, 7), <>($3, 8))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[IS NOT NULL($3)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsDupNot -------------------------------------------------------
# [CALCITE-3198] Enhance RexSimplify to handle (x<>a or x<>b), with NOT.

select d.deptno from dept d where not(d.deptno=7 and d.deptno=8);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(DEPTNO=[$0])
  LogicalFilter(condition=[NOT(AND(=($0, 7), =($0, 8)))])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$0])
  LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsDupNot2 -------------------------------------------------------
# [CALCITE-3198] Enhance RexSimplify to handle (x<>a or x<>b), NOT with three predicates.

select d.deptno from dept d where not(d.deptno=7 and d.dname='foo' and d.deptno=8);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(DEPTNO=[$0])
  LogicalFilter(condition=[NOT(AND(=($0, 7), =($1, 'foo'), =($0, 8)))])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$0])
  LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsDupNot2Null -------------------------------------------------------
# [CALCITE-3198] Enhance RexSimplify to handle (x<>a or x<>b), NOT with nullable column.

select e.empno from emp e where not(e.mgr=7 and e.deptno=8 and e.mgr=8);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[NOT(AND(=($3, 7), =($7, 8), =($3, 8)))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[OR(IS NOT NULL($3), <>($7, 8))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsDupNotNull -------------------------------------------------------
# [CALCITE-3198] Enhance RexSimplify to handle (x<>a or x<>b), NOT with single nullable column.

select e.empno from emp e where not(e.mgr=7 and e.mgr=8);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[NOT(AND(=($3, 7), =($3, 8)))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[IS NOT NULL($3)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsDynamicFunction -------------------------------------------------------
# Tests that a dynamic function (CURRENT_TIMESTAMP) is not reduced.

select sal, t
from (select sal, current_timestamp t from emp)
where t > TIMESTAMP '2018-01-01 00:00:00';
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(SAL=[$0], T=[$1])
  LogicalFilter(condition=[>($1, 2018-01-01 00:00:00)])
    LogicalProject(SAL=[$5], T=[CURRENT_TIMESTAMP])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(SAL=[$0], T=[$1])
  LogicalFilter(condition=[>($1, 2018-01-01 00:00:00)])
    LogicalProject(SAL=[$5], T=[CURRENT_TIMESTAMP])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS, PROJECT_REDUCE_EXPRESSIONS"

# testReduceConstantsEliminatesFilter -------------------------------------------------------
# Tests that a filter with WHERE NULL (same as WHERE FALSE) produces an empty result.

select * from (values (1,2)) where 1 + 2 > 3 + CAST(NULL AS INTEGER);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EXPR$0=[$0], EXPR$1=[$1])
  LogicalFilter(condition=[>(+(1, 2), +(3, null))])
    LogicalValues(tuples=[[{ 1, 2 }]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$0], EXPR$1=[$1])
  LogicalValues(tuples=[[]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsIsNotNull -------------------------------------------------------
# Tests that "empno=10 and empno is not null" is unchanged (redundant IS NOT NULL).

select empno from emp
where empno=10 and empno is not null;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[=($0, 10)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[=($0, 10)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsIsNull -------------------------------------------------------
# Tests that "empno=10 and empno is null" reduces to an empty result.

select empno from emp where empno=10 and empno is null;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[false])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0])
  LogicalValues(tuples=[[]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsNegated -------------------------------------------------------
# Tests that "empno=10 and not(empno=10)" reduces to an empty result.

select empno from emp
where empno=10 and not(empno=10);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[AND(=($0, 10), NOT(=($0, 10)))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0])
  LogicalValues(tuples=[[]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsNegatedInverted -------------------------------------------------------
# Tests that "empno>10 and empno<=10" reduces to an empty result.

select empno from emp where empno>10 and empno<=10;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EMPNO=[$0])
  LogicalFilter(condition=[AND(>($0, 10), <=($0, 10))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EMPNO=[$0])
  LogicalValues(tuples=[[]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsNull -------------------------------------------------------
# [CALCITE-1860] Duplicate null predicates cause NullPointerException in RexUtil.

select * from (
  select *
  from (
    select cast(null as integer) as n
    from emp)
  where n is null and n is null)
where n is null;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(N=[$0])
  LogicalFilter(condition=[IS NULL($0)])
    LogicalProject(N=[$0])
      LogicalFilter(condition=[IS NULL($0)])
        LogicalProject(N=[null:INTEGER])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(N=[$0])
  LogicalProject(N=[$0])
    LogicalProject(N=[null:INTEGER])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# testReduceConstantsNullEqualsOne -------------------------------------------------------
# [HIVE-9645] Tests that cast(null as integer) = 1 reduces to empty result.

select count(1) from emp where cast(null as integer) = 1;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[1])
    LogicalFilter(condition=[false])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[1])
    LogicalValues(tuples=[[]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testReduceConstantsProjectNullable -------------------------------------------------------
# [CALCITE-902] Match nullability when reducing expressions in a Project.

select mgr from emp where mgr=10;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(MGR=[$3])
  LogicalFilter(condition=[=($3, 10)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(MGR=[CAST(10):INTEGER])
  LogicalFilter(condition=[=($3, 10)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS, FILTER_REDUCE_EXPRESSIONS, JOIN_REDUCE_EXPRESSIONS"

# testReduceConstantsWithRow -------------------------------------------------------
# [CALCITE-7140] Improve constant reduction of expressions containing SqlRowOperator.

SELECT 1+1, ARRAY[1+1, 2+2], ROW('a', 3+3), MAP['a'||'b', 6+6],
ROW(1+2, ARRAY[1+2, 2+3], ROW('a', 3+4), MAP['ab'||'cd', 6+7]),
ARRAY[2*3, 2, 1],
ARRAY[ROW(4*2, 'a'), ROW(4+4, 'b')],
ARRAY[MAP['abc'||'def', 8+8], MAP['ghi'||'jkl', 9+9]],
ARRAY[ROW(1+2, ARRAY[1+1, 2+2], ROW('a', 3+3), MAP['x'||'y', 8+8])],
CARDINALITY(ARRAY[2*3, 2*2, 1*4]),
CARDINALITY(ARRAY[ROW(4*3, 'm'), ROW(4+6, 'b')]),
CARDINALITY(ARRAY[MAP['ac'||'bd', 1+8], MAP['gi'||'jl', 1+9]]),
CARDINALITY(ARRAY[ROW(1+7, ARRAY[1+4, 4+2], ROW('t', 5+5), MAP['y'||'z', 9+9])]);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(EXPR$0=[+(1, 1)], EXPR$1=[ARRAY(+(1, 1), +(2, 2))], EXPR$2=[ROW('a', +(3, 3))], EXPR$3=[MAP(||('a', 'b'), +(6, 6))], EXPR$4=[ROW(+(1, 2), ARRAY(+(1, 2), +(2, 3)), ROW('a', +(3, 4)), MAP(||('ab', 'cd'), +(6, 7)))], EXPR$5=[ARRAY(*(2, 3), 2, 1)], EXPR$6=[ARRAY(ROW(*(4, 2), 'a'), ROW(+(4, 4), 'b'))], EXPR$7=[ARRAY(MAP(||('abc', 'def'), +(8, 8)), MAP(||('ghi', 'jkl'), +(9, 9)))], EXPR$8=[ARRAY(ROW(+(1, 2), ARRAY(+(1, 1), +(2, 2)), ROW('a', +(3, 3)), MAP(||('x', 'y'), +(8, 8))))], EXPR$9=[CARDINALITY(ARRAY(*(2, 3), *(2, 2), 4))], EXPR$10=[CARDINALITY(ARRAY(ROW(*(4, 3), 'm'), ROW(+(4, 6), 'b')))], EXPR$11=[CARDINALITY(ARRAY(MAP(||('ac', 'bd'), +(1, 8)), MAP(||('gi', 'jl'), +(1, 9))))], EXPR$12=[CARDINALITY(ARRAY(ROW(+(1, 7), ARRAY(+(1, 4), +(4, 2)), ROW('t', +(5, 5)), MAP(||('y', 'z'), +(9, 9)))))])
  LogicalValues(tuples=[[{ 0 }]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[2], EXPR$1=[ARRAY(2, 4)], EXPR$2=[ROW('a', 6)], EXPR$3=[MAP('ab', 12)], EXPR$4=[ROW(3, ARRAY(3, 5), ROW('a', 7), MAP('abcd', 13))], EXPR$5=[ARRAY(6, 2, 1)], EXPR$6=[ARRAY(ROW(8, 'a'), ROW(8, 'b'))], EXPR$7=[ARRAY(MAP('abcdef', 16), MAP('ghijkl', 18))], EXPR$8=[ARRAY(ROW(3, ARRAY(2, 4), ROW('a', 6), MAP('xy', 16)))], EXPR$9=[3], EXPR$10=[2], EXPR$11=[2], EXPR$12=[1])
  LogicalValues(tuples=[[{ 0 }]])
!sub-plan "NONE, PROJECT_REDUCE_EXPRESSIONS"

# testReduceExpressionsNot -------------------------------------------------------
# FILTER_REDUCE_EXPRESSIONS does not reduce NOT(col1) when col1 is a boolean
# from a VALUES clause (checkUnchanged).

select * from (values (false),(true)) as q (col1) where not(col1);
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalProject(COL1=[$0])
  LogicalFilter(condition=[NOT($0)])
    LogicalValues(tuples=[[{ false }, { true }]])
!sub-plan "NONE"
LogicalProject(COL1=[$0])
  LogicalFilter(condition=[NOT($0)])
    LogicalValues(tuples=[[{ false }, { true }]])
!sub-plan "NONE, FILTER_REDUCE_EXPRESSIONS"

# End reduce-expressions.iq
