# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Tests planner rules related to set operations (INTERSECT, MINUS, UNION).
#
# Ensure that tests occur in alphabetical order:
# // lint: sort where '^[#] test'
#

!use scott
!set outputformat mysql

# testAggregateUnionTransposeWithAllInputsUnique --------------------------------
# AGGREGATE_UNION_TRANSPOSE is a no-op if all inputs to UNION are already unique.

select deptno, SUM(t) from (
select distinct deptno, 1 as t from emp e1
union all
select distinct deptno, 2 as t from emp e2)
group by deptno;
+--------+--------+
| DEPTNO | EXPR$1 |
+--------+--------+
|     10 |      3 |
|     20 |      3 |
|     30 |      3 |
+--------+--------+
(3 rows)

!ok
LogicalAggregate(group=[{0}], EXPR$1=[SUM($1)])
  LogicalUnion(all=[true])
    LogicalAggregate(group=[{0, 1}])
      LogicalProject(DEPTNO=[$7], T=[1])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalAggregate(group=[{0, 1}])
      LogicalProject(DEPTNO=[$7], T=[2])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{0}], EXPR$1=[SUM($1)])
  LogicalUnion(all=[true])
    LogicalAggregate(group=[{0, 1}])
      LogicalProject(DEPTNO=[$7], T=[1])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalAggregate(group=[{0, 1}])
      LogicalProject(DEPTNO=[$7], T=[2])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_UNION_TRANSPOSE"

# testAggregateUnionTransposeWithOneInputNonNullable ---------------------------
# AGGREGATE_UNION_TRANSPOSE pushes aggregate below UNION when one input has a non-nullable column.
# [CALCITE-6642]

select deptno, SUM(t) from (
select deptno, 1 as t from emp e1
union all
select deptno, nullif(sal, 0) as t from emp e2)
group by deptno;
+--------+----------+
| DEPTNO | EXPR$1   |
+--------+----------+
|     10 |  8753.00 |
|     20 | 10880.00 |
|     30 |  9406.00 |
+--------+----------+
(3 rows)

!ok
LogicalAggregate(group=[{0}], EXPR$1=[SUM($1)])
  LogicalUnion(all=[true])
    LogicalProject(DEPTNO=[$7], T=[1])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(DEPTNO=[$7], T=[CASE(=($5, 0), null:INTEGER, $5)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{0}], EXPR$1=[SUM($1)])
  LogicalUnion(all=[true])
    LogicalAggregate(group=[{0}], EXPR$1=[SUM($1)])
      LogicalProject(DEPTNO=[$7], T=[1])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalAggregate(group=[{0}], EXPR$1=[SUM($1)])
      LogicalProject(DEPTNO=[$7], T=[CASE(=($5, 0), null:INTEGER, $5)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_UNION_TRANSPOSE"

# testAggregateUnionTransposeWithOneInputUnique --------------------------------
# AGGREGATE_UNION_TRANSPOSE pushes aggregate below UNION when one input is unique.
# [CALCITE-4616]

select deptno, SUM(t) from (
select deptno, 1 as t from emp e1
union all
select distinct deptno, 2 as t from emp e2)
group by deptno;
+--------+--------+
| DEPTNO | EXPR$1 |
+--------+--------+
|     10 |      5 |
|     20 |      7 |
|     30 |      8 |
+--------+--------+
(3 rows)

!ok
LogicalAggregate(group=[{0}], EXPR$1=[SUM($1)])
  LogicalUnion(all=[true])
    LogicalProject(DEPTNO=[$7], T=[1])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalAggregate(group=[{0, 1}])
      LogicalProject(DEPTNO=[$7], T=[2])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{0}], EXPR$1=[SUM($1)])
  LogicalUnion(all=[true])
    LogicalAggregate(group=[{0}], EXPR$1=[SUM($1)])
      LogicalProject(DEPTNO=[$7], T=[1])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalAggregate(group=[{0}], EXPR$1=[SUM($1)])
      LogicalAggregate(group=[{0, 1}])
        LogicalProject(DEPTNO=[$7], T=[2])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_UNION_TRANSPOSE"

# testAggregateUnionTransposeWithTopLevelGroupSetRemapping ---------------------
# AGGREGATE_UNION_TRANSPOSE pushes aggregate below UNION when top-level group set is remapped.

select count(t1), t2 from (
select (case when deptno=0 then 1 else null end) as t1, 1 as t2 from emp e1
union all
select (case when deptno=0 then 1 else null end) as t1, 2 as t2 from emp e2)
group by t2;
+--------+----+
| EXPR$0 | T2 |
+--------+----+
|      0 |  1 |
|      0 |  2 |
+--------+----+
(2 rows)

!ok
LogicalProject(EXPR$0=[$1], T2=[$0])
  LogicalAggregate(group=[{1}], EXPR$0=[COUNT($0)])
    LogicalUnion(all=[true])
      LogicalProject(T1=[CASE(=($7, 0), 1, null:INTEGER)], T2=[1])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(T1=[CASE(=($7, 0), 1, null:INTEGER)], T2=[2])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_PROJECT_MERGE"
LogicalProject(EXPR$0=[$1], T2=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[$SUM0($1)])
    LogicalUnion(all=[true])
      LogicalAggregate(group=[{1}], EXPR$0=[COUNT($0)])
        LogicalProject(T1=[CASE(=($7, 0), 1, null:INTEGER)], T2=[1])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalAggregate(group=[{1}], EXPR$0=[COUNT($0)])
        LogicalProject(T1=[CASE(=($7, 0), 1, null:INTEGER)], T2=[2])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, AGGREGATE_PROJECT_MERGE, AGGREGATE_UNION_TRANSPOSE"

# testIntersectToExistsRuleMultiFields -----------------------------------------
# INTERSECT_TO_EXISTS rewrites INTERSECT to a correlated EXISTS with multiple fields.
# [CALCITE-6836]

SELECT a.ename, a.job FROM emp AS a
INTERSECT
SELECT b.ename, b.job FROM emp AS b;
+--------+-----------+
| ENAME  | JOB       |
+--------+-----------+
| ADAMS  | CLERK     |
| ALLEN  | SALESMAN  |
| BLAKE  | MANAGER   |
| CLARK  | MANAGER   |
| FORD   | ANALYST   |
| JAMES  | CLERK     |
| JONES  | MANAGER   |
| KING   | PRESIDENT |
| MARTIN | SALESMAN  |
| MILLER | CLERK     |
| SCOTT  | ANALYST   |
| SMITH  | CLERK     |
| TURNER | SALESMAN  |
| WARD   | SALESMAN  |
+--------+-----------+
(14 rows)

!ok
LogicalIntersect(all=[false])
  LogicalProject(ENAME=[$1], JOB=[$2])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(ENAME=[$1], JOB=[$2])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{0, 1}])
  LogicalFilter(condition=[EXISTS({
LogicalFilter(condition=[AND(=($cor0.ENAME, $0), =($cor0.JOB, $1))])
  LogicalProject(ENAME=[$1], JOB=[$2])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
})], variablesSet=[[$cor0]])
    LogicalProject(ENAME=[$1], JOB=[$2])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, INTERSECT_TO_EXISTS"

# testIntersectToExistsRuleMultiIntersect --------------------------------------
# INTERSECT_TO_EXISTS rewrites nested INTERSECT to correlated EXISTS subqueries.
# [CALCITE-6836]

SELECT a.ename FROM emp AS a
INTERSECT
SELECT b.dname FROM dept AS b
INTERSECT
SELECT c.ename FROM emp AS c;
+-------+
| ENAME |
+-------+
+-------+
(0 rows)

!ok
LogicalIntersect(all=[false])
  LogicalIntersect(all=[false])
    LogicalProject(ENAME=[$1])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(DNAME=[CAST($1):VARCHAR(20) NOT NULL])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
  LogicalProject(ENAME=[$1])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalFilter(condition=[EXISTS({
LogicalFilter(condition=[=($cor0.ENAME, $0)])
  LogicalProject(ENAME=[$1])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
})], variablesSet=[[$cor0]])
  LogicalAggregate(group=[{0}])
    LogicalFilter(condition=[EXISTS({
LogicalFilter(condition=[=($cor1.ENAME, $0)])
  LogicalProject(DNAME=[CAST($1):VARCHAR(20) NOT NULL])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
})], variablesSet=[[$cor1]])
      LogicalProject(ENAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, INTERSECT_TO_EXISTS"

# testIntersectToExistsRuleOneField --------------------------------------------
# INTERSECT_TO_EXISTS rewrites INTERSECT to a correlated EXISTS with one field.
# [CALCITE-6836]

SELECT a.ename FROM emp AS a
INTERSECT
SELECT b.dname FROM dept AS b;
+-------+
| ENAME |
+-------+
+-------+
(0 rows)

!ok
LogicalIntersect(all=[false])
  LogicalProject(ENAME=[$1])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(DNAME=[CAST($1):VARCHAR(20) NOT NULL])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalAggregate(group=[{0}])
  LogicalFilter(condition=[EXISTS({
LogicalFilter(condition=[=($cor0.ENAME, $0)])
  LogicalProject(DNAME=[CAST($1):VARCHAR(20) NOT NULL])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
})], variablesSet=[[$cor0]])
    LogicalProject(ENAME=[$1])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, INTERSECT_TO_EXISTS"

# testIntersectToExistsRulePrimaryKey ------------------------------------------
# INTERSECT_TO_EXISTS on a primary-key column skips the outer Aggregate.
# [CALCITE-6836]

SELECT a.empno FROM emp AS a
INTERSECT
SELECT b.empno FROM emp AS b;
+-------+
| EMPNO |
+-------+
|  7369 |
|  7499 |
|  7521 |
|  7566 |
|  7654 |
|  7698 |
|  7782 |
|  7788 |
|  7839 |
|  7844 |
|  7876 |
|  7900 |
|  7902 |
|  7934 |
+-------+
(14 rows)

!ok
LogicalIntersect(all=[false])
  LogicalProject(EMPNO=[$0])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(EMPNO=[$0])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalFilter(condition=[EXISTS({
LogicalFilter(condition=[=($cor0.EMPNO, $0)])
  LogicalProject(EMPNO=[$0])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
})], variablesSet=[[$cor0]])
  LogicalProject(EMPNO=[$0])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, INTERSECT_TO_EXISTS"

# testIntersectToExistsRuleWithAll ---------------------------------------------
# INTERSECT_TO_EXISTS does not rewrite INTERSECT ALL (only INTERSECT DISTINCT).
# [CALCITE-6836]

SELECT a.ename FROM emp AS a
INTERSECT ALL
SELECT b.dname FROM dept AS b;
+-------+
| ENAME |
+-------+
+-------+
(0 rows)

!ok
LogicalIntersect(all=[true])
  LogicalProject(ENAME=[$1])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(DNAME=[CAST($1):VARCHAR(20) NOT NULL])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalIntersect(all=[true])
  LogicalProject(ENAME=[$1])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(DNAME=[CAST($1):VARCHAR(20) NOT NULL])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, INTERSECT_TO_EXISTS"

# testIntersectToFilterRuleNWayWithMultiSources --------------------------------
# INTERSECT_FILTER_TO_FILTER merges n-way INTERSECT from multiple sources into combined filters.
# [CALCITE-7002]

SELECT deptno FROM emp WHERE deptno < 12
INTERSECT
SELECT deptno FROM dept WHERE deptno > 5
INTERSECT
SELECT deptno FROM emp WHERE deptno > 6
INTERSECT
SELECT deptno FROM dept WHERE deptno < 10;
java.lang.AssertionError: type mismatch:
type1:
TINYINT NOT NULL
type2:
TINYINT
	at org.apache.calcite.util.Litmus.lambda$static$0(Litmus.java:31)
	at org.apache.calcite.plan.RelOptUtil.eq(RelOptUtil.java:2240)
	at org.apache.calcite.rex.RexProgramBuilder$RegisterInputShuttle.visitInputRef(RexProgramBuilder.java:945)
	at org.apache.calcite.rex.RexProgramBuilder$RegisterInputShuttle.visitInputRef(RexProgramBuilder.java:923)
	at org.apache.calcite.rex.RexInputRef.accept(RexInputRef.java:125)
	at org.apache.calcite.rex.RexShuttle.visitList(RexShuttle.java:168)
	at org.apache.calcite.rex.RexShuttle.visitCall(RexShuttle.java:120)
	at org.apache.calcite.rex.RexProgramBuilder$RegisterShuttle.visitCall(RexProgramBuilder.java:883)
	at org.apache.calcite.rex.RexProgramBuilder$RegisterShuttle.visitCall(RexProgramBuilder.java:881)
	at org.apache.calcite.rex.RexCall.accept(RexCall.java:208)
	at org.apache.calcite.rex.RexShuttle.visitList(RexShuttle.java:168)
	at org.apache.calcite.rex.RexShuttle.visitCall(RexShuttle.java:120)
	at org.apache.calcite.rex.RexProgramBuilder$RegisterShuttle.visitCall(RexProgramBuilder.java:883)
	at org.apache.calcite.rex.RexProgramBuilder$RegisterShuttle.visitCall(RexProgramBuilder.java:881)
	at org.apache.calcite.rex.RexCall.accept(RexCall.java:208)
	at org.apache.calcite.rex.RexProgramBuilder.registerInput(RexProgramBuilder.java:300)
	at org.apache.calcite.rex.RexProgramBuilder.addProject(RexProgramBuilder.java:210)
	at org.apache.calcite.rex.RexExecutorImpl.compile(RexExecutorImpl.java:76)
	at org.apache.calcite.rex.RexExecutorImpl.getExecutable(RexExecutorImpl.java:123)
	at org.apache.calcite.plan.RexImplicationChecker.isSatisfiable(RexImplicationChecker.java:259)
	at org.apache.calcite.plan.RexImplicationChecker.implies2(RexImplicationChecker.java:245)
	at org.apache.calcite.plan.RexImplicationChecker.impliesConjunction(RexImplicationChecker.java:151)
	at org.apache.calcite.plan.RexImplicationChecker.impliesAny(RexImplicationChecker.java:141)
	at org.apache.calcite.plan.RexImplicationChecker.implies(RexImplicationChecker.java:127)
	at org.apache.calcite.rel.metadata.RelMdPredicates.lambda$getPredicates$2(RelMdPredicates.java:521)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:178)
	at java.base/java.util.HashMap$KeySpliterator.forEachRemaining(HashMap.java:1715)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)
	at org.apache.calcite.rel.metadata.RelMdPredicates.getPredicates(RelMdPredicates.java:522)
	at org.apache.calcite.rel.metadata.janino.GeneratedMetadata_PredicatesHandler.getPredicates_$(Unknown Source)
	at org.apache.calcite.rel.metadata.janino.GeneratedMetadata_PredicatesHandler.getPredicates(Unknown Source)
	at org.apache.calcite.rel.metadata.RelMetadataQuery.getPulledUpPredicates(RelMetadataQuery.java:918)
	at org.apache.calcite.rel.metadata.RelMdPredicates.getPredicates(RelMdPredicates.java:641)
	at org.apache.calcite.rel.metadata.janino.GeneratedMetadata_PredicatesHandler.getPredicates_$(Unknown Source)
	at org.apache.calcite.rel.metadata.janino.GeneratedMetadata_PredicatesHandler.getPredicates(Unknown Source)
	at org.apache.calcite.rel.metadata.RelMetadataQuery.getPulledUpPredicates(RelMetadataQuery.java:918)
	at org.apache.calcite.rel.metadata.RelMdColumnUniqueness.decorateWithConstantColumnsFromPredicates(RelMdColumnUniqueness.java:516)
	at org.apache.calcite.rel.metadata.RelMdColumnUniqueness.areColumnsUnique(RelMdColumnUniqueness.java:469)
	at org.apache.calcite.rel.metadata.janino.GeneratedMetadata_ColumnUniquenessHandler.areColumnsUnique_$(Unknown Source)
	at org.apache.calcite.rel.metadata.janino.GeneratedMetadata_ColumnUniquenessHandler.areColumnsUnique(Unknown Source)
	at org.apache.calcite.rel.metadata.RelMetadataQuery.areColumnsUnique(RelMetadataQuery.java:619)
	at org.apache.calcite.rel.metadata.RelMetadataQuery.areColumnsUnique(RelMetadataQuery.java:599)
	at org.apache.calcite.rel.rules.AggregateRemoveRule.onMatch(AggregateRemoveRule.java:113)
	at org.apache.calcite.plan.volcano.VolcanoRuleCall.onMatch(VolcanoRuleCall.java:223)
	at org.apache.calcite.plan.volcano.IterativeRuleDriver.drive(IterativeRuleDriver.java:61)
	at org.apache.calcite.plan.volcano.VolcanoPlanner.findBestExp(VolcanoPlanner.java:525)
	at org.apache.calcite.tools.Programs.lambda$standard$5(Programs.java:341)
	at org.apache.calcite.tools.Programs$SequenceProgram.run(Programs.java:407)
	at org.apache.calcite.prepare.Prepare.optimize(Prepare.java:178)
	at org.apache.calcite.prepare.Prepare.prepareSql(Prepare.java:320)
	at org.apache.calcite.prepare.Prepare.prepareSql(Prepare.java:221)
	at org.apache.calcite.prepare.CalcitePrepareImpl.prepare2_(CalcitePrepareImpl.java:675)
	at org.apache.calcite.prepare.CalcitePrepareImpl.prepare_(CalcitePrepareImpl.java:526)
	at org.apache.calcite.prepare.CalcitePrepareImpl.prepareSql(CalcitePrepareImpl.java:494)
	at org.apache.calcite.jdbc.CalciteConnectionImpl.parseQuery(CalciteConnectionImpl.java:246)
	at org.apache.calcite.jdbc.CalciteMetaImpl.prepareAndExecute(CalciteMetaImpl.java:654)
	at org.apache.calcite.avatica.AvaticaConnection.prepareAndExecuteInternal(AvaticaConnection.java:677)
	at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:157)
	at org.apache.calcite.avatica.AvaticaStatement.executeQuery(AvaticaStatement.java:228)
	at net.hydromatic.quidem.Quidem.checkResult(Quidem.java:317)
	at net.hydromatic.quidem.Quidem.access$2600(Quidem.java:54)
	at net.hydromatic.quidem.Quidem$ContextImpl.checkResult(Quidem.java:1778)
	at net.hydromatic.quidem.Quidem$CheckResultCommand.execute(Quidem.java:985)
	at net.hydromatic.quidem.Quidem$CompositeCommand.execute(Quidem.java:1522)
	at net.hydromatic.quidem.Quidem.execute(Quidem.java:204)
	at org.apache.calcite.test.QuidemTest.checkRun(QuidemTest.java:540)
	at org.apache.calcite.test.QuidemTest.test(QuidemTest.java:730)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.SameThreadTimeoutInvocation.proceed(SameThreadTimeoutInvocation.java:45)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestTemplateMethod(TimeoutExtension.java:94)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:217)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:213)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:138)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.submit(ForkJoinPoolHierarchicalTestExecutorService.java:118)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:226)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:204)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:142)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.lambda$execute$2(TestTemplateTestDescriptor.java:110)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:762)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:1024)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:110)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:44)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:129)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorSe (stack truncated)
!ok
LogicalIntersect(all=[false])
  LogicalFilter(condition=[<($0, 12)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[>($0, 5)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
  LogicalFilter(condition=[>($0, 6)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[<($0, 10)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, INTERSECT_MERGE, PROJECT_FILTER_TRANSPOSE"
LogicalIntersect(all=[false])
  LogicalFilter(condition=[SEARCH($0, Sarg[(6..12)])])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[SEARCH($0, Sarg[(5..10)])])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, INTERSECT_MERGE, PROJECT_FILTER_TRANSPOSE, INTERSECT_FILTER_TO_FILTER"

# testIntersectToFilterRuleWithOneFilter ---------------------------------------
# INTERSECT_FILTER_TO_FILTER rewrites INTERSECT into a single filter when one input has no filter.
# [CALCITE-7002]

SELECT mgr, comm FROM emp
INTERSECT
SELECT mgr, comm FROM emp WHERE comm = 5;
+-----+------+
| MGR | COMM |
+-----+------+
+-----+------+
(0 rows)

!ok
LogicalIntersect(all=[false])
  LogicalProject(MGR=[$3], COMM=[$6])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($1, 5)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE"
LogicalAggregate(group=[{0, 1}])
  LogicalFilter(condition=[=($1, 5)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE, INTERSECT_FILTER_TO_FILTER"

# testIntersectToFilterRuleWithTwoFilters --------------------------------------
# INTERSECT_FILTER_TO_FILTER rewrites INTERSECT into AND of two filters.
# [CALCITE-7002]

SELECT mgr, comm FROM emp WHERE mgr = 12
INTERSECT
SELECT mgr, comm FROM emp WHERE comm = 5;
+-----+------+
| MGR | COMM |
+-----+------+
+-----+------+
(0 rows)

!ok
LogicalIntersect(all=[false])
  LogicalFilter(condition=[=($0, 12)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($1, 5)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE"
LogicalAggregate(group=[{0, 1}])
  LogicalFilter(condition=[AND(=($0, 12), =($1, 5))])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE, INTERSECT_FILTER_TO_FILTER"

# testIntersectToSemiJoin ------------------------------------------------------
# INTERSECT_TO_SEMI_JOIN rewrites 2-way INTERSECT DISTINCT to semi-join + aggregate.
# [CALCITE-6880]

select ename from emp where deptno = 10
intersect
select ename from emp where deptno = 20;
+-------+
| ENAME |
+-------+
+-------+
(0 rows)

!ok
LogicalIntersect(all=[false])
  LogicalProject(ENAME=[$1])
    LogicalFilter(condition=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(ENAME=[$1])
    LogicalFilter(condition=[=($7, 20)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{0}])
  LogicalJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[semi])
    LogicalProject(ENAME=[$1])
      LogicalFilter(condition=[=($7, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(ENAME=[$1])
      LogicalFilter(condition=[=($7, 20)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, INTERSECT_TO_SEMI_JOIN"

# testIntersectToSemiJoin2 -----------------------------------------------------
# INTERSECT_TO_SEMI_JOIN rewrites n-way INTERSECT to chained semi-joins (after INTERSECT_MERGE).
# [CALCITE-7000]

select ename from emp where deptno = 10
intersect
select deptno from emp where ename in ('a', 'b')
intersect
select ename from empnullables;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalIntersect(all=[false])
  LogicalProject(ENAME=[$1])
    LogicalFilter(condition=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(DEPTNO=[CAST($7):VARCHAR NOT NULL])
    LogicalFilter(condition=[OR(=($1, 'a'), =($1, 'b'))])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(ENAME=[$1])
    LogicalTableScan(table=[[CATALOG, SALES, EMPNULLABLES]])
!sub-plan "NONE, INTERSECT_MERGE"
LogicalAggregate(group=[{0}])
  LogicalJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[semi])
    LogicalJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[semi])
      LogicalProject(ENAME=[CAST($0):VARCHAR])
        LogicalProject(ENAME=[$1])
          LogicalFilter(condition=[=($7, 10)])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(ENAME=[CAST($0):VARCHAR])
        LogicalProject(DEPTNO=[CAST($7):VARCHAR NOT NULL])
          LogicalFilter(condition=[OR(=($1, 'a'), =($1, 'b'))])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(ENAME=[CAST($0):VARCHAR])
      LogicalProject(ENAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, EMPNULLABLES]])
!sub-plan "NONE, INTERSECT_MERGE, INTERSECT_TO_SEMI_JOIN"

# testIntersectToSemiJoinAll ---------------------------------------------------
# INTERSECT_TO_SEMI_JOIN applies only to INTERSECT DISTINCT; INTERSECT ALL is left unchanged.
# [CALCITE-6880]

select ename from emp where deptno = 10
intersect
select ename from emp where deptno = 20
intersect all
select ename from emp where deptno = 30;
+-------+
| ENAME |
+-------+
+-------+
(0 rows)

!ok
LogicalIntersect(all=[true])
  LogicalIntersect(all=[false])
    LogicalProject(ENAME=[$1])
      LogicalFilter(condition=[=($7, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(ENAME=[$1])
      LogicalFilter(condition=[=($7, 20)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(ENAME=[$1])
    LogicalFilter(condition=[=($7, 30)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalIntersect(all=[true])
  LogicalAggregate(group=[{0}])
    LogicalJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[semi])
      LogicalProject(ENAME=[$1])
        LogicalFilter(condition=[=($7, 10)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(ENAME=[$1])
        LogicalFilter(condition=[=($7, 20)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(ENAME=[$1])
    LogicalFilter(condition=[=($7, 30)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, INTERSECT_TO_SEMI_JOIN"

# testIntersectToSemiJoinCoercion ----------------------------------------------
# INTERSECT_TO_SEMI_JOIN handles column type coercion between INTERSECT inputs.
# [CALCITE-6880]

select ename from emp where deptno = 10
intersect
select job from emp where deptno = 20;
+-------+
| ENAME |
+-------+
+-------+
(0 rows)

!ok
LogicalIntersect(all=[false])
  LogicalProject(ENAME=[$1])
    LogicalFilter(condition=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(JOB=[CAST($2):VARCHAR(20) NOT NULL])
    LogicalFilter(condition=[=($7, 20)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{0}])
  LogicalJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[semi])
    LogicalProject(ENAME=[$1])
      LogicalFilter(condition=[=($7, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(JOB=[CAST($2):VARCHAR(20) NOT NULL])
      LogicalFilter(condition=[=($7, 20)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, INTERSECT_TO_SEMI_JOIN"

# testIntersectToSemiJoinMultiCol ----------------------------------------------
# INTERSECT_TO_SEMI_JOIN rewrites INTERSECT with multiple columns to a multi-condition semi-join.
# [CALCITE-6880]

select deptno, ename from emp where deptno = 10
intersect
select deptno, ename from emp where deptno = 20;
+--------+-------+
| DEPTNO | ENAME |
+--------+-------+
+--------+-------+
(0 rows)

!ok
LogicalIntersect(all=[false])
  LogicalProject(DEPTNO=[$7], ENAME=[$1])
    LogicalFilter(condition=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(DEPTNO=[$7], ENAME=[$1])
    LogicalFilter(condition=[=($7, 20)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{0, 1}])
  LogicalJoin(condition=[AND(IS NOT DISTINCT FROM($0, $2), IS NOT DISTINCT FROM($1, $3))], joinType=[semi])
    LogicalProject(DEPTNO=[$7], ENAME=[$1])
      LogicalFilter(condition=[=($7, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(DEPTNO=[$7], ENAME=[$1])
      LogicalFilter(condition=[=($7, 20)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, INTERSECT_TO_SEMI_JOIN"

# testMinusToAntiJoinRule ------------------------------------------------------
# MINUS_TO_ANTI_JOIN rewrites 2-way EXCEPT DISTINCT to anti-join + aggregate.
# [CALCITE-6948]

select ename from emp where deptno = 10
except
select ename from emp where deptno = 20;
+--------+
| ENAME  |
+--------+
| CLARK  |
| KING   |
| MILLER |
+--------+
(3 rows)

!ok
LogicalMinus(all=[false])
  LogicalProject(ENAME=[$1])
    LogicalFilter(condition=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(ENAME=[$1])
    LogicalFilter(condition=[=($7, 20)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{0}])
  LogicalJoin(condition=[=($0, $1)], joinType=[anti])
    LogicalProject(ENAME=[$1])
      LogicalFilter(condition=[=($7, 10)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(ENAME=[$1])
      LogicalFilter(condition=[=($7, 20)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, MINUS_TO_ANTI_JOIN"

# testMinusToAntiJoinRuleMultiInputs -------------------------------------------
# MINUS_TO_ANTI_JOIN rewrites n-way EXCEPT to chained anti-joins (after MINUS_MERGE).

select ename from emp where deptno = 10
except
select deptno from emp where ename in ('a', 'b')
except
select ename from empnullables;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalMinus(all=[false])
  LogicalProject(ENAME=[$1])
    LogicalFilter(condition=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(DEPTNO=[CAST($7):VARCHAR NOT NULL])
    LogicalFilter(condition=[OR(=($1, 'a'), =($1, 'b'))])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(ENAME=[$1])
    LogicalTableScan(table=[[CATALOG, SALES, EMPNULLABLES]])
!sub-plan "NONE, MINUS_MERGE"
LogicalProject(ENAME=[CAST($0):VARCHAR])
  LogicalAggregate(group=[{0}])
    LogicalJoin(condition=[IS NOT DISTINCT FROM(CAST($0):VARCHAR, CAST($1):VARCHAR)], joinType=[anti])
      LogicalJoin(condition=[=(CAST($0):VARCHAR, $1)], joinType=[anti])
        LogicalProject(ENAME=[$1])
          LogicalFilter(condition=[=($7, 10)])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(DEPTNO=[CAST($7):VARCHAR NOT NULL])
          LogicalFilter(condition=[OR(=($1, 'a'), =($1, 'b'))])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(ENAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, EMPNULLABLES]])
!sub-plan "NONE, MINUS_MERGE, MINUS_TO_ANTI_JOIN"

# testMinusToFilterNWayWithSubquery --------------------------------------------
# MINUS_FILTER_TO_FILTER merges same-source inputs in n-way EXCEPT containing a correlated subquery.
# [CALCITE-7002]

SELECT deptno FROM emp WHERE deptno > 12
EXCEPT
SELECT deptno FROM dept WHERE deptno = 5
EXCEPT
SELECT deptno FROM emp e1 WHERE EXISTS (
    SELECT 1 FROM emp e2
    WHERE e2.comm = e1.comm)
EXCEPT
SELECT deptno FROM dept WHERE deptno = 10
EXCEPT
SELECT deptno FROM emp WHERE deptno > 20;
# Not using !ok: EnumerableMinus with correlated subquery is not supported by H2.
LogicalMinus(all=[false])
  LogicalFilter(condition=[>($0, 12)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($0, 5)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
  LogicalFilter(condition=[EXISTS({
LogicalFilter(condition=[=($6, $cor0.COMM)])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
})])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($0, 10)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
  LogicalFilter(condition=[>($0, 20)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, MINUS_MERGE, PROJECT_FILTER_TRANSPOSE"
LogicalMinus(all=[false])
  LogicalFilter(condition=[SEARCH($0, Sarg[(12..20]])])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[SEARCH($0, Sarg[5, 10])])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
  LogicalFilter(condition=[EXISTS({
LogicalFilter(condition=[=($6, $cor0.COMM)])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
})])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, MINUS_MERGE, PROJECT_FILTER_TRANSPOSE, MINUS_FILTER_TO_FILTER"

# testMinusToFilterRuleFourWayWithForSources -----------------------------------
# MINUS_FILTER_TO_FILTER is unchanged when all four EXCEPT sources are different tables.
# [CALCITE-7002]

SELECT deptno FROM emp WHERE deptno = 12
EXCEPT
SELECT deptno FROM dept WHERE deptno = 5
EXCEPT
SELECT deptno FROM empnullables WHERE deptno = 6
EXCEPT
SELECT deptno FROM deptnullables WHERE deptno = 10;
# Not using !ok: this test focuses on plan transformation (see !sub-plan).
LogicalMinus(all=[false])
  LogicalFilter(condition=[=($0, 12)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($0, 5)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
  LogicalFilter(condition=[=($0, 6)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMPNULLABLES]])
  LogicalFilter(condition=[=($0, 10)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPTNULLABLES]])
!sub-plan "NONE, MINUS_MERGE, PROJECT_FILTER_TRANSPOSE"
LogicalMinus(all=[false])
  LogicalFilter(condition=[=($0, 12)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($0, 5)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
  LogicalFilter(condition=[=($0, 6)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMPNULLABLES]])
  LogicalFilter(condition=[=($0, 10)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPTNULLABLES]])
!sub-plan "NONE, MINUS_MERGE, PROJECT_FILTER_TRANSPOSE, MINUS_FILTER_TO_FILTER"

# testMinusToFilterRuleNWayWithMultiSources ------------------------------------
# MINUS_FILTER_TO_FILTER merges n-way EXCEPT from multiple sources into combined filters.
# [CALCITE-6973]

SELECT deptno FROM emp WHERE deptno > 6
EXCEPT
SELECT deptno FROM dept WHERE deptno > 8
EXCEPT
SELECT deptno FROM emp WHERE deptno > 12
EXCEPT
SELECT deptno FROM dept WHERE deptno > 10;
+--------+
| DEPTNO |
+--------+
+--------+
(0 rows)

!ok
LogicalMinus(all=[false])
  LogicalFilter(condition=[>($0, 6)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[>($0, 8)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
  LogicalFilter(condition=[>($0, 12)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[>($0, 10)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, MINUS_MERGE, PROJECT_FILTER_TRANSPOSE"
LogicalMinus(all=[false])
  LogicalFilter(condition=[SEARCH($0, Sarg[(6..12]])])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[>($0, 8)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, MINUS_MERGE, PROJECT_FILTER_TRANSPOSE, MINUS_FILTER_TO_FILTER"

# testMinusToFilterRuleWithOneFilter -------------------------------------------
# MINUS_FILTER_TO_FILTER rewrites EXCEPT into a negated filter when one input has no filter.
# [CALCITE-6973]

SELECT mgr, comm FROM emp
EXCEPT
SELECT mgr, comm FROM emp WHERE comm = 5;
+------+---------+
| MGR  | COMM    |
+------+---------+
| 7566 |         |
| 7698 |    0.00 |
| 7698 | 1400.00 |
| 7698 |  300.00 |
| 7698 |  500.00 |
| 7698 |         |
| 7782 |         |
| 7788 |         |
| 7839 |         |
| 7902 |         |
|      |         |
+------+---------+
(11 rows)

!ok
LogicalMinus(all=[false])
  LogicalProject(MGR=[$3], COMM=[$6])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($1, 5)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE"
LogicalAggregate(group=[{0, 1}])
  LogicalFilter(condition=[<>($1, 5)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE, MINUS_FILTER_TO_FILTER"

# testMinusToFilterRuleWithTwoFilters ------------------------------------------
# MINUS_FILTER_TO_FILTER rewrites EXCEPT into AND of one filter and NOT of the other.
# [CALCITE-6973]

SELECT mgr, comm FROM emp WHERE mgr = 12
EXCEPT
SELECT mgr, comm FROM emp WHERE comm = 5;
+-----+------+
| MGR | COMM |
+-----+------+
+-----+------+
(0 rows)

!ok
LogicalMinus(all=[false])
  LogicalFilter(condition=[=($0, 12)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($1, 5)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE"
LogicalAggregate(group=[{0, 1}])
  LogicalFilter(condition=[AND(=($0, 12), <>($1, 5))])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE, MINUS_FILTER_TO_FILTER"

# testPushJoinThroughUnionOnLeft -----------------------------------------------
# JOIN_LEFT_UNION_TRANSPOSE distributes a join over a UNION ALL on the left input.

select r1.sal from
(select * from emp e1 union all select * from emp e2) r1,
emp r2;
+---------+
| SAL     |
+---------+
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
+---------+
(392 rows)

!ok
LogicalProject(SAL=[$5])
  LogicalJoin(condition=[true], joinType=[inner])
    LogicalUnion(all=[true])
      LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(SAL=[$5])
  LogicalUnion(all=[true])
    LogicalJoin(condition=[true], joinType=[inner])
      LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalJoin(condition=[true], joinType=[inner])
      LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, JOIN_LEFT_UNION_TRANSPOSE"

# testPushJoinThroughUnionOnRight ----------------------------------------------
# JOIN_RIGHT_UNION_TRANSPOSE distributes a join over a UNION ALL on the right input.

select r1.sal from
emp r1,
(select * from emp e1 union all select * from emp e2) r2;
+---------+
| SAL     |
+---------+
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1100.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1300.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1500.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 1600.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2450.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2850.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 2975.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
| 5000.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  800.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
|  950.00 |
+---------+
(392 rows)

!ok
LogicalProject(SAL=[$5])
  LogicalJoin(condition=[true], joinType=[inner])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalUnion(all=[true])
      LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(SAL=[$5])
  LogicalUnion(all=[true])
    LogicalJoin(condition=[true], joinType=[inner])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalJoin(condition=[true], joinType=[inner])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, JOIN_RIGHT_UNION_TRANSPOSE"

# testUnionToFilterRuleNWayWithMultiSources ------------------------------------
# UNION_FILTER_TO_FILTER merges n-way UNION from multiple sources into combined filters.
# [CALCITE-7002]

SELECT deptno FROM emp WHERE deptno = 12
UNION
SELECT deptno FROM dept WHERE deptno = 5
UNION
SELECT deptno FROM emp WHERE deptno = 6
UNION
SELECT deptno FROM dept WHERE deptno = 10;
+--------+
| DEPTNO |
+--------+
|     10 |
+--------+
(1 row)

!ok
LogicalUnion(all=[false])
  LogicalFilter(condition=[=($0, 12)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($0, 5)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
  LogicalFilter(condition=[=($0, 6)])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($0, 10)])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, UNION_MERGE, PROJECT_FILTER_TRANSPOSE"
LogicalUnion(all=[false])
  LogicalFilter(condition=[SEARCH($0, Sarg[6, 12])])
    LogicalProject(DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[SEARCH($0, Sarg[5, 10])])
    LogicalProject(DEPTNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, UNION_MERGE, PROJECT_FILTER_TRANSPOSE, UNION_FILTER_TO_FILTER"

# testUnionToFilterRuleWithOneFilter -------------------------------------------
# UNION_FILTER_TO_FILTER rewrites UNION into a single scan when one input has no filter.
# [CALCITE-7002]

SELECT mgr, comm FROM emp
UNION
SELECT mgr, comm FROM emp WHERE comm = 5;
+------+---------+
| MGR  | COMM    |
+------+---------+
| 7566 |         |
| 7698 |    0.00 |
| 7698 | 1400.00 |
| 7698 |  300.00 |
| 7698 |  500.00 |
| 7698 |         |
| 7782 |         |
| 7788 |         |
| 7839 |         |
| 7902 |         |
|      |         |
+------+---------+
(11 rows)

!ok
LogicalUnion(all=[false])
  LogicalProject(MGR=[$3], COMM=[$6])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($1, 5)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE"
LogicalAggregate(group=[{0, 1}])
  LogicalProject(MGR=[$3], COMM=[$6])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE, UNION_FILTER_TO_FILTER"

# testUnionToFilterRuleWithTwoFilters ------------------------------------------
# UNION_FILTER_TO_FILTER rewrites UNION into OR of two filters.
# [CALCITE-7002]

SELECT mgr, comm FROM emp WHERE mgr = 12
UNION
SELECT mgr, comm FROM emp WHERE comm = 5;
+-----+------+
| MGR | COMM |
+-----+------+
+-----+------+
(0 rows)

!ok
LogicalUnion(all=[false])
  LogicalFilter(condition=[=($0, 12)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalFilter(condition=[=($1, 5)])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE"
LogicalAggregate(group=[{0, 1}])
  LogicalFilter(condition=[OR(=($0, 12), =($1, 5))])
    LogicalProject(MGR=[$3], COMM=[$6])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE, UNION_FILTER_TO_FILTER"

# End set-op.iq
