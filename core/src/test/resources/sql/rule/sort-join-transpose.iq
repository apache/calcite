# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Tests planner rules related to pushing Sort past Join
# (SORT_JOIN_TRANSPOSE, SORT_JOIN_COPY, SORT_PROJECT_TRANSPOSE).
#
# Ensure that tests occur in alphabetical order:
# // lint: sort where '^[#] test'
#

!use scott
!set outputformat mysql

# testSortJoinCopyInnerJoinOrderBy ---------------------------------------------
# SORT_JOIN_COPY should copy the Sort to the preserving side of an inner join.

select * from emp join dept on
emp.deptno = dept.deptno order by sal;
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO0 | DNAME      | LOC      |
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |      30 | SALES      | CHICAGO  |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |      30 | SALES      | CHICAGO  |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |      30 | SALES      | CHICAGO  |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |      30 | SALES      | CHICAGO  |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |      30 | SALES      | CHICAGO  |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |      30 | SALES      | CHICAGO  |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
(14 rows)

!ok

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$5], dir0=[ASC])
    LogicalJoin(condition=[=($7, $9)], joinType=[inner])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$5], dir0=[ASC])
    LogicalJoin(condition=[=($7, $9)], joinType=[inner])
      LogicalSort(sort0=[$5], dir0=[ASC])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_COPY"

# testSortJoinCopyInnerJoinOrderByLimit ----------------------------------------
# SORT_JOIN_COPY should copy the Sort but not the fetch to the preserving side.

select * from emp e join (
  select * from dept d) d on e.deptno = d.deptno
order by sal limit 10;
+-------+--------+----------+------+------------+---------+---------+--------+---------+------------+----------+
| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO0 | DNAME      | LOC      |
+-------+--------+----------+------+------------+---------+---------+--------+---------+------------+----------+
|  7369 | SMITH  | CLERK    | 7902 | 1980-12-17 |  800.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7900 | JAMES  | CLERK    | 7698 | 1981-12-03 |  950.00 |         |     30 |      30 | SALES      | CHICAGO  |
|  7876 | ADAMS  | CLERK    | 7788 | 1987-05-23 | 1100.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |      30 | SALES      | CHICAGO  |
|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |      30 | SALES      | CHICAGO  |
|  7934 | MILLER | CLERK    | 7782 | 1982-01-23 | 1300.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |      30 | SALES      | CHICAGO  |
|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |      30 | SALES      | CHICAGO  |
|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7698 | BLAKE  | MANAGER  | 7839 | 1981-01-05 | 2850.00 |         |     30 |      30 | SALES      | CHICAGO  |
+-------+--------+----------+------+------------+---------+---------+--------+---------+------------+----------+
(10 rows)

!ok

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$5], dir0=[ASC], fetch=[10])
    LogicalJoin(condition=[=($7, $9)], joinType=[inner])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$5], dir0=[ASC], fetch=[10])
    LogicalJoin(condition=[=($7, $9)], joinType=[inner])
      LogicalSort(sort0=[$5], dir0=[ASC])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_COPY"

# testSortJoinCopyInnerJoinOrderByTwoFields ------------------------------------
# SORT_JOIN_COPY should copy Sort keys to both sides when each key comes from
# a different input.

select * from emp e join  dept d on
 e.deptno = d.deptno order by e.sal,d.dname;
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO0 | DNAME      | LOC      |
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |      30 | SALES      | CHICAGO  |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |      30 | SALES      | CHICAGO  |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |      30 | SALES      | CHICAGO  |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |      30 | SALES      | CHICAGO  |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |      30 | SALES      | CHICAGO  |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |      30 | SALES      | CHICAGO  |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
(14 rows)

!ok

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$5], sort1=[$10], dir0=[ASC], dir1=[ASC])
    LogicalJoin(condition=[=($7, $9)], joinType=[inner])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$5], sort1=[$10], dir0=[ASC], dir1=[ASC])
    LogicalJoin(condition=[=($7, $9)], joinType=[inner])
      LogicalSort(sort0=[$5], dir0=[ASC])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalSort(sort0=[$1], dir0=[ASC])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_COPY"

# testSortJoinTranspose1 -------------------------------------------------------
# SORT_JOIN_TRANSPOSE should push Sort past the preserving side of a left join.

select * from emp e left join (
  select * from dept d) d on e.deptno = d.deptno
order by sal limit 10;
+-------+--------+----------+------+------------+---------+---------+--------+---------+------------+----------+
| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO0 | DNAME      | LOC      |
+-------+--------+----------+------+------------+---------+---------+--------+---------+------------+----------+
|  7369 | SMITH  | CLERK    | 7902 | 1980-12-17 |  800.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7900 | JAMES  | CLERK    | 7698 | 1981-12-03 |  950.00 |         |     30 |      30 | SALES      | CHICAGO  |
|  7876 | ADAMS  | CLERK    | 7788 | 1987-05-23 | 1100.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |      30 | SALES      | CHICAGO  |
|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |      30 | SALES      | CHICAGO  |
|  7934 | MILLER | CLERK    | 7782 | 1982-01-23 | 1300.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |      30 | SALES      | CHICAGO  |
|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |      30 | SALES      | CHICAGO  |
|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7698 | BLAKE  | MANAGER  | 7839 | 1981-01-05 | 2850.00 |         |     30 |      30 | SALES      | CHICAGO  |
+-------+--------+----------+------+------------+---------+---------+--------+---------+------------+----------+
(10 rows)

!ok

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$5], dir0=[ASC], fetch=[10])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$5], dir0=[ASC], fetch=[10])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalSort(sort0=[$5], dir0=[ASC], fetch=[10])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE"

# testSortJoinTranspose10 ------------------------------------------------------
# SORT_JOIN_TRANSPOSE should handle large BIGINT fetch and offset values.

select * from emp e left join (
  select * from dept d) d on e.deptno = d.deptno
limit 3000000000 offset 2500000000;
# Not using !ok: LIMIT 3000000000 OFFSET 2500000000 overflows H2 implementation limits.

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(offset=[2500000000:BIGINT], fetch=[3000000000:BIGINT])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(offset=[2500000000:BIGINT], fetch=[3000000000:BIGINT])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalSort(fetch=[5500000000:BIGINT])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE"

# testSortJoinTranspose2 -------------------------------------------------------
# SORT_JOIN_TRANSPOSE should push Sort past the preserving side of a right join.

select * from emp e right join (
  select * from dept d) d on e.deptno = d.deptno
order by dname;
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO0 | DNAME      | LOC      |
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|       |        |           |      |            |         |         |        |      40 | OPERATIONS | BOSTON   |
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |      30 | SALES      | CHICAGO  |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |      30 | SALES      | CHICAGO  |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |      30 | SALES      | CHICAGO  |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |      30 | SALES      | CHICAGO  |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |      30 | SALES      | CHICAGO  |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |      30 | SALES      | CHICAGO  |
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
(15 rows)

!ok

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$10], dir0=[ASC])
    LogicalJoin(condition=[=($7, $9)], joinType=[right])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$10], dir0=[ASC])
    LogicalJoin(condition=[=($7, $9)], joinType=[right])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalSort(sort0=[$1], dir0=[ASC])
        LogicalProject(DEPTNO=[$0], DNAME=[$1])
          LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE"

# testSortJoinTranspose3 -------------------------------------------------------
# SORT_JOIN_TRANSPOSE should not push Sort when keys come from both sides of
# the join.

select * from emp e left join (
  select * from dept) d on e.deptno = d.deptno
order by sal, dname limit 10;
+-------+--------+----------+------+------------+---------+---------+--------+---------+------------+----------+
| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO0 | DNAME      | LOC      |
+-------+--------+----------+------+------------+---------+---------+--------+---------+------------+----------+
|  7369 | SMITH  | CLERK    | 7902 | 1980-12-17 |  800.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7900 | JAMES  | CLERK    | 7698 | 1981-12-03 |  950.00 |         |     30 |      30 | SALES      | CHICAGO  |
|  7876 | ADAMS  | CLERK    | 7788 | 1987-05-23 | 1100.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |      30 | SALES      | CHICAGO  |
|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |      30 | SALES      | CHICAGO  |
|  7934 | MILLER | CLERK    | 7782 | 1982-01-23 | 1300.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |      30 | SALES      | CHICAGO  |
|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |      30 | SALES      | CHICAGO  |
|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7698 | BLAKE  | MANAGER  | 7839 | 1981-01-05 | 2850.00 |         |     30 |      30 | SALES      | CHICAGO  |
+-------+--------+----------+------+------------+---------+---------+--------+---------+------------+----------+
(10 rows)

!ok

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$5], sort1=[$10], dir0=[ASC], dir1=[ASC], fetch=[10])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(sort0=[$5], sort1=[$10], dir0=[ASC], dir1=[ASC], fetch=[10])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE"

# testSortJoinTranspose5 -------------------------------------------------------
# SORT_JOIN_TRANSPOSE should not fire again after it has already pushed the Sort.
# [CALCITE-1498]

select * from emp e right join (
  select * from dept d) d on e.deptno = d.deptno
limit 10;
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO0 | DNAME      | LOC      |
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |      30 | SALES      | CHICAGO  |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |      30 | SALES      | CHICAGO  |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |      30 | SALES      | CHICAGO  |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |      30 | SALES      | CHICAGO  |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |      20 | RESEARCH   | DALLAS   |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |      10 | ACCOUNTING | NEW YORK |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |      30 | SALES      | CHICAGO  |
+-------+--------+-----------+------+------------+---------+---------+--------+---------+------------+----------+
(10 rows)

!ok

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(fetch=[10])
    LogicalJoin(condition=[=($7, $9)], joinType=[right])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalSort(fetch=[10])
          LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE, SORT_PROJECT_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(fetch=[10])
    LogicalJoin(condition=[=($7, $9)], joinType=[right])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalSort(fetch=[10])
          LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE"

# testSortJoinTranspose6 -------------------------------------------------------
# SORT_JOIN_TRANSPOSE should push LIMIT+OFFSET past a count-preserving join.
# [CALCITE-1507]

select d.deptno, empno from dept d
right join emp e using (deptno) limit 10 offset 2;
+--------+-------+
| DEPTNO | EMPNO |
+--------+-------+
|     10 |  7934 |
|     20 |  7369 |
|     20 |  7566 |
|     20 |  7788 |
|     20 |  7876 |
|     20 |  7902 |
|     30 |  7499 |
|     30 |  7521 |
|     30 |  7654 |
|     30 |  7698 |
+--------+-------+
(10 rows)

!ok

LogicalProject(DEPTNO=[$0], EMPNO=[$2])
  LogicalSort(offset=[2], fetch=[10])
    LogicalJoin(condition=[=($0, $9)], joinType=[right])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"
LogicalProject(DEPTNO=[$0], EMPNO=[$2])
  LogicalSort(offset=[2], fetch=[10])
    LogicalJoin(condition=[=($0, $9)], joinType=[right])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
      LogicalSort(fetch=[12])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE"

# testSortJoinTranspose7 -------------------------------------------------------
# SORT_JOIN_TRANSPOSE should push Sort with OFFSET past a left join when the
# non-preserving side is count-preserving against the join condition.
# [CALCITE-1507]

select d.deptno, empno from dept d
left join emp e using (deptno) order by d.deptno offset 1;
+--------+-------+
| DEPTNO | EMPNO |
+--------+-------+
|     10 |  7839 |
|     10 |  7934 |
|     20 |  7369 |
|     20 |  7566 |
|     20 |  7788 |
|     20 |  7876 |
|     20 |  7902 |
|     30 |  7499 |
|     30 |  7521 |
|     30 |  7654 |
|     30 |  7698 |
|     30 |  7844 |
|     30 |  7900 |
|     40 |       |
+--------+-------+
(14 rows)

!ok

LogicalProject(DEPTNO=[$0], EMPNO=[$2])
  LogicalSort(sort0=[$0], dir0=[ASC], offset=[1])
    LogicalJoin(condition=[=($0, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"
LogicalProject(DEPTNO=[$0], EMPNO=[$2])
  LogicalSort(sort0=[$0], dir0=[ASC], offset=[1])
    LogicalJoin(condition=[=($0, $9)], joinType=[left])
      LogicalSort(sort0=[$0], dir0=[ASC])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE"

# testSortJoinTranspose8 -------------------------------------------------------
# SORT_JOIN_TRANSPOSE should not push Sort past a JOIN when fetch is a dynamic
# parameter.
# [CALCITE-6983]

select * from emp e right join (
  select * from dept d) d on e.deptno = d.deptno
FETCH NEXT ? ROWS ONLY;
java.sql.SQLException: Error while executing SQL "select * from emp e right join (
  select * from dept d) d on e.deptno = d.deptno
FETCH NEXT ? ROWS ONLY": Cannot invoke "java.lang.Integer.intValue()" because the return value of "org.apache.calcite.DataContext.get(String)" is null
	at org.apache.calcite.avatica.Helper.createException(Helper.java:56)
	at org.apache.calcite.avatica.Helper.createException(Helper.java:41)
	at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:164)
	at org.apache.calcite.avatica.AvaticaStatement.executeQuery(AvaticaStatement.java:228)
	at net.hydromatic.quidem.Quidem.checkResult(Quidem.java:317)
	at net.hydromatic.quidem.Quidem.access$2600(Quidem.java:54)
	at net.hydromatic.quidem.Quidem$ContextImpl.checkResult(Quidem.java:1778)
	at net.hydromatic.quidem.Quidem$CheckResultCommand.execute(Quidem.java:985)
	at net.hydromatic.quidem.Quidem$CompositeCommand.execute(Quidem.java:1522)
	at net.hydromatic.quidem.Quidem.execute(Quidem.java:204)
	at org.apache.calcite.test.QuidemTest.checkRun(QuidemTest.java:540)
	at org.apache.calcite.test.QuidemTest.test(QuidemTest.java:730)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.SameThreadTimeoutInvocation.proceed(SameThreadTimeoutInvocation.java:45)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestTemplateMethod(TimeoutExtension.java:94)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:217)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:213)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:138)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.submit(ForkJoinPoolHierarchicalTestExecutorService.java:118)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:226)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:204)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:142)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.lambda$execute$2(TestTemplateTestDescriptor.java:110)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:762)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:1024)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:110)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:44)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:129)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:129)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at java.base/java.util.concurrent.RecursiveAction.exec(RecursiveAction.java:194)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:387)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1310)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1841)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1806)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:188)
Caused by: java.lang.NullPointerException: Cannot invoke "java.lang.Integer.intValue()" because the return value of "org.apache.calcite.DataContext.get(String)" is null
	at Baz.bind(Unknown Source)
	at org.apache.calcite.jdbc.CalcitePrepare$CalciteSignature.enumerable(CalcitePrepare.java:367)
	at org.apache.calcite.jdbc.CalciteConnectionImpl.enumerable(CalciteConnectionImpl.java:335)
	at org.apache.calcite.jdbc.CalciteMetaImpl._createIterable(CalciteMetaImpl.java:609)
	at org.apache.calcite.jdbc.CalciteMetaImpl.createIterable(CalciteMetaImpl.java:600)
	at org.apache.calcite.avatica.AvaticaResultSet.execute(AvaticaResultSet.java:184)
	at org.apache.calcite.jdbc.CalciteResultSet.execute(CalciteResultSet.java:64)
	at org.apache.calcite.jdbc.CalciteResultSet.execute(CalciteResultSet.java:43)
	at org.apache.calcite.avatica.AvaticaConnection$1.execute(AvaticaConnection.java:669)
	at org.apache.calcite.jdbc.CalciteMetaImpl.prepareAndExecute(CalciteMetaImpl.java:669)
	at org.apache.calcite.avatica.AvaticaConnection.prepareAndExecuteInternal(AvaticaConnection.java:677)
	at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:157)
	... 123 more
!ok

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(fetch=[?0])
    LogicalJoin(condition=[=($7, $9)], joinType=[right])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE, SORT_PROJECT_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(fetch=[?0])
    LogicalJoin(condition=[=($7, $9)], joinType=[right])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE"

# testSortJoinTranspose9 -------------------------------------------------------
# SORT_JOIN_TRANSPOSE should not push Sort past a JOIN when offset is a dynamic
# parameter.
# [CALCITE-6983]

select * from emp e left join (
  select * from dept d) d on e.deptno = d.deptno
OFFSET ? ROWS;
java.sql.SQLException: Error while executing SQL "select * from emp e left join (
  select * from dept d) d on e.deptno = d.deptno
OFFSET ? ROWS": Cannot invoke "java.lang.Integer.intValue()" because the return value of "org.apache.calcite.DataContext.get(String)" is null
	at org.apache.calcite.avatica.Helper.createException(Helper.java:56)
	at org.apache.calcite.avatica.Helper.createException(Helper.java:41)
	at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:164)
	at org.apache.calcite.avatica.AvaticaStatement.executeQuery(AvaticaStatement.java:228)
	at net.hydromatic.quidem.Quidem.checkResult(Quidem.java:317)
	at net.hydromatic.quidem.Quidem.access$2600(Quidem.java:54)
	at net.hydromatic.quidem.Quidem$ContextImpl.checkResult(Quidem.java:1778)
	at net.hydromatic.quidem.Quidem$CheckResultCommand.execute(Quidem.java:985)
	at net.hydromatic.quidem.Quidem$CompositeCommand.execute(Quidem.java:1522)
	at net.hydromatic.quidem.Quidem.execute(Quidem.java:204)
	at org.apache.calcite.test.QuidemTest.checkRun(QuidemTest.java:540)
	at org.apache.calcite.test.QuidemTest.test(QuidemTest.java:730)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.SameThreadTimeoutInvocation.proceed(SameThreadTimeoutInvocation.java:45)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestTemplateMethod(TimeoutExtension.java:94)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:217)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:213)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:138)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.submit(ForkJoinPoolHierarchicalTestExecutorService.java:118)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:226)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:204)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:142)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.lambda$execute$2(TestTemplateTestDescriptor.java:110)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:762)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:1024)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:110)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:44)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:129)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:129)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at java.base/java.util.concurrent.RecursiveAction.exec(RecursiveAction.java:194)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:387)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1310)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1841)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1806)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:188)
Caused by: java.lang.NullPointerException: Cannot invoke "java.lang.Integer.intValue()" because the return value of "org.apache.calcite.DataContext.get(String)" is null
	at Baz.bind(Unknown Source)
	at org.apache.calcite.jdbc.CalcitePrepare$CalciteSignature.enumerable(CalcitePrepare.java:367)
	at org.apache.calcite.jdbc.CalciteConnectionImpl.enumerable(CalciteConnectionImpl.java:335)
	at org.apache.calcite.jdbc.CalciteMetaImpl._createIterable(CalciteMetaImpl.java:609)
	at org.apache.calcite.jdbc.CalciteMetaImpl.createIterable(CalciteMetaImpl.java:600)
	at org.apache.calcite.avatica.AvaticaResultSet.execute(AvaticaResultSet.java:184)
	at org.apache.calcite.jdbc.CalciteResultSet.execute(CalciteResultSet.java:64)
	at org.apache.calcite.jdbc.CalciteResultSet.execute(CalciteResultSet.java:43)
	at org.apache.calcite.avatica.AvaticaConnection$1.execute(AvaticaConnection.java:669)
	at org.apache.calcite.jdbc.CalciteMetaImpl.prepareAndExecute(CalciteMetaImpl.java:669)
	at org.apache.calcite.avatica.AvaticaConnection.prepareAndExecuteInternal(AvaticaConnection.java:677)
	at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:157)
	... 123 more
!ok

LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(offset=[?0])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE, SORT_PROJECT_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], DEPTNO0=[$9], DNAME=[$10])
  LogicalSort(offset=[?0])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$0], DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE, SORT_PROJECT_TRANSPOSE, SORT_JOIN_TRANSPOSE"

# testSortProjectTranspose1 ----------------------------------------------------
# SORT_PROJECT_TRANSPOSE should push Sort past a Project when the sort key is a
# monotone expression (cast to same type).

select d.deptno from dept d
order by cast(d.deptno as integer) offset 1;
+--------+
| DEPTNO |
+--------+
|     20 |
|     30 |
|     40 |
+--------+
(3 rows)

!ok

LogicalProject(DEPTNO=[$0])
  LogicalSort(sort0=[$1], dir0=[ASC], offset=[1])
    LogicalProject(DEPTNO=[$0], EXPR$1=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$0])
  LogicalProject(DEPTNO=[$0], EXPR$1=[$0])
    LogicalSort(sort0=[$0], dir0=[ASC], offset=[1])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"

# testSortProjectTranspose2 ----------------------------------------------------
# SORT_PROJECT_TRANSPOSE should push Sort past a Project when the sort key is a
# monotone cast (DOUBLE preserves integer ordering).

select d.deptno from dept d
order by cast(d.deptno as double) offset 1;
+--------+
| DEPTNO |
+--------+
|     20 |
|     30 |
|     40 |
+--------+
(3 rows)

!ok

LogicalProject(DEPTNO=[$0])
  LogicalSort(sort0=[$1], dir0=[ASC], offset=[1])
    LogicalProject(DEPTNO=[$0], EXPR$1=[CAST($0):DOUBLE NOT NULL])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$0])
  LogicalProject(DEPTNO=[$0], EXPR$1=[CAST($0):DOUBLE NOT NULL])
    LogicalSort(sort0=[$0], dir0=[ASC], offset=[1])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_PROJECT_TRANSPOSE"

# testSortProjectTranspose3 ----------------------------------------------------
# SORT_JOIN_TRANSPOSE should not push Sort past a Project when the sort key is
# a non-monotone cast (VARCHAR ordering differs from integer ordering).

select d.deptno from dept d
order by cast(d.deptno as varchar(10)) offset 1;
+--------+
| DEPTNO |
+--------+
|     20 |
|     30 |
|     40 |
+--------+
(3 rows)

!ok

LogicalProject(DEPTNO=[$0])
  LogicalSort(sort0=[$1], dir0=[ASC], offset=[1])
    LogicalProject(DEPTNO=[$0], EXPR$1=[CAST($0):VARCHAR(10) NOT NULL])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$0])
  LogicalSort(sort0=[$1], dir0=[ASC], offset=[1])
    LogicalProject(DEPTNO=[$0], EXPR$1=[CAST($0):VARCHAR(10) NOT NULL])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, SORT_JOIN_TRANSPOSE"

# End sort-join-transpose.iq
