# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Tests planner rules related to JOIN_PUSH_TRANSITIVE_PREDICATES, which
# infers and pushes transitive predicates through joins.
#
# Ensure that tests occur in alphabetical order:
# // lint: sort where '^[#] test'
#

!use scott
!set outputformat mysql

# testInferringPredicatesWithNotOperatorInJoinCondition -----------------------
# [CALCITE-2275] Tests that JoinPushTransitivePredicatesRule correctly handles
# a NOT IN condition in the join condition, pushing the NOT predicate to the
# left side and the equivalent SEARCH predicate to the right side.

select * from sales.emp d
join sales.emp e on e.deptno = d.deptno and d.deptno not in (4, 6);
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], EMPNO0=[$9], ENAME0=[$10], JOB0=[$11], MGR0=[$12], HIREDATE0=[$13], SAL0=[$14], COMM0=[$15], DEPTNO0=[$16], SLACKER0=[$17])
  LogicalJoin(condition=[AND(=($16, $7), NOT(OR(=($7, 4), =($7, 6))))], joinType=[inner])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "relBuilderSimplify=false, NONE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], EMPNO0=[$9], ENAME0=[$10], JOB0=[$11], MGR0=[$12], HIREDATE0=[$13], SAL0=[$14], COMM0=[$15], DEPTNO0=[$16], SLACKER0=[$17])
  LogicalJoin(condition=[=($16, $7)], joinType=[inner])
    LogicalFilter(condition=[NOT(OR(=($7, 4), =($7, 6)))])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[SEARCH($7, Sarg[(-∞..4), (4..6), (6..+∞)])])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "relBuilderSimplify=false, NONE, FILTER_INTO_JOIN, JOIN_CONDITION_PUSH, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testInfiniteLoopWithBetweenAnd -----------------------------------------------
# Tests that JOIN_PUSH_TRANSITIVE_PREDICATES does not cause an infinite loop
# [CALCITE-7302]
# when the join condition involves a BETWEEN predicate.

With dept_temp as (SELECT deptno, dname FROM dept where deptno between 30 and 50),
emp_temp as (Select ename, deptno from emp)
select * from dept_temp inner join emp_temp on dept_temp.deptno = emp_temp.deptno;
# Not using !ok: query involves join with non-deterministic row ordering.
LogicalProject(DEPTNO=[$0], DNAME=[$1], ENAME=[$2], DEPTNO0=[$3])
  LogicalJoin(condition=[=($0, $3)], joinType=[inner])
    LogicalProject(DEPTNO=[$0], DNAME=[$1])
      LogicalFilter(condition=[AND(>=($0, 30), <=($0, 50))])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
    LogicalProject(ENAME=[$1], DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$0], DNAME=[$1], ENAME=[$2], DEPTNO0=[$3])
  LogicalJoin(condition=[=($0, $3)], joinType=[inner])
    LogicalProject(DEPTNO=[$0], DNAME=[$1])
      LogicalFilter(condition=[AND(>=($0, 30), <=($0, 50))])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
    LogicalFilter(condition=[SEARCH($1, Sarg[[30..50]])])
      LogicalProject(ENAME=[$1], DEPTNO=[$7])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testJoinPushTransitivePredicatesNullabilityIssue -----------------------------
# Tests that JOIN_PUSH_TRANSITIVE_PREDICATES handles nullable columns correctly
# [CALCITE-5387]
# and does not produce incorrect predicates when null columns are involved.

WITH
non_null_table AS (
  SELECT DATE '2023-08-07' AS date_col_non_null FROM dept
),
null_table AS (
  SELECT CAST(null as DATE) AS date_col_null FROM dept
)
SELECT *
FROM non_null_table
JOIN null_table
ON null_table.date_col_null = non_null_table.date_col_non_null;
# Not using !ok: query uses CTEs with constant date values; plan transformation is the focus.
LogicalProject(DATE_COL_NON_NULL=[$0], DATE_COL_NULL=[$1])
  LogicalJoin(condition=[=($1, $0)], joinType=[inner])
    LogicalProject(DATE_COL_NON_NULL=[2023-08-07])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
    LogicalProject(DATE_COL_NULL=[null:DATE])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DATE_COL_NON_NULL=[$0], DATE_COL_NULL=[$1])
  LogicalJoin(condition=[=($1, $0)], joinType=[inner])
    LogicalValues(tuples=[[]])
    LogicalFilter(condition=[=($0, 2023-08-07)])
      LogicalProject(DATE_COL_NULL=[null:DATE])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceAggregate ---------------------------------------------
# Tests that transitive predicates are inferred and pushed through an Aggregate.

select 1 from (select deptno, count(*) from sales.emp where deptno > 7
group by deptno) d inner join sales.emp e on d.deptno = e.deptno;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($0, $9)], joinType=[inner])
    LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
      LogicalProject(DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 7)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($0, $9)], joinType=[inner])
    LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
      LogicalProject(DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 7)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[>($7, 7)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceComplexPredicate --------------------------------------
# Tests that only the simple component of a complex predicate is inferred and
# pushed; non-transferable sub-expressions are not propagated.

select 1 from sales.emp d
inner join sales.emp e on d.deptno = e.deptno
where d.deptno > 7 and e.sal = e.deptno and d.comm = d.deptno
and d.comm + d.deptno > d.comm/2;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalFilter(condition=[AND(>($7, 7), =($6, $7), >(+($6, $7), /($6, 2)))])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[=($5, $7)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalFilter(condition=[AND(>($7, 7), =($6, $7), >(+($6, $7), /($6, 2)))])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[>($7, 7)])
      LogicalFilter(condition=[=($5, $7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceConjunctInPullUp --------------------------------------
# Tests that a conjunct with multiple IN/OR conditions is correctly inferred
# and pushed to the other side of the join.

select 1 from sales.emp d
inner join sales.emp e on d.deptno = e.deptno
where d.deptno in (7, 9) or d.deptno > 10;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalFilter(condition=[SEARCH($7, Sarg[7, 9, (10..+∞)])])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalFilter(condition=[SEARCH($7, Sarg[7, 9, (10..+∞)])])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[SEARCH($7, Sarg[7, 9, (10..+∞)])])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceConstantEquiPredicate ---------------------------------
# Tests that a constant equi-predicate (1 = 1) does not trigger transitive
# inference (plan is unchanged).

select 1 from sales.emp d
inner join sales.emp e on d.deptno = e.deptno where 1 = 1;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceFullOuterJoin -----------------------------------------
# Tests that transitive predicates are NOT pushed through a full outer join
# (plan is unchanged).

select 1 from sales.emp d full outer join sales.emp e
on d.deptno = e.deptno where d.deptno > 7 and e.deptno > 9;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalFilter(condition=[AND(>($7, 7), >($16, 9))])
    LogicalJoin(condition=[=($7, $16)], joinType=[full])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalFilter(condition=[AND(>($7, 7), >($16, 9))])
    LogicalJoin(condition=[=($7, $16)], joinType=[full])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceJoin --------------------------------------------------
# Tests that a filter predicate on one side of a join is inferred and pushed to
# the other side.

select 1 from sales.emp d
inner join sales.emp e on d.deptno = e.deptno where e.deptno > 7;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[>($7, 7)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalFilter(condition=[>($7, 7)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[>($7, 7)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceJoin3way ----------------------------------------------
# Tests that transitive predicates are inferred and pushed across a three-way
# join, propagating predicates to all three tables.

select 1 from sales.emp d
inner join sales.emp e on d.deptno = e.deptno
inner join sales.emp f on e.deptno = f.deptno
where d.deptno > 7;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($16, $25)], joinType=[inner])
    LogicalJoin(condition=[=($7, $16)], joinType=[inner])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($16, $25)], joinType=[inner])
    LogicalJoin(condition=[=($7, $16)], joinType=[inner])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[>($7, 7)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceJoin3wayAgg -------------------------------------------
# Tests that transitive predicates from an Aggregate are inferred and pushed
# across a three-way join.

select 1 from
(select deptno, count(*) from sales.emp where deptno > 7 group by deptno) d
inner join sales.emp e on d.deptno = e.deptno
inner join sales.emp f on e.deptno = f.deptno;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($9, $18)], joinType=[inner])
    LogicalJoin(condition=[=($0, $9)], joinType=[inner])
      LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
        LogicalProject(DEPTNO=[$7])
          LogicalFilter(condition=[>($7, 7)])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($9, $18)], joinType=[inner])
    LogicalJoin(condition=[=($0, $9)], joinType=[inner])
      LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
        LogicalProject(DEPTNO=[$7])
          LogicalFilter(condition=[>($7, 7)])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[>($7, 7)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceJoinUsingStar -----------------------------------------
# [CALCITE-2274] Tests that filter predicates are inferred while using a
# dynamic star (*) in a subquery.

SELECT * FROM sales.emp d JOIN
(SELECT * FROM sales.emp WHERE deptno = 4) e
ON e.deptno = d.deptno;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], EMPNO0=[$9], ENAME0=[$10], JOB0=[$11], MGR0=[$12], HIREDATE0=[$13], SAL0=[$14], COMM0=[$15], DEPTNO0=[$16], SLACKER0=[$17])
  LogicalJoin(condition=[=($16, $7)], joinType=[inner])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
      LogicalFilter(condition=[=($7, 4)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], EMPNO0=[$9], ENAME0=[$10], JOB0=[$11], MGR0=[$12], HIREDATE0=[$13], SAL0=[$14], COMM0=[$15], DEPTNO0=[$16], SLACKER0=[$17])
  LogicalJoin(condition=[=($16, $7)], joinType=[inner])
    LogicalFilter(condition=[=($7, 4)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
      LogicalFilter(condition=[=($7, 4)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceLeftOuterJoin -----------------------------------------
# Tests that transitive predicates from the left side of a left outer join are
# inferred and pushed to the right side.

select 1 from sales.emp d
left outer join sales.emp e on d.deptno = e.deptno
where d.deptno > 7 and e.deptno > 9;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalFilter(condition=[>($16, 9)])
    LogicalJoin(condition=[=($7, $16)], joinType=[left])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalFilter(condition=[>($16, 9)])
    LogicalJoin(condition=[=($7, $16)], joinType=[left])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceNoPullUpExprs -----------------------------------------
# Tests that no predicate is inferred when the filter condition mixes columns
# (making pull-up impossible).

select 1 from sales.emp d
inner join sales.emp e on d.deptno = e.deptno
where d.deptno in (7, 9) or d.comm > 10;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalFilter(condition=[OR(SEARCH($7, Sarg[7, 9]), >($6, 10))])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalFilter(condition=[OR(SEARCH($7, Sarg[7, 9]), >($6, 10))])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferencePreventProjectPullUp ----------------------------------
# Tests that transitive inference is prevented when the Project renames a column
# (comm -> deptno), making it impossible to pull up the predicate.

select 1 from (select comm as deptno from sales.emp where deptno > 7) d
inner join sales.emp e on d.deptno = e.deptno;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($0, $8)], joinType=[inner])
    LogicalProject(DEPTNO=[$6])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($0, $8)], joinType=[inner])
    LogicalProject(DEPTNO=[$6])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceProject -----------------------------------------------
# Tests that a filter predicate below a Project is inferred and pushed to the
# other side of the join.

select 1 from (select * from sales.emp where deptno > 7) d
inner join sales.emp e on d.deptno = e.deptno;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($7, $16)], joinType=[inner])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
      LogicalFilter(condition=[>($7, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[>($7, 7)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferencePullUpThruAlias ---------------------------------------
# Tests that a predicate on an aliased column (comm aliased as deptno) is
# correctly pulled up and inferred on the other side of the join.

select 1 from (select comm as deptno from sales.emp where comm > 7) d
inner join sales.emp e on d.deptno = e.deptno;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($0, $8)], joinType=[inner])
    LogicalProject(DEPTNO=[$6])
      LogicalFilter(condition=[>($6, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($0, $8)], joinType=[inner])
    LogicalProject(DEPTNO=[$6])
      LogicalFilter(condition=[>($6, 7)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[>($7, 7)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceRightOuterJoin ----------------------------------------
# Tests that transitive predicates from the right side of a right outer join
# are inferred and pushed to the left side.

select 1 from sales.emp d
right outer join sales.emp e on d.deptno = e.deptno
where d.deptno > 7 and e.deptno > 9;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalFilter(condition=[>($7, 7)])
    LogicalJoin(condition=[=($7, $16)], joinType=[right])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalFilter(condition=[>($7, 9)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalFilter(condition=[>($7, 7)])
    LogicalJoin(condition=[=($7, $16)], joinType=[right])
      LogicalFilter(condition=[>($7, 9)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalFilter(condition=[>($7, 9)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceUnion -------------------------------------------------
# Tests that transitive predicates are inferred from a union subquery and pushed
# to the other side of the join.

select 1 from
(select deptno from sales.emp where deptno > 7
union all select deptno from sales.emp where deptno > 10) d
inner join sales.emp e on d.deptno = e.deptno;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($0, $8)], joinType=[inner])
    LogicalUnion(all=[true])
      LogicalProject(DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 7)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 10)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($0, $8)], joinType=[inner])
    LogicalUnion(all=[true])
      LogicalProject(DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 7)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 10)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[>($7, 7)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceUnion3way ---------------------------------------------
# Tests that transitive predicates are inferred from a three-way union subquery
# and pushed to the other side of the join (using the weakest predicate).

select 1 from
(select deptno from sales.emp where deptno > 7
union all
select deptno from sales.emp where deptno > 10
union all
select deptno from sales.emp where deptno > 1) d
inner join sales.emp e on d.deptno = e.deptno;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($0, $8)], joinType=[inner])
    LogicalUnion(all=[true])
      LogicalUnion(all=[true])
        LogicalProject(DEPTNO=[$7])
          LogicalFilter(condition=[>($7, 7)])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(DEPTNO=[$7])
          LogicalFilter(condition=[>($7, 10)])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 1)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($0, $8)], joinType=[inner])
    LogicalUnion(all=[true])
      LogicalUnion(all=[true])
        LogicalProject(DEPTNO=[$7])
          LogicalFilter(condition=[>($7, 7)])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(DEPTNO=[$7])
          LogicalFilter(condition=[>($7, 10)])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 1)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[>($7, 1)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceUnion3wayOr -------------------------------------------
# Tests that transitive inference is not applied when the union subquery
# contains OR conditions with non-uniform predicates (plan is unchanged).

select 1 from
(select empno, deptno from sales.emp where deptno > 7 or empno < 10
union all
select empno, deptno from sales.emp where deptno > 10 or empno < deptno
union all
select empno, deptno from sales.emp where deptno > 1) d
inner join sales.emp e on d.deptno = e.deptno;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($1, $9)], joinType=[inner])
    LogicalUnion(all=[true])
      LogicalUnion(all=[true])
        LogicalProject(EMPNO=[$0], DEPTNO=[$7])
          LogicalFilter(condition=[OR(>($7, 7), <($0, 10))])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(EMPNO=[$0], DEPTNO=[$7])
          LogicalFilter(condition=[OR(>($7, 10), <($0, $7))])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(EMPNO=[$0], DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 1)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(EXPR$0=[1])
  LogicalJoin(condition=[=($1, $9)], joinType=[inner])
    LogicalUnion(all=[true])
      LogicalUnion(all=[true])
        LogicalProject(EMPNO=[$0], DEPTNO=[$7])
          LogicalFilter(condition=[OR(>($7, 7), <($0, 10))])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(EMPNO=[$0], DEPTNO=[$7])
          LogicalFilter(condition=[OR(>($7, 10), <($0, $7))])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(EMPNO=[$0], DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 1)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# testTransitiveInferenceUnionAlwaysTrue ---------------------------------------
# [CALCITE-443] Tests that when one arm of a UNION has no filter, the inferred
# predicate from the other side of the join is pushed correctly.

select d.deptno, e.deptno from
(select deptno from sales.emp where deptno < 4) d
inner join
(select deptno from sales.emp where deptno > 7
union all select deptno from sales.emp) e
on d.deptno = e.deptno;
# Not using !ok: query uses the sales schema, which is not in the scott database.
LogicalProject(DEPTNO=[$0], DEPTNO0=[$1])
  LogicalJoin(condition=[=($0, $1)], joinType=[inner])
    LogicalProject(DEPTNO=[$7])
      LogicalFilter(condition=[<($7, 4)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalUnion(all=[true])
      LogicalProject(DEPTNO=[$7])
        LogicalFilter(condition=[>($7, 7)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalProject(DEPTNO=[$7])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE"
LogicalProject(DEPTNO=[$0], DEPTNO0=[$1])
  LogicalJoin(condition=[=($0, $1)], joinType=[inner])
    LogicalProject(DEPTNO=[$7])
      LogicalFilter(condition=[<($7, 4)])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalFilter(condition=[<($0, 4)])
      LogicalUnion(all=[true])
        LogicalProject(DEPTNO=[$7])
          LogicalFilter(condition=[>($7, 7)])
            LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(DEPTNO=[$7])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_INTO_JOIN_DUMB, JOIN_CONDITION_PUSH, FILTER_PROJECT_TRANSPOSE, FILTER_SET_OP_TRANSPOSE, JOIN_PUSH_TRANSITIVE_PREDICATES"

# End join-push-transitive-predicates.iq
