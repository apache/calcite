# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Tests planner rules related to filters, projects, and windows.
#
# Ensure that tests occur in alphabetical order:
# // lint: sort where '^[#] test'
#

!use scott
!set outputformat mysql

# testConstantWindow -----------------------------------------------------------
# PROJECT_WINDOW_TRANSPOSE should not push a Project past a Window when the
# Window has constant arguments.
# [CALCITE-6746]
# Not using !ok: this test focuses on plan transformation (see !sub-plan).

with empsalary(dept, empno, salary, enroll_date) as
(VALUES ('x', 10, 5200, DATE '2007-08-01'), (NULL, NULL, NULL, NULL))
select sum(salary)
OVER (order by enroll_date range between INTERVAL 365 DAYS preceding and
INTERVAL 365 DAYS following),
salary, enroll_date FROM empsalary;
LogicalProject(EXPR$0=[CASE(>($3, 0), $4, null:INTEGER)], SALARY=[$0], ENROLL_DATE=[$1])
  LogicalWindow(window#0=[window(order by [1] range between $2 PRECEDING and $2 FOLLOWING aggs [COUNT($0), SUM($0)])])
    LogicalProject(EXPR$2=[$2], EXPR$3=[$3], $2=[*(365, 86400000:INTERVAL DAY)])
      LogicalValues(tuples=[[{ 'x', 10, 5200, 2007-08-01 }, { null, null, null, null }]])
!sub-plan "NONE, PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW"
LogicalProject(EXPR$0=[CASE(>($3, 0), $4, null:INTEGER)], SALARY=[$0], ENROLL_DATE=[$1])
  LogicalWindow(window#0=[window(order by [1] range between $2 PRECEDING and $2 FOLLOWING aggs [COUNT($0), SUM($0)])])
    LogicalProject(EXPR$2=[$2], EXPR$3=[$3], $2=[*(365, 86400000:INTERVAL DAY)])
      LogicalValues(tuples=[[{ 'x', 10, 5200, 2007-08-01 }, { null, null, null, null }]])
!sub-plan "NONE, PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW, PROJECT_WINDOW_TRANSPOSE"

# testFilterTableFunctionScanTranspose -----------------------------------------
# FILTER_TABLE_FUNCTION_TRANSPOSE pushes a Filter past a TableFunctionScan.
# [CALCITE-5985]
# Not using !ok: table function cannot be executed in the scott database.

select * from table(tfrt(cursor(select dname from dept)))
where dname = '1';
LogicalProject(DNAME=[$0])
  LogicalFilter(condition=[=($0, '1')])
    LogicalTableFunctionScan(invocation=[TFRT(CAST($0):CURSOR NOT NULL)], rowType=[RecordType(VARCHAR(10) DNAME)])
      LogicalProject(DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DNAME=[$0])
  LogicalTableFunctionScan(invocation=[TFRT(CAST($0):CURSOR NOT NULL)], rowType=[RecordType(VARCHAR(10) DNAME)])
    LogicalFilter(condition=[=($0, '1')])
      LogicalProject(DNAME=[$1])
        LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, FILTER_TABLE_FUNCTION_TRANSPOSE"

# testNestedAggregates ---------------------------------------------------------
# PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW converts a windowed aggregate on top of
# a regular aggregate into a LogicalWindow.
# [CALCITE-750]
# Not using !ok: this test focuses on plan transformation (see !sub-plan).

SELECT
  avg(sum(sal) + 2 * min(empno) + 3 * avg(empno))
  over (partition by deptno)
from emp
group by deptno;
LogicalProject(EXPR$0=[CAST(/(SUM(+(+($1, *(2, $2)), *(3, $3))) OVER (PARTITION BY $0), COUNT(+(+($1, *(2, $2)), *(3, $3))) OVER (PARTITION BY $0))):INTEGER NOT NULL])
  LogicalAggregate(group=[{0}], agg#0=[SUM($1)], agg#1=[MIN($2)], agg#2=[AVG($2)])
    LogicalProject(DEPTNO=[$7], SAL=[$5], EMPNO=[$0])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[CAST(/($2, $3)):INTEGER NOT NULL])
  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1)])])
    LogicalProject(DEPTNO=[$0], $1=[+(+($1, *(2, $2)), *(3, $3))])
      LogicalAggregate(group=[{0}], agg#0=[SUM($1)], agg#1=[MIN($2)], agg#2=[AVG($2)])
        LogicalProject(DEPTNO=[$7], SAL=[$5], EMPNO=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW"

# testNestedConstantWindow -----------------------------------------------------
# PROJECT_WINDOW_TRANSPOSE should correctly adjust column indices in window
# bounds when the window has constant arguments.
# [CALCITE-7375]
# Not using !ok: this test focuses on plan transformation (see !sub-plan).

WITH t1 AS (
  SELECT *,
         FIRST_VALUE(deptno) OVER (
           ORDER BY empno
           ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING
         ) AS f1
  FROM emp
)
SELECT deptno,
       f1,
       LAST_VALUE(deptno) OVER (
         ORDER BY empno
         ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING
       ) AS f2
FROM t1;
LogicalProject(DEPTNO=[$1], F1=[$2], F2=[$3])
  LogicalWindow(window#0=[window(order by [0] rows between $3 PRECEDING and $4 FOLLOWING aggs [LAST_VALUE($1)])], constants=[[2, 1]])
    LogicalProject(EMPNO=[$0], DEPTNO=[$7], F1=[$9])
      LogicalWindow(window#0=[window(order by [0] rows between $9 PRECEDING and $10 FOLLOWING aggs [FIRST_VALUE($7)])], constants=[[2, 1]])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW"
LogicalProject(DEPTNO=[$1], F1=[$2], F2=[$3])
  LogicalWindow(window#0=[window(order by [0] rows between $3 PRECEDING and $4 FOLLOWING aggs [LAST_VALUE($1)])], constants=[[2, 1]])
    LogicalWindow(window#0=[window(order by [0] rows between $2 PRECEDING and $3 FOLLOWING aggs [FIRST_VALUE($1)])], constants=[[2, 1]])
      LogicalProject(EMPNO=[$0], DEPTNO=[$7])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW, PROJECT_WINDOW_TRANSPOSE"

# testProjectCorrelateTransposeWithOver ----------------------------------------
# PROJECT_CORRELATE_TRANSPOSE should not push a Project with windowed aggregates
# over a Correlate, but can push into the Correlate's inputs.
# Not using !ok: this test focuses on plan transformation (see !sub-plan).

select sum(t1.deptno + 1) over (partition by t1.dname),
count(t2.empno) over ()
from DEPT_NESTED as t1,
unnest(t1.employees) as t2;
LogicalProject(EXPR$0=[SUM(+($0, 1)) OVER (PARTITION BY $1)], EXPR$1=[COUNT($4) OVER ()])
  LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{3}])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT_NESTED]])
    Uncollect
      LogicalProject(EMPLOYEES=[$cor0.EMPLOYEES])
        LogicalValues(tuples=[[{ 0 }]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[SUM($2) OVER (PARTITION BY $0)], EXPR$1=[COUNT($3) OVER ()])
  LogicalCorrelate(correlation=[$cor1], joinType=[inner], requiredColumns=[{1}])
    LogicalProject(DNAME=[$1], EMPLOYEES=[$3], EXPR$0=[+($0, 1)])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT_NESTED]])
    LogicalProject(EMPNO=[$0])
      Uncollect
        LogicalProject(EMPLOYEES=[$cor1.EMPLOYEES])
          LogicalValues(tuples=[[{ 0 }]])
!sub-plan "NONE, PROJECT_CORRELATE_TRANSPOSE"

# testPushFilterWithRank -------------------------------------------------------
# FILTER_PROJECT_TRANSPOSE should not push a Filter past a Project that contains
# a window function (RANK).
# Not using !ok: this test focuses on plan transformation (see !sub-plan).

select e1.ename, r
from (
  select ename,   rank() over(partition by  deptno order by sal) as r   from emp) e1
where r < 2;
LogicalProject(ENAME=[$0], R=[$1])
  LogicalFilter(condition=[<($1, 2)])
    LogicalProject(ENAME=[$1], R=[RANK() OVER (PARTITION BY $7 ORDER BY $5)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(ENAME=[$0], R=[$1])
  LogicalFilter(condition=[<($1, 2)])
    LogicalProject(ENAME=[$1], R=[RANK() OVER (PARTITION BY $7 ORDER BY $5)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_PROJECT_TRANSPOSE"

# testPushFilterWithRankExpr ---------------------------------------------------
# FILTER_PROJECT_TRANSPOSE should not push a Filter past a Project that contains
# a window function expression (RANK + 1).
# Not using !ok: this test focuses on plan transformation (see !sub-plan).

select e1.ename, r
from (
  select ename,
  rank() over(partition by  deptno order by sal) + 1 as r   from emp) e1
where r < 2;
LogicalProject(ENAME=[$0], R=[$1])
  LogicalFilter(condition=[<($1, 2)])
    LogicalProject(ENAME=[$1], R=[+(RANK() OVER (PARTITION BY $7 ORDER BY $5), 1)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(ENAME=[$0], R=[$1])
  LogicalFilter(condition=[<($1, 2)])
    LogicalProject(ENAME=[$1], R=[+(RANK() OVER (PARTITION BY $7 ORDER BY $5), 1)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, FILTER_PROJECT_TRANSPOSE"

# testWindowFunctionOnAggregations ---------------------------------------------
# PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW converts a query with a window function
# applied to an aggregate result into a LogicalWindow.
# [CALCITE-2078]
# Not using !ok: this test focuses on plan transformation (see !sub-plan).

SELECT
  min(empno),
  sum(sal),
  sum(sum(sal))
    over (partition by min(empno) order by sum(sal))
from emp
group by deptno;
LogicalProject(EXPR$0=[$1], EXPR$1=[$2], EXPR$2=[SUM($2) OVER (PARTITION BY $1 ORDER BY $2)])
  LogicalAggregate(group=[{0}], EXPR$0=[MIN($1)], EXPR$1=[SUM($2)])
    LogicalProject(DEPTNO=[$7], EMPNO=[$0], SAL=[$5])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$2], EXPR$2=[$3])
  LogicalWindow(window#0=[window(partition {1} order by [2] aggs [SUM($2)])])
    LogicalAggregate(group=[{0}], EXPR$0=[MIN($1)], EXPR$1=[SUM($2)])
      LogicalProject(DEPTNO=[$7], EMPNO=[$0], SAL=[$5])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW"

# testWindowMissingConstantInDigest --------------------------------------------
# PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW correctly distinguishes windows with
# different constant values in their digest.
# [CALCITE-6632]
# Not using !ok: this test focuses on plan transformation (see !sub-plan).

select sum(100) over (partition by deptno order by sal) as s
from emp
union all
select sum(1000) over(partition by deptno order by sal) as s
from emp;
LogicalUnion(all=[true])
  LogicalProject(S=[SUM(100) OVER (PARTITION BY $7 ORDER BY $5)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(S=[SUM(1000) OVER (PARTITION BY $7 ORDER BY $5)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalUnion(all=[true])
  LogicalProject(S=[$2])
    LogicalWindow(window#0=[window(partition {1} order by [0] aggs [SUM($2)])], constants=[[100]])
      LogicalProject(SAL=[$5], DEPTNO=[$7])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(S=[$2])
    LogicalWindow(window#0=[window(partition {1} order by [0] aggs [SUM($2)])], constants=[[1000]])
      LogicalProject(SAL=[$5], DEPTNO=[$7])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW"

# End filter-project-transpose.iq
