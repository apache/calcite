# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Tests planner rules related to removing redundant joins in projections
# (PROJECT_JOIN_JOIN_REMOVE and PROJECT_JOIN_REMOVE rules).
#
# Ensure that tests occur in alphabetical order:
# // lint: sort where '^[#] test'
#

!use scott
!set outputformat mysql

# testProjectJoinRemove1 ------------------------------------------------------
# PROJECT_JOIN_JOIN_REMOVE should remove the second left join when d2 is a
# duplicate of d1.

SELECT e.deptno, d2.deptno
FROM emp e
LEFT JOIN dept d1 ON e.deptno = d1.deptno
LEFT JOIN dept d2 ON e.deptno = d2.deptno;
+--------+--------+
| DEPTNO | DEPTNO |
+--------+--------+
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
+--------+--------+
(14 rows)

!ok
LogicalProject(DEPTNO=[$7], DEPTNO0=[$11])
  LogicalJoin(condition=[=($7, $11)], joinType=[left])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$7], DEPTNO0=[$9])
  LogicalJoin(condition=[=($7, $9)], joinType=[left])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, PROJECT_JOIN_JOIN_REMOVE"

# testProjectJoinRemove10 -----------------------------------------------------
# PROJECT_JOIN_REMOVE should remove the left join when all projected columns
# come from the left (non-null-generating) side.

SELECT e.deptno, e.slacker
FROM emp e
LEFT JOIN dept d ON e.deptno = d.deptno;
java.sql.SQLException: Error while executing SQL "SELECT e.deptno, e.slacker
FROM emp e
LEFT JOIN dept d ON e.deptno = d.deptno": From line 1, column 20 to line 1, column 26: Column 'SLACKER' not found in table 'E'
	at org.apache.calcite.avatica.Helper.createException(Helper.java:56)
	at org.apache.calcite.avatica.Helper.createException(Helper.java:41)
	at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:164)
	at org.apache.calcite.avatica.AvaticaStatement.executeQuery(AvaticaStatement.java:228)
	at net.hydromatic.quidem.Quidem.checkResult(Quidem.java:317)
	at net.hydromatic.quidem.Quidem.access$2600(Quidem.java:54)
	at net.hydromatic.quidem.Quidem$ContextImpl.checkResult(Quidem.java:1778)
	at net.hydromatic.quidem.Quidem$CheckResultCommand.execute(Quidem.java:985)
	at net.hydromatic.quidem.Quidem$CompositeCommand.execute(Quidem.java:1522)
	at net.hydromatic.quidem.Quidem.execute(Quidem.java:204)
	at org.apache.calcite.test.QuidemTest.checkRun(QuidemTest.java:540)
	at org.apache.calcite.test.QuidemTest.test(QuidemTest.java:730)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.SameThreadTimeoutInvocation.proceed(SameThreadTimeoutInvocation.java:45)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestTemplateMethod(TimeoutExtension.java:94)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:217)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:213)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:138)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.submit(ForkJoinPoolHierarchicalTestExecutorService.java:118)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:226)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:204)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:142)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.lambda$execute$2(TestTemplateTestDescriptor.java:110)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:762)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:1024)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:110)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:44)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:129)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:129)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at java.base/java.util.concurrent.RecursiveAction.exec(RecursiveAction.java:194)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:387)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1310)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1841)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1806)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:188)
Caused by: org.apache.calcite.runtime.CalciteContextException: From line 1, column 20 to line 1, column 26: Column 'SLACKER' not found in table 'E'
	at java.base/jdk.internal.reflect.DirectConstructorHandleAccessor.newInstance(DirectConstructorHandleAccessor.java:62)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:502)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:486)
	at org.apache.calcite.runtime.Resources$ExInstWithCause.ex(Resources.java:511)
	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:960)
	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:945)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.newValidationError(SqlValidatorImpl.java:6151)
	at org.apache.calcite.sql.validate.DelegatingScope.fullyQualify(DelegatingScope.java:473)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$Expander.visit(SqlValidatorImpl.java:7389)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$SelectExpander.visit(SqlValidatorImpl.java:7730)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$SelectExpander.visit(SqlValidatorImpl.java:7682)
	at org.apache.calcite.sql.SqlIdentifier.accept(SqlIdentifier.java:324)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$Expander.go(SqlValidatorImpl.java:7354)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$SelectExpander.go(SqlValidatorImpl.java:7721)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.expandSelectExpr(SqlValidatorImpl.java:6917)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.expandSelectItem(SqlValidatorImpl.java:490)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateSelectList(SqlValidatorImpl.java:5268)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateSelect(SqlValidatorImpl.java:4260)
	at org.apache.calcite.sql.validate.SelectNamespace.validateImpl(SelectNamespace.java:62)
	at org.apache.calcite.sql.validate.AbstractNamespace.validate(AbstractNamespace.java:96)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateNamespace(SqlValidatorImpl.java:1304)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateQuery(SqlValidatorImpl.java:1275)
	at org.apache.calcite.sql.SqlSelect.validate(SqlSelect.java:292)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateScopedExpression(SqlValidatorImpl.java:1241)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validate(SqlValidatorImpl.java:947)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertQuery(SqlToRelConverter.java:628)
	at org.apache.calcite.prepare.Prepare.prepareSql(Prepare.java:258)
	at org.apache.calcite.prepare.Prepare.prepareSql(Prepare.java:221)
	at org.apache.calcite.prepare.CalcitePrepareImpl.prepare2_(CalcitePrepareImpl.java:675)
	at org.apache.calcite.prepare.CalcitePrepareImpl.prepare_(CalcitePrepareImpl.java:526)
	at org.apache.calcite.prepare.CalcitePrepareImpl.prepareSql(CalcitePrepareImpl.java:494)
	at org.apache.calcite.jdbc.CalciteConnectionImpl.parseQuery(CalciteConnectionImpl.java:246)
	at org.apache.calcite.jdbc.CalciteMetaImpl.prepareAndExecute(CalciteMetaImpl.java:654)
	at org.apache.calcite.avatica.AvaticaConnection.prepareAndExecuteInternal(AvaticaConnection.java:677)
	at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:157)
	... 123 more
Caused by: org.apache.calcite.sql.validate.SqlValidatorException: Column 'SLACKER' not found in table 'E'
	at java.base/jdk.internal.reflect.DirectConstructorHandleAccessor.newInstance(Dire (stack truncated)
!ok
LogicalProject(DEPTNO=[$7], SLACKER=[$8])
  LogicalJoin(condition=[=($7, $9)], joinType=[left])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$7], SLACKER=[$8])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_JOIN_REMOVE"

# testProjectJoinRemove2 ------------------------------------------------------
# PROJECT_JOIN_JOIN_REMOVE should not remove d2 when the project references d1.

SELECT e.deptno, d1.deptno
FROM emp e
LEFT JOIN dept d1 ON e.deptno = d1.deptno
LEFT JOIN dept d2 ON e.deptno = d2.deptno;
+--------+--------+
| DEPTNO | DEPTNO |
+--------+--------+
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
+--------+--------+
(14 rows)

!ok
LogicalProject(DEPTNO=[$7], DEPTNO0=[$9])
  LogicalJoin(condition=[=($7, $11)], joinType=[left])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$7], DEPTNO0=[$9])
  LogicalJoin(condition=[=($7, $11)], joinType=[left])
    LogicalJoin(condition=[=($7, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, PROJECT_JOIN_JOIN_REMOVE"

# testProjectJoinRemove3 ------------------------------------------------------
# PROJECT_JOIN_JOIN_REMOVE should not remove a join when the tables differ.

SELECT e1.deptno, d.deptno
FROM emp e1
LEFT JOIN emp e2 ON e1.deptno = e2.deptno
LEFT JOIN dept d ON e1.deptno = d.deptno;
+--------+--------+
| DEPTNO | DEPTNO |
+--------+--------+
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
|     10 |     10 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     20 |     20 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
|     30 |     30 |
+--------+--------+
(70 rows)

!ok
LogicalProject(DEPTNO=[$7], DEPTNO0=[$18])
  LogicalJoin(condition=[=($7, $18)], joinType=[left])
    LogicalJoin(condition=[=($7, $16)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$7], DEPTNO0=[$18])
  LogicalJoin(condition=[=($7, $18)], joinType=[left])
    LogicalJoin(condition=[=($7, $16)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, PROJECT_JOIN_JOIN_REMOVE"

# testProjectJoinRemove4 ------------------------------------------------------
# PROJECT_JOIN_REMOVE should remove the left join when the project only uses
# columns from the preserved side.

SELECT e.deptno
FROM emp e
LEFT JOIN dept d ON e.deptno = d.deptno;
+--------+
| DEPTNO |
+--------+
|     10 |
|     10 |
|     10 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
+--------+
(14 rows)

!ok
LogicalProject(DEPTNO=[$7])
  LogicalJoin(condition=[=($7, $9)], joinType=[left])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$7])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_JOIN_REMOVE"

# testProjectJoinRemove5 ------------------------------------------------------
# PROJECT_JOIN_REMOVE should not remove the join when EMP.DEPTNO is not a
# unique key.

SELECT e1.deptno
FROM emp e1
LEFT JOIN emp e2 ON e1.deptno = e2.deptno;
+--------+
| DEPTNO |
+--------+
|     10 |
|     10 |
|     10 |
|     10 |
|     10 |
|     10 |
|     10 |
|     10 |
|     10 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
+--------+
(70 rows)

!ok
LogicalProject(DEPTNO=[$7])
  LogicalJoin(condition=[=($7, $16)], joinType=[left])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$7])
  LogicalJoin(condition=[=($7, $16)], joinType=[left])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_JOIN_REMOVE"

# testProjectJoinRemove6 ------------------------------------------------------
# PROJECT_JOIN_REMOVE should not remove the join when the project uses
# a column from the null-generating side.

SELECT e.deptno, d.dname
FROM emp e
LEFT JOIN dept d ON e.deptno = d.deptno;
+--------+------------+
| DEPTNO | DNAME      |
+--------+------------+
|     10 | ACCOUNTING |
|     10 | ACCOUNTING |
|     10 | ACCOUNTING |
|     20 | RESEARCH   |
|     20 | RESEARCH   |
|     20 | RESEARCH   |
|     20 | RESEARCH   |
|     20 | RESEARCH   |
|     30 | SALES      |
|     30 | SALES      |
|     30 | SALES      |
|     30 | SALES      |
|     30 | SALES      |
|     30 | SALES      |
+--------+------------+
(14 rows)

!ok
LogicalProject(DEPTNO=[$7], DNAME=[$10])
  LogicalJoin(condition=[=($7, $9)], joinType=[left])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$7], DNAME=[$10])
  LogicalJoin(condition=[=($7, $9)], joinType=[left])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, PROJECT_JOIN_REMOVE"

# testProjectJoinRemove7 ------------------------------------------------------
# PROJECT_JOIN_REMOVE should remove a right join when the project only uses
# columns from the preserved (right) side.

SELECT e.deptno
FROM dept d
RIGHT JOIN emp e ON e.deptno = d.deptno;
+--------+
| DEPTNO |
+--------+
|     10 |
|     10 |
|     10 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
+--------+
(14 rows)

!ok
LogicalProject(DEPTNO=[$9])
  LogicalJoin(condition=[=($9, $0)], joinType=[right])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$7])
  LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_JOIN_REMOVE"

# testProjectJoinRemove8 ------------------------------------------------------
# PROJECT_JOIN_REMOVE should not remove a right join when EMP.DEPTNO is not a
# unique key.

SELECT e2.deptno
FROM emp e1
RIGHT JOIN emp e2 ON e1.deptno = e2.deptno;
+--------+
| DEPTNO |
+--------+
|     10 |
|     10 |
|     10 |
|     10 |
|     10 |
|     10 |
|     10 |
|     10 |
|     10 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     20 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
|     30 |
+--------+
(70 rows)

!ok
LogicalProject(DEPTNO=[$16])
  LogicalJoin(condition=[=($7, $16)], joinType=[right])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$16])
  LogicalJoin(condition=[=($7, $16)], joinType=[right])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_JOIN_REMOVE"

# testProjectJoinRemove9 ------------------------------------------------------
# PROJECT_JOIN_REMOVE should not remove a right join when the project uses
# a column from the null-generating (left) side.

SELECT e.deptno, d.dname
FROM dept d
RIGHT JOIN emp e ON e.deptno = d.deptno;
+--------+------------+
| DEPTNO | DNAME      |
+--------+------------+
|     10 | ACCOUNTING |
|     10 | ACCOUNTING |
|     10 | ACCOUNTING |
|     20 | RESEARCH   |
|     20 | RESEARCH   |
|     20 | RESEARCH   |
|     20 | RESEARCH   |
|     20 | RESEARCH   |
|     30 | SALES      |
|     30 | SALES      |
|     30 | SALES      |
|     30 | SALES      |
|     30 | SALES      |
|     30 | SALES      |
+--------+------------+
(14 rows)

!ok
LogicalProject(DEPTNO=[$9], DNAME=[$1])
  LogicalJoin(condition=[=($9, $0)], joinType=[right])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(DEPTNO=[$9], DNAME=[$1])
  LogicalJoin(condition=[=($9, $0)], joinType=[right])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_JOIN_REMOVE"

# End project-join-remove.iq
