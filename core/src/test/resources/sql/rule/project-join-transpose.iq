# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Tests for rules related to pushing projects through joins and set-ops
# (PROJECT_JOIN_TRANSPOSE, PROJECT_SET_OP_TRANSPOSE, PROJECT_FILTER_TRANSPOSE,
# PROJECT_MERGE rules).
#
# Ensure that tests occur in alphabetical order:
# // lint: sort where '^[#] test'
#

!use scott
!set outputformat mysql

# testProjectMergeRuleWithCorrelation -----------------------------------------
# [CALCITE-7395] ProjectMergeRule incorrectly merges PROJECTs with correlation
# variables.

SELECT ARRAY(SELECT y + 1 FROM UNNEST(s.x) y)
FROM (SELECT ARRAY[1,2,3] as x) s;
# Not using !ok: query uses ARRAY constructor not supported in the scott database.

LogicalProject(variablesSet=[[$cor0]], EXPR$0=[ARRAY({
LogicalProject(EXPR$0=[+($0, 1)])
  Uncollect
    LogicalProject(X=[$cor0.X])
      LogicalValues(tuples=[[{ 0 }]])
})])
  LogicalProject(X=[ARRAY(1, 2, 3)])
    LogicalValues(tuples=[[{ 0 }]])
!sub-plan "NONE"
LogicalProject(variablesSet=[[$cor0]], EXPR$0=[ARRAY({
LogicalProject(EXPR$0=[+($0, 1)])
  Uncollect
    LogicalProject(X=[$cor0.X])
      LogicalValues(tuples=[[{ 0 }]])
})])
  LogicalProject(X=[ARRAY(1, 2, 3)])
    LogicalValues(tuples=[[{ 0 }]])
!sub-plan "NONE, PROJECT_MERGE"

# testProjectMergeShouldIgnoreOver --------------------------------------------
# PROJECT_MERGE should not merge a Project over a Project that contains OVER
# (window function), as that would nest an OVER inside an OVER.

select row_number() over (order by deptno), col1
from (
  select deptno,
    sum(100) over (partition by  deptno order by sal) as col1
  from emp);
# Not using !ok: query uses window functions whose results are not verified here.

LogicalProject(EXPR$0=[ROW_NUMBER() OVER (ORDER BY $0)], COL1=[$1])
  LogicalProject(DEPTNO=[$7], COL1=[SUM(100) OVER (PARTITION BY $7 ORDER BY $5)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[ROW_NUMBER() OVER (ORDER BY $0)], COL1=[$1])
  LogicalProject(DEPTNO=[$7], COL1=[SUM(100) OVER (PARTITION BY $7 ORDER BY $5)])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_MERGE"

# testProjectSetOpTranspose ---------------------------------------------------
# [CALCITE-3004] Should not push over past union but its operands can since
# setop will affect row count.

select job, sum(sal + 100) over (partition by deptno) from
(select * from emp e1 union all select * from emp e2);
# Not using !ok: query uses window functions whose results are not verified here.

LogicalProject(JOB=[$2], EXPR$1=[SUM(+($5, 100)) OVER (PARTITION BY $7)])
  LogicalUnion(all=[true])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(JOB=[$0], EXPR$1=[SUM($2) OVER (PARTITION BY $1)])
  LogicalUnion(all=[true])
    LogicalProject(JOB=[$2], DEPTNO=[$7], EXPR$0=[+($5, 100)])
      LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(JOB=[$2], DEPTNO=[$7], EXPR$0=[+($5, 100)])
      LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_SET_OP_TRANSPOSE"

# testPushProjectPastFilter ---------------------------------------------------
# PROJECT_FILTER_TRANSPOSE pushes a Project through a Filter.

select empno + deptno from emp where sal = 10 * comm
and upper(ename) = 'FOO';
+--------+
| EXPR$0 |
+--------+
+--------+
(0 rows)

!ok
LogicalProject(EXPR$0=[+($0, $7)])
  LogicalFilter(condition=[AND(=($5, *(10, $6)), =(UPPER($1), 'FOO'))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[+($0, $4)])
  LogicalFilter(condition=[AND(=($2, *(10, $3)), =(UPPER($1), 'FOO'))])
    LogicalProject(EMPNO=[$0], ENAME=[$1], SAL=[$5], COMM=[$6], DEPTNO=[$7])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE"

# testPushProjectPastFilter2 --------------------------------------------------
# [CALCITE-1778] Query with "WHERE CASE" throws AssertionError "Cast for just
# nullability not allowed".

select count(*)
from emp
where case when mgr < 10 then true else false end;
+--------+
| EXPR$0 |
+--------+
|      0 |
+--------+
(1 row)

!ok
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[0])
    LogicalFilter(condition=[CASE(<($3, 10), true, false)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[0])
    LogicalFilter(condition=[<($0, 10)])
      LogicalProject(MGR=[$3])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE"

# testPushProjectPastFilter3 --------------------------------------------------
# [CALCITE-3975] ProjectFilterTransposeRule should succeed for project that
# happens to reference all input columns.

select empno + deptno as x, ename, job, mgr,
  hiredate, sal, comm, slacker
from emp
where sal = 10 * comm
and upper(ename) = 'FOO';
java.sql.SQLException: Error while executing SQL "select empno + deptno as x, ename, job, mgr,
  hiredate, sal, comm, slacker
from emp
where sal = 10 * comm
and upper(ename) = 'FOO'": From line 2, column 24 to line 2, column 30: Column 'SLACKER' not found in any table
	at org.apache.calcite.avatica.Helper.createException(Helper.java:56)
	at org.apache.calcite.avatica.Helper.createException(Helper.java:41)
	at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:164)
	at org.apache.calcite.avatica.AvaticaStatement.executeQuery(AvaticaStatement.java:228)
	at net.hydromatic.quidem.Quidem.checkResult(Quidem.java:317)
	at net.hydromatic.quidem.Quidem.access$2600(Quidem.java:54)
	at net.hydromatic.quidem.Quidem$ContextImpl.checkResult(Quidem.java:1778)
	at net.hydromatic.quidem.Quidem$CheckResultCommand.execute(Quidem.java:985)
	at net.hydromatic.quidem.Quidem$CompositeCommand.execute(Quidem.java:1522)
	at net.hydromatic.quidem.Quidem.execute(Quidem.java:204)
	at org.apache.calcite.test.QuidemTest.checkRun(QuidemTest.java:540)
	at org.apache.calcite.test.QuidemTest.test(QuidemTest.java:730)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.SameThreadTimeoutInvocation.proceed(SameThreadTimeoutInvocation.java:45)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestTemplateMethod(TimeoutExtension.java:94)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:217)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:213)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:138)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.submit(ForkJoinPoolHierarchicalTestExecutorService.java:118)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:226)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:204)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:142)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.lambda$execute$2(TestTemplateTestDescriptor.java:110)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:762)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:1024)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1708)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:110)
	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:44)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:129)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:129)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:185)
	at java.base/java.util.concurrent.RecursiveAction.exec(RecursiveAction.java:194)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:387)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1310)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1841)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1806)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:188)
Caused by: org.apache.calcite.runtime.CalciteContextException: From line 2, column 24 to line 2, column 30: Column 'SLACKER' not found in any table
	at java.base/jdk.internal.reflect.DirectConstructorHandleAccessor.newInstance(DirectConstructorHandleAccessor.java:62)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:502)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:486)
	at org.apache.calcite.runtime.Resources$ExInstWithCause.ex(Resources.java:511)
	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:960)
	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:945)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.newValidationError(SqlValidatorImpl.java:6151)
	at org.apache.calcite.sql.validate.DelegatingScope.fullyQualify(DelegatingScope.java:293)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$Expander.visit(SqlValidatorImpl.java:7389)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$SelectExpander.visit(SqlValidatorImpl.java:7730)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$SelectExpander.visit(SqlValidatorImpl.java:7682)
	at org.apache.calcite.sql.SqlIdentifier.accept(SqlIdentifier.java:324)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$Expander.go(SqlValidatorImpl.java:7354)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$SelectExpander.go(SqlValidatorImpl.java:7721)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.expandSelectExpr(SqlValidatorImpl.java:6917)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.expandSelectItem(SqlValidatorImpl.java:490)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateSelectList(SqlValidatorImpl.java:5268)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateSelect(SqlValidatorImpl.java:4260)
	at org.apache.calcite.sql.validate.SelectNamespace.validateImpl(SelectNamespace.java:62)
	at org.apache.calcite.sql.validate.AbstractNamespace.validate(AbstractNamespace.java:96)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateNamespace(SqlValidatorImpl.java:1304)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateQuery(SqlValidatorImpl.java:1275)
	at org.apache.calcite.sql.SqlSelect.validate(SqlSelect.java:292)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateScopedExpression(SqlValidatorImpl.java:1241)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validate(SqlValidatorImpl.java:947)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertQuery(SqlToRelConverter.java:628)
	at org.apache.calcite.prepare.Prepare.prepareSql(Prepare.java:258)
	at org.apache.calcite.prepare.Prepare.prepareSql(Prepare.java:221)
	at org.apache.calcite.prepare.CalcitePrepareImpl.prepare2_(CalcitePrepareImpl.java:675)
	at org.apache.calcite.prepare.CalcitePrepareImpl.prepare_(CalcitePrepareImpl.java:526)
	at org.apache.calcite.prepare.CalcitePrepareImpl.prepareSql(CalcitePrepareImpl.java:494)
	at org.apache.calcite.jdbc.CalciteConnectionImpl.parseQuery(CalciteConnectionImpl.java:246)
	at org.apache.calcite.jdbc.CalciteMetaImpl.prepareAndExecute(CalciteMetaImpl.java:654)
	at org.apache.calcite.avatica.AvaticaConnection.prepareAndExecuteInternal(AvaticaConnection.java:677)
	at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:157)
	... 123 more
Caused by: org.apache.calcite.sql.validate.SqlValidatorException: Column 'SLACKER' not found in any table
	at java.base/jdk.internal.re (stack truncated)
!ok
LogicalProject(X=[+($0, $7)], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], SLACKER=[$8])
  LogicalFilter(condition=[AND(=($5, *(10, $6)), =(UPPER($1), 'FOO'))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(X=[+($0, $7)], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], SLACKER=[$8])
  LogicalFilter(condition=[AND(=($5, *(10, $6)), =(UPPER($1), 'FOO'))])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_FILTER_TRANSPOSE"

# testPushProjectPastFullJoin -------------------------------------------------
# PROJECT_JOIN_TRANSPOSE should not push a non-strong expression past a
# null-generating side of a full outer join.

select count(*), case when e.sal < 11 then 11 else -1 * e.sal end
from emp e full outer join bonus b on e.ename = b.ename
group by case when e.sal < 11 then 11 else -1 * e.sal end;
+--------+----------+
| EXPR$0 | EXPR$1   |
+--------+----------+
|      1 | -1100.00 |
|      1 | -1300.00 |
|      1 | -1500.00 |
|      1 | -1600.00 |
|      1 | -2450.00 |
|      1 | -2850.00 |
|      1 | -2975.00 |
|      1 | -5000.00 |
|      1 |  -800.00 |
|      1 |  -950.00 |
|      2 | -1250.00 |
|      2 | -3000.00 |
+--------+----------+
(12 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($5, 11), 11, *(-1, $5))])
      LogicalJoin(condition=[=($1, $9)], joinType=[full])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE($1, 11, $2)])
      LogicalJoin(condition=[=($0, $3)], joinType=[full])
        LogicalProject(ENAME=[$1], EXPR$0=[<($5, 11)], EXPR$1=[*(-1, $5)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastFullJoinStrong -------------------------------------------
# PROJECT_JOIN_TRANSPOSE pushes a strong expression past a full outer join.

select count(*), case when e.sal < 11 then -1 * e.sal else e.sal end
from emp e full outer join bonus b on e.ename = b.ename
group by case when e.sal < 11 then -1 * e.sal else e.sal end;
+--------+---------+
| EXPR$0 | EXPR$1  |
+--------+---------+
|      1 | 1100.00 |
|      1 | 1300.00 |
|      1 | 1500.00 |
|      1 | 1600.00 |
|      1 | 2450.00 |
|      1 | 2850.00 |
|      1 | 2975.00 |
|      1 | 5000.00 |
|      1 |  800.00 |
|      1 |  950.00 |
|      2 | 1250.00 |
|      2 | 3000.00 |
+--------+---------+
(12 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($5, 11), *(-1, $5), $5)])
      LogicalJoin(condition=[=($1, $9)], joinType=[full])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[$1])
      LogicalJoin(condition=[=($0, $2)], joinType=[full])
        LogicalProject(ENAME=[$1], EXPR$1=[CASE(<($5, 11), *(-1, $5), $5)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastInnerJoin ------------------------------------------------
# [CALCITE-1753] PushProjector should only preserve expressions if the
# expression is strong when pushing into the nullable-side of outer join.

select count(*), case when e.sal < 11 then 11 else -1 * e.sal end
from emp e inner join bonus b on e.ename = b.ename
group by case when e.sal < 11 then 11 else -1 * e.sal end;
+--------+--------+
| EXPR$0 | EXPR$1 |
+--------+--------+
+--------+--------+
(0 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($5, 11), 11, *(-1, $5))])
      LogicalJoin(condition=[=($1, $9)], joinType=[inner])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[$1])
      LogicalJoin(condition=[=($0, $2)], joinType=[inner])
        LogicalProject(ENAME=[$1], EXPR$1=[CASE(<($5, 11), 11, *(-1, $5))])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastInnerJoinStrong ------------------------------------------
# PROJECT_JOIN_TRANSPOSE pushes a strong expression past an inner join.

select count(*), case when e.sal < 11 then -1 * e.sal else e.sal end
from emp e inner join bonus b on e.ename = b.ename
group by case when e.sal < 11 then -1 * e.sal else e.sal end;
+--------+--------+
| EXPR$0 | EXPR$1 |
+--------+--------+
+--------+--------+
(0 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($5, 11), *(-1, $5), $5)])
      LogicalJoin(condition=[=($1, $9)], joinType=[inner])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[$1])
      LogicalJoin(condition=[=($0, $2)], joinType=[inner])
        LogicalProject(ENAME=[$1], EXPR$1=[CASE(<($5, 11), *(-1, $5), $5)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastJoin -----------------------------------------------------
# PROJECT_JOIN_TRANSPOSE pushes a project past an inner join.

select e.sal + b.comm from emp e inner join bonus b
on e.ename = b.ename and e.deptno = 10;
+--------+
| EXPR$0 |
+--------+
+--------+
(0 rows)

!ok
LogicalProject(EXPR$0=[+($5, $12)])
  LogicalJoin(condition=[AND(=($1, $9), =($7, 10))], joinType=[inner])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[+($1, $4)])
  LogicalJoin(condition=[AND(=($0, $3), $2)], joinType=[inner])
    LogicalProject(ENAME=[$1], SAL=[$5], EXPR$0=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(ENAME=[$0], COMM=[$3])
      LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastLeftJoin -------------------------------------------------
# [CALCITE-1753] PROJECT_JOIN_TRANSPOSE should not push a non-strong expression
# into the null-generating side of a left join.

select count(*), case when e.sal < 11 then 11 else -1 * e.sal end
from emp e left outer join bonus b on e.ename = b.ename
group by case when e.sal < 11 then 11 else -1 * e.sal end;
+--------+----------+
| EXPR$0 | EXPR$1   |
+--------+----------+
|      1 | -1100.00 |
|      1 | -1300.00 |
|      1 | -1500.00 |
|      1 | -1600.00 |
|      1 | -2450.00 |
|      1 | -2850.00 |
|      1 | -2975.00 |
|      1 | -5000.00 |
|      1 |  -800.00 |
|      1 |  -950.00 |
|      2 | -1250.00 |
|      2 | -3000.00 |
+--------+----------+
(12 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($5, 11), 11, *(-1, $5))])
      LogicalJoin(condition=[=($1, $9)], joinType=[left])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[$1])
      LogicalJoin(condition=[=($0, $2)], joinType=[left])
        LogicalProject(ENAME=[$1], EXPR$1=[CASE(<($5, 11), 11, *(-1, $5))])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastLeftJoinSwap ---------------------------------------------
# PROJECT_JOIN_TRANSPOSE should not push non-strong expr into the
# null-generating side when the table order is swapped (bonus left join emp).

select count(*), case when e.sal < 11 then 11 else -1 * e.sal end
from bonus b left outer join emp e on e.ename = b.ename
group by case when e.sal < 11 then 11 else -1 * e.sal end;
+--------+--------+
| EXPR$0 | EXPR$1 |
+--------+--------+
+--------+--------+
(0 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($9, 11), 11, *(-1, $9))])
      LogicalJoin(condition=[=($5, $0)], joinType=[left])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE($2, 11, $3)])
      LogicalJoin(condition=[=($1, $0)], joinType=[left])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
        LogicalProject(ENAME=[$1], EXPR$0=[<($5, 11)], EXPR$1=[*(-1, $5)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastLeftJoinSwapStrong ---------------------------------------
# PROJECT_JOIN_TRANSPOSE pushes a strong expression past the null-generating
# side when tables are swapped (bonus left join emp).

select count(*), case when e.sal < 11 then -1 * e.sal else e.sal end
from bonus b left outer join emp e on e.ename = b.ename
group by case when e.sal < 11 then -1 * e.sal else e.sal end;
+--------+--------+
| EXPR$0 | EXPR$1 |
+--------+--------+
+--------+--------+
(0 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($9, 11), *(-1, $9), $9)])
      LogicalJoin(condition=[=($5, $0)], joinType=[left])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[$2])
      LogicalJoin(condition=[=($1, $0)], joinType=[left])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
        LogicalProject(ENAME=[$1], EXPR$1=[CASE(<($5, 11), *(-1, $5), $5)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastOutJoinWithCastNonNullExpr --------------------------------
# [CALCITE-4982] NonNull field shouldn't be pushed down into leaf of outer-join
# in ProjectJoinTransposeRule.

select e.empno + 1 as c1, coalesce(d.dname, b.job, '') as c2
from emp e
left join bonus b on e.ename = b.ename
left join dept d on e.deptno = d.deptno;
+------+------------+
| C1   | C2         |
+------+------------+
| 7370 | RESEARCH   |
| 7500 | SALES      |
| 7522 | SALES      |
| 7567 | RESEARCH   |
| 7655 | SALES      |
| 7699 | SALES      |
| 7783 | ACCOUNTING |
| 7789 | RESEARCH   |
| 7840 | ACCOUNTING |
| 7845 | SALES      |
| 7877 | RESEARCH   |
| 7901 | SALES      |
| 7903 | RESEARCH   |
| 7935 | ACCOUNTING |
+------+------------+
(14 rows)

!ok
LogicalProject(C1=[+($0, 1)], C2=[CASE(IS NOT NULL($14), CAST($14):VARCHAR(10) NOT NULL, IS NOT NULL($10), CAST($10):VARCHAR(10) NOT NULL, '':VARCHAR(10))])
  LogicalJoin(condition=[=($7, $13)], joinType=[left])
    LogicalJoin(condition=[=($1, $9)], joinType=[left])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
      LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
    LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE"
LogicalProject(C1=[$2], C2=[CASE(IS NOT NULL($5), CAST($5):VARCHAR(10) NOT NULL, $3, CAST($1):VARCHAR(10) NOT NULL, '':VARCHAR(10))])
  LogicalJoin(condition=[=($0, $4)], joinType=[left])
    LogicalProject(DEPTNO=[$1], JOB0=[$4], C1=[$2], EXPR$1=[IS NOT NULL($4)])
      LogicalJoin(condition=[=($0, $3)], joinType=[left])
        LogicalProject(ENAME=[$1], DEPTNO=[$7], C1=[+($0, 1)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(ENAME=[$0], JOB=[$1])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
    LogicalProject(DEPTNO=[$0], DNAME=[$1])
      LogicalTableScan(table=[[CATALOG, SALES, DEPT]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastRightJoin ------------------------------------------------
# PROJECT_JOIN_TRANSPOSE should not push a non-strong expression into the
# null-generating left side of a right join.

select count(*), case when e.sal < 11 then 11 else -1 * e.sal end
from emp e right outer join bonus b on e.ename = b.ename
group by case when e.sal < 11 then 11 else -1 * e.sal end;
+--------+--------+
| EXPR$0 | EXPR$1 |
+--------+--------+
+--------+--------+
(0 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($5, 11), 11, *(-1, $5))])
      LogicalJoin(condition=[=($1, $9)], joinType=[right])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE($1, 11, $2)])
      LogicalJoin(condition=[=($0, $3)], joinType=[right])
        LogicalProject(ENAME=[$1], EXPR$0=[<($5, 11)], EXPR$1=[*(-1, $5)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastRightJoinStrong ------------------------------------------
# PROJECT_JOIN_TRANSPOSE pushes a strong expression past a right join.

select count(*),
 case when e.sal < 11 then -1 * e.sal else e.sal end
from emp e right outer join bonus b on e.ename = b.ename
group by case when e.sal < 11 then -1 * e.sal else e.sal end;
+--------+--------+
| EXPR$0 | EXPR$1 |
+--------+--------+
+--------+--------+
(0 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($5, 11), *(-1, $5), $5)])
      LogicalJoin(condition=[=($1, $9)], joinType=[right])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[$1])
      LogicalJoin(condition=[=($0, $2)], joinType=[right])
        LogicalProject(ENAME=[$1], EXPR$1=[CASE(<($5, 11), *(-1, $5), $5)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastRightJoinSwap --------------------------------------------
# PROJECT_JOIN_TRANSPOSE should not push a non-strong expression into the
# null-generating right side of a right join (bonus right join emp).

select count(*), case when e.sal < 11 then 11 else -1 * e.sal end
from bonus b right outer join emp e on e.ename = b.ename
group by case when e.sal < 11 then 11 else -1 * e.sal end;
+--------+----------+
| EXPR$0 | EXPR$1   |
+--------+----------+
|      1 | -1100.00 |
|      1 | -1300.00 |
|      1 | -1500.00 |
|      1 | -1600.00 |
|      1 | -2450.00 |
|      1 | -2850.00 |
|      1 | -2975.00 |
|      1 | -5000.00 |
|      1 |  -800.00 |
|      1 |  -950.00 |
|      2 | -1250.00 |
|      2 | -3000.00 |
+--------+----------+
(12 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($9, 11), 11, *(-1, $9))])
      LogicalJoin(condition=[=($5, $0)], joinType=[right])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[$2])
      LogicalJoin(condition=[=($1, $0)], joinType=[right])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
        LogicalProject(ENAME=[$1], EXPR$1=[CASE(<($5, 11), 11, *(-1, $5))])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastRightJoinSwapStrong --------------------------------------
# PROJECT_JOIN_TRANSPOSE pushes a strong expression past a right join
# (bonus right join emp).

select count(*), case when e.sal < 11 then -1 * e.sal else e.sal end
from bonus b right outer join emp e on e.ename = b.ename
group by case when e.sal < 11 then -1 * e.sal else e.sal end;
+--------+---------+
| EXPR$0 | EXPR$1  |
+--------+---------+
|      1 | 1100.00 |
|      1 | 1300.00 |
|      1 | 1500.00 |
|      1 | 1600.00 |
|      1 | 2450.00 |
|      1 | 2850.00 |
|      1 | 2975.00 |
|      1 | 5000.00 |
|      1 |  800.00 |
|      1 |  950.00 |
|      2 | 1250.00 |
|      2 | 3000.00 |
+--------+---------+
(12 rows)

!ok
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[CASE(<($9, 11), *(-1, $9), $9)])
      LogicalJoin(condition=[=($5, $0)], joinType=[right])
        LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
        LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[$1], EXPR$1=[$0])
  LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
    LogicalProject(EXPR$1=[$2])
      LogicalJoin(condition=[=($1, $0)], joinType=[right])
        LogicalProject(ENAME=[$0])
          LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
        LogicalProject(ENAME=[$1], EXPR$1=[CASE(<($5, 11), *(-1, $5), $5)])
          LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectPastSetOp ----------------------------------------------------
# PROJECT_SET_OP_TRANSPOSE pushes a Project through a Union all set-op.

select sal from
(select * from emp e1 union all select * from emp e2);
+---------+
| SAL     |
+---------+
| 1100.00 |
| 1100.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1250.00 |
| 1300.00 |
| 1300.00 |
| 1500.00 |
| 1500.00 |
| 1600.00 |
| 1600.00 |
| 2450.00 |
| 2450.00 |
| 2850.00 |
| 2850.00 |
| 2975.00 |
| 2975.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 3000.00 |
| 5000.00 |
| 5000.00 |
|  800.00 |
|  800.00 |
|  950.00 |
|  950.00 |
+---------+
(28 rows)

!ok
LogicalProject(SAL=[$5])
  LogicalUnion(all=[true])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE"
LogicalUnion(all=[true])
  LogicalProject(SAL=[$5])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
  LogicalProject(SAL=[$5])
    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
!sub-plan "NONE, PROJECT_SET_OP_TRANSPOSE"

# testPushProjectWithOverPastJoin1 --------------------------------------------
# [CALCITE-2343] Should not push over whose columns are all from left child
# past join since join will affect row count.

select e.sal + b.comm,
count(e.empno) over (partition by e.deptno)
from emp e join bonus b
on e.ename = b.ename and e.deptno = 10;
# Not using !ok: query uses window functions whose results are not verified here.

LogicalProject(EXPR$0=[+($5, $12)], EXPR$1=[COUNT($0) OVER (PARTITION BY $7)])
  LogicalJoin(condition=[AND(=($1, $9), =($7, 10))], joinType=[inner])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[+($2, $6)], EXPR$1=[COUNT($0) OVER (PARTITION BY $3)])
  LogicalJoin(condition=[AND(=($1, $5), $4)], joinType=[inner])
    LogicalProject(EMPNO=[$0], ENAME=[$1], SAL=[$5], DEPTNO=[$7], EXPR$0=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(ENAME=[$0], COMM=[$3])
      LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectWithOverPastJoin2 --------------------------------------------
# Should not push over whose columns are all from right child past join since
# join will affect row count.

select e.sal + b.comm,
count(b.sal) over (partition by b.job)
from emp e join bonus b
on e.ename = b.ename and e.deptno = 10;
# Not using !ok: query uses window functions whose results are not verified here.

LogicalProject(EXPR$0=[+($5, $12)], EXPR$1=[COUNT($11) OVER (PARTITION BY $10)])
  LogicalJoin(condition=[AND(=($1, $9), =($7, 10))], joinType=[inner])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[+($1, $6)], EXPR$1=[COUNT($5) OVER (PARTITION BY $4)])
  LogicalJoin(condition=[AND(=($0, $3), $2)], joinType=[inner])
    LogicalProject(ENAME=[$1], SAL=[$5], EXPR$0=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(ENAME=[$0], JOB=[$1], SAL=[$2], COMM=[$3])
      LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testPushProjectWithOverPastJoin3 --------------------------------------------
# Should not push over past join but should push the operands of over past join.

select e.sal + b.comm,
sum(b.sal + b.sal + 100) over (partition by b.job)
from emp e join bonus b
on e.ename = b.ename and e.deptno = 10;
# Not using !ok: query uses window functions whose results are not verified here.

LogicalProject(EXPR$0=[+($5, $12)], EXPR$1=[SUM(+(+($11, $11), 100)) OVER (PARTITION BY $10)])
  LogicalJoin(condition=[AND(=($1, $9), =($7, 10))], joinType=[inner])
    LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE"
LogicalProject(EXPR$0=[+($1, $5)], EXPR$1=[SUM($6) OVER (PARTITION BY $4)])
  LogicalJoin(condition=[AND(=($0, $3), $2)], joinType=[inner])
    LogicalProject(ENAME=[$1], SAL=[$5], EXPR$0=[=($7, 10)])
      LogicalTableScan(table=[[CATALOG, SALES, EMP]])
    LogicalProject(ENAME=[$0], JOB=[$1], COMM=[$3], EXPR$0=[+(+($2, $2), 100)])
      LogicalTableScan(table=[[CATALOG, SALES, BONUS]])
!sub-plan "NONE, PROJECT_JOIN_TRANSPOSE"

# testReduceValuesUnderProject ------------------------------------------------
# PROJECT_MERGE + PROJECT_VALUES_MERGE reduce expressions in VALUES clauses.

select a + b from (values (10, 1), (20, 3)) as t(a, b);
+--------+
| EXPR$0 |
+--------+
|     11 |
|     23 |
+--------+
(2 rows)

!ok
LogicalProject(EXPR$0=[+($0, $1)])
  LogicalValues(tuples=[[{ 10, 1 }, { 20, 3 }]])
!sub-plan "NONE"
LogicalValues(tuples=[[{ 11 }, { 23 }]])
!sub-plan "NONE, PROJECT_MERGE, PROJECT_VALUES_MERGE"

# End project-join-transpose.iq
