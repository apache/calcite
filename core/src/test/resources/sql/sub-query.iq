# sub-query.iq - Queries involving IN and EXISTS sub-queries
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
!use post
!set outputformat psql

# [CALCITE-373]
# the following should return no rows, because the IN list has a null.
# for details on this: see HIVE-784, Dayal's paper from VLDB-87
with
t1(x) as (select * from  (values 1,2, case when 1 = 1 then null else 3 end)),
t2(x) as (select * from  (values 1,case when 1 = 1 then null else 3 end))
select *
from t1
where t1.x not in (select t2.x from t2);
 X
---
(0 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], expr#5=[0], expr#6=[=($t1, $t5)], expr#7=[IS NULL($t4)], expr#8=[>=($t2, $t1)], expr#9=[IS NOT NULL($t0)], expr#10=[AND($t7, $t8, $t9)], expr#11=[OR($t6, $t10)], X=[$t0], $condition=[$t11])
  EnumerableMergeJoin(condition=[=($0, $3)], joinType=[left])
    EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
      EnumerableValues(tuples=[[{ 1 }, { 2 }, { null }]])
      EnumerableAggregate(group=[{}], c=[COUNT()], ck=[COUNT($0)])
        EnumerableValues(tuples=[[{ 1 }, { null }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[true], proj#0..1=[{exprs}])
      EnumerableValues(tuples=[[{ 1 }, { null }]])
!plan

# Use of case is to get around issue with directly specifying null in values
# list. Postgres gives 0 rows.
with
t1(x) as (select * from  (values (1),(2),(case when 1 = 1 then null else 3 end)) as t1),
t2(x) as (select * from  (values (1),(case when 1 = 1 then null else 3 end)) as t2)
select *
from t1
where t1.x not in (select t2.x from t2);
 X
---
(0 rows)

!ok

# RHS has a mixture of NULL and NOT NULL keys
select * from dept where deptno not in (select deptno from emp);
 DEPTNO | DNAME
--------+-------
(0 rows)

!ok

# [CALCITE-5638] Assertion Failure during planning correlated query
SELECT "hr"."emps"."empid", "hr"."emps"."deptno",
 (SELECT count(*) FROM "hr"."emps" AS x WHERE x."salary">"hr"."emps"."salary" AND x."deptno"<"hr"."emps"."deptno")
FROM "hr"."emps"
 WHERE "hr"."emps"."empid"<"hr"."emps"."salary"
 ORDER BY 1,2,3;
 empid | deptno | EXPR$2
-------+--------+--------
   100 |     10 |      0
   110 |     10 |      0
   150 |     10 |      0
   200 |     20 |      2
(4 rows)

!ok

# [CALCITE-5638] Assertion Failure during planning correlated query
SELECT t1.deptno FROM dept AS t0 JOIN emp AS t1 ON
(t1.deptno = (SELECT inner_t1.deptno FROM emp AS inner_t1 WHERE inner_t1.ENAME = t0.DNAME));
 DEPTNO
--------
(0 rows)

!ok

select deptno, deptno     in (select deptno from emp) from dept;
 DEPTNO | EXPR$1
--------+--------
     10 | true
     20 | true
     30 | true
     40 | null
(4 rows)

!ok
select deptno, deptno not in (select deptno from emp) from dept;
 DEPTNO | EXPR$1
--------+--------
     10 | false
     20 | false
     30 | false
     40 | null
(4 rows)

!ok

# RHS has only NULL keys
select * from dept where deptno not in (select deptno from emp where deptno is null);
 DEPTNO | DNAME
--------+-------
(0 rows)

!ok
select deptno, deptno     in (select deptno from emp where deptno is null) from dept;
 DEPTNO | EXPR$1
--------+--------
     10 | null
     20 | null
     30 | null
     40 | null
(4 rows)

!ok
select deptno, deptno not in (select deptno from emp where deptno is null) from dept;
 DEPTNO | EXPR$1
--------+--------
     10 | null
     20 | null
     30 | null
     40 | null
(4 rows)

!ok

!set outputformat mysql

# RHS has only NOT NULL keys
select * from dept where deptno not in (select deptno from emp where deptno is not null);
+--------+-------------+
| DEPTNO | DNAME       |
+--------+-------------+
|     40 | Empty       |
+--------+-------------+
(1 row)

!ok
select deptno, deptno     in (select deptno from emp where deptno is not null) from dept;
+--------+--------+
| DEPTNO | EXPR$1 |
+--------+--------+
|     10 | true   |
|     20 | true   |
|     30 | true   |
|     40 | false  |
+--------+--------+
(4 rows)

!ok
select deptno, deptno not in (select deptno from emp where deptno is not null) from dept;
+--------+--------+
| DEPTNO | EXPR$1 |
+--------+--------+
|     10 | false  |
|     20 | false  |
|     30 | false  |
|     40 | true   |
+--------+--------+
(4 rows)

!ok

# [CALCITE-6579] SqlToRelConverter should not remove ORDER BY in subquery if it has an OFFSET
select count(*) as c from (select * from emp order by deptno offset 4);
+---+
| C |
+---+
| 5 |
+---+
(1 row)

!ok

# Subquery with ORDER BY and LIMIT
select count(*) as c from (select * from emp order by deptno limit 3);
+---+
| C |
+---+
| 3 |
+---+
(1 row)

!ok

# Subquery with ORDER BY and LIMIT. (LIMIT exceeds row count so has no effect.)
select count(*) as c from (select * from emp order by deptno limit 99);
+---+
| C |
+---+
| 9 |
+---+
(1 row)

!ok

# Previous queries as scalar subqueries.
select
  (select count(*) from emp) as c,
  (select count(*) from (select * from emp order by deptno)) as co,
  (select count(*) from (select * from emp order by deptno offset 4)) as o4,
  (select count(*) from (select * from emp order by deptno limit 3)) as l3,
  (select count(*) from (select * from emp order by deptno limit 99)) as l99,
  (select count(*) from (select * from emp order by deptno limit 99 offset 94)) as l99o94,
  (select count(*) from (select * from emp order by deptno limit 99 offset 5)) as l99o5
from (values 1) as t (v);
+---+----+----+----+-----+--------+-------+
| C | CO | O4 | L3 | L99 | L99O94 | L99O5 |
+---+----+----+----+-----+--------+-------+
| 9 |  9 |  5 |  3 |   9 |      0 |     4 |
+---+----+----+----+-----+--------+-------+
(1 row)

!ok

# RHS has no rows
# Even 'NULL NOT IN ...' is TRUE.
select * from dept where deptno not in (select deptno from emp where false);
+--------+-------------+
| DEPTNO | DNAME       |
+--------+-------------+
|     10 | Sales       |
|     20 | Marketing   |
|     30 | Engineering |
|     40 | Empty       |
+--------+-------------+
(4 rows)

!ok
EnumerableValues(tuples=[[{ 10, 'Sales      ' }, { 20, 'Marketing  ' }, { 30, 'Engineering' }, { 40, 'Empty      ' }]])
!plan

select deptno, deptno in (select deptno from emp where false) from dept;
+--------+--------+
| DEPTNO | EXPR$1 |
+--------+--------+
|     10 | false  |
|     20 | false  |
|     30 | false  |
|     40 | false  |
+--------+--------+
(4 rows)

!ok
EnumerableCalc(expr#0..1=[{inputs}], expr#2=[false], expr#3=[CAST($t2):BOOLEAN], DEPTNO=[$t0], EXPR$1=[$t3])
  EnumerableValues(tuples=[[{ 10, 'Sales      ' }, { 20, 'Marketing  ' }, { 30, 'Engineering' }, { 40, 'Empty      ' }]])
!plan

select deptno, deptno not in (select deptno from emp where false) from dept;
+--------+--------+
| DEPTNO | EXPR$1 |
+--------+--------+
|     10 | true   |
|     20 | true   |
|     30 | true   |
|     40 | true   |
+--------+--------+
(4 rows)

!ok

# Multiple IN, connected by OR
select * from dept
where deptno in (select deptno from emp where gender = 'F')
or deptno in (select deptno from emp where gender = 'M');
+--------+-------------+
| DEPTNO | DNAME       |
+--------+-------------+
|     10 | Sales       |
|     20 | Marketing   |
|     30 | Engineering |
+--------+-------------+
(3 rows)

!ok

# Mix IN and EXISTS
select * from dept
where deptno in (select deptno from emp where gender = 'F')
or exists (select 99, 101 from emp where gender = 'X');
+--------+-------------+
| DEPTNO | DNAME       |
+--------+-------------+
|     10 | Sales       |
|     30 | Engineering |
+--------+-------------+
(2 rows)

!ok

# Composite key
select * from dept
where (deptno, deptno) in (select deptno * 2 - deptno, deptno from emp where gender = 'F');

# Composite key, part literal
select * from emp
where (gender, deptno) in (select gender, 10 from emp where gender = 'F');
+-------+--------+--------+
| ENAME | DEPTNO | GENDER |
+-------+--------+--------+
| Jane  |     10 | F      |
+-------+--------+--------+
(1 row)

!ok

!use scott

# [CALCITE-1155] Support columns for IN list
SELECT empno, ename, mgr FROM "scott".emp WHERE 7782 IN (empno, mgr);
+-------+--------+------+
| EMPNO | ENAME  | MGR  |
+-------+--------+------+
|  7782 | CLARK  | 7839 |
|  7934 | MILLER | 7782 |
+-------+--------+------+
(2 rows)

!ok

# [CALCITE-694] Scan HAVING clause for sub-queries and IN-lists
SELECT count(*) AS c
FROM "scott".emp
GROUP BY emp.deptno
HAVING sum(case when emp.empno in (7369, 7839, 7902) then emp.sal else 0 end)
     BETWEEN 5000.0 AND 10000.0;
+---+
| C |
+---+
| 3 |
+---+
(1 row)

!ok

# [CALCITE-716] Scalar sub-query and aggregate function in SELECT or HAVING
# clause gives AssertionError
SELECT emp.deptno
FROM "scott".emp
GROUP BY emp.deptno
HAVING max(emp.empno) > (SELECT min(emp.empno) FROM "scott".emp);
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
+--------+
(3 rows)

!ok

# [CALCITE-716] Scalar sub-query and aggregate function in SELECT or HAVING
# clause gives AssertionError
SELECT emp.deptno,
  max(emp.empno) > (SELECT min(emp.empno) FROM "scott".emp) as bbbb
FROM "scott".emp
GROUP BY emp.deptno;
+--------+------+
| DEPTNO | BBBB |
+--------+------+
|     10 | true |
|     20 | true |
|     30 | true |
+--------+------+
(3 rows)

!ok

# [DRILL-4407] Group by sub-query causes Java NPE
select count(*) as c
from "scott".emp
group by (select deptno from "scott".emp where empno = 10);
+----+
| C  |
+----+
| 14 |
+----+
(1 row)

!ok

# Correlated IN sub-query in WHERE clause of JOIN
select empno from "scott".emp as e
join "scott".dept as d using (deptno)
where e.job in (
  select e2.job from "scott".emp as e2 where e2.deptno > e.deptno);
+-------+
| EMPNO |
+-------+
|  7369 |
|  7566 |
|  7782 |
|  7876 |
|  7934 |
+-------+
(5 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], EMPNO=[$t0])
  EnumerableHashJoin(condition=[=($2, $5)], joinType=[semi])
    EnumerableCalc(expr#0..4=[{inputs}], EMPNO=[$t2], JOB=[$t3], DEPTNO=[$t4], JOB0=[$t0], DEPTNO0=[$t1])
      EnumerableHashJoin(condition=[AND(=($1, $4), =($0, $3))], joinType=[inner])
        EnumerableAggregate(group=[{1, 3}])
          EnumerableNestedLoopJoin(condition=[>($2, $3)], joinType=[inner])
            EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], JOB=[$t2], DEPTNO=[$t7])
              EnumerableTableScan(table=[[scott, EMP]])
            EnumerableAggregate(group=[{1}])
              EnumerableHashJoin(condition=[=($1, $2)], joinType=[semi])
                EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
                  EnumerableTableScan(table=[[scott, EMP]])
                EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
                  EnumerableTableScan(table=[[scott, DEPT]])
        EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], JOB=[$t2], DEPTNO=[$t7])
          EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan

# [CALCITE-6824] Subquery in join conditions rewrite fails if referencing a column from the right-hand side table
select empno from "scott".emp where (empno not in (select dept.deptno from dept))
in (select deptno = 0 from dept);
+-------+
| EMPNO |
+-------+
+-------+
(0 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], EMPNO=[$t0])
  EnumerableNestedLoopJoin(condition=[=(IS NULL($2), $3)], joinType=[inner])
    EnumerableMergeJoin(condition=[=($0, $1)], joinType=[left])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0])
        EnumerableTableScan(table=[[scott, EMP]])
      EnumerableSort(sort0=[$0], dir0=[ASC])
        EnumerableAggregate(group=[{0}], i=[LITERAL_AGG(true)])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):SMALLINT NOT NULL], DEPTNO=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER NOT NULL], expr#4=[0], expr#5=[=($t3, $t4)], EXPR$0=[$t5])
        EnumerableTableScan(table=[[scott, DEPT]])
!plan

# [CALCITE-6824] Subquery in join conditions rewrite fails if referencing a column from the right-hand side table
SELECT empno FROM emp JOIN dept on emp.deptno <= ALL(SELECT deptno FROM dept) and emp.deptno = dept.deptno;
+-------+
| EMPNO |
+-------+
|  7782 |
|  7839 |
|  7934 |
+-------+
(3 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], EMPNO=[$t0])
  EnumerableHashJoin(condition=[=($1, $5)], joinType=[semi])
    EnumerableNestedLoopJoin(condition=[OR(=($3, 0), AND(<=($1, $2), IS NOT TRUE(OR(>($1, $2), >($3, $4)))))], joinType=[inner])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
      EnumerableCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}], d=[$t1])
        EnumerableAggregate(group=[{}], m=[MIN($0)], c=[COUNT()])
          EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan

# [CALCITE-6824] Subquery in join conditions rewrite fails if referencing a column from the right-hand side table
SELECT empno FROM emp JOIN dept on emp.deptno = (SELECT min(deptno) FROM dept) and emp.deptno = dept.deptno;
+-------+
| EMPNO |
+-------+
|  7782 |
|  7839 |
|  7934 |
+-------+
(3 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], EMPNO=[$t0])
  EnumerableHashJoin(condition=[=($2, $3)], joinType=[semi])
    EnumerableCalc(expr#0..2=[{inputs}], EMPNO=[$t1], DEPTNO=[$t2], EXPR$0=[$t0])
      EnumerableHashJoin(condition=[=($0, $2)], joinType=[inner])
        EnumerableAggregate(group=[{}], EXPR$0=[MIN($0)])
          EnumerableTableScan(table=[[scott, DEPT]])
        EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
          EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Correlated NOT IN sub-query in WHERE clause of JOIN
select empno from "scott".emp as e
join "scott".dept as d using (deptno)
where e.job not in (
  select e2.job from "scott".emp as e2 where e2.deptno > e.deptno);
+-------+
| EMPNO |
+-------+
|  7499 |
|  7521 |
|  7654 |
|  7698 |
|  7788 |
|  7839 |
|  7844 |
|  7900 |
|  7902 |
+-------+
(9 rows)

!ok
EnumerableCalc(expr#0..9=[{inputs}], expr#10=[0], expr#11=[=($t5, $t10)], expr#12=[IS NULL($t1)], expr#13=[IS NOT NULL($t9)], expr#14=[<($t6, $t5)], expr#15=[OR($t12, $t13, $t14)], expr#16=[IS NOT TRUE($t15)], expr#17=[OR($t11, $t16)], EMPNO=[$t0], $condition=[$t17])
  EnumerableMergeJoin(condition=[AND(=($1, $7), =($2, $8))], joinType=[left])
    EnumerableSort(sort0=[$1], sort1=[$2], dir0=[ASC], dir1=[ASC])
      EnumerableMergeJoin(condition=[=($2, $4)], joinType=[left])
        EnumerableMergeJoin(condition=[=($2, $3)], joinType=[inner])
          EnumerableSort(sort0=[$2], dir0=[ASC])
            EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], JOB=[$t2], DEPTNO=[$t7])
              EnumerableTableScan(table=[[scott, EMP]])
          EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
            EnumerableTableScan(table=[[scott, DEPT]])
        EnumerableSort(sort0=[$0], dir0=[ASC])
          EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NOT NULL($t2)], expr#5=[0], expr#6=[CASE($t4, $t2, $t5)], expr#7=[IS NOT NULL($t3)], expr#8=[CASE($t7, $t3, $t5)], DEPTNO0=[$t0], c=[$t6], ck=[$t8])
            EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
              EnumerableAggregate(group=[{1}])
                EnumerableHashJoin(condition=[=($1, $2)], joinType=[semi])
                  EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
                    EnumerableTableScan(table=[[scott, EMP]])
                  EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
                    EnumerableTableScan(table=[[scott, DEPT]])
              EnumerableAggregate(group=[{3}], c=[COUNT()], ck=[COUNT($1)])
                EnumerableNestedLoopJoin(condition=[>($2, $3)], joinType=[inner])
                  EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], JOB=[$t2], DEPTNO=[$t7])
                    EnumerableTableScan(table=[[scott, EMP]])
                  EnumerableAggregate(group=[{1}])
                    EnumerableHashJoin(condition=[=($1, $2)], joinType=[semi])
                      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
                        EnumerableTableScan(table=[[scott, EMP]])
                      EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
                        EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t0)], proj#0..2=[{exprs}], $condition=[$t3])
        EnumerableAggregate(group=[{1, 3}], i=[LITERAL_AGG(true)])
          EnumerableNestedLoopJoin(condition=[>($2, $3)], joinType=[inner])
            EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], JOB=[$t2], DEPTNO=[$t7])
              EnumerableTableScan(table=[[scott, EMP]])
            EnumerableAggregate(group=[{1}])
              EnumerableHashJoin(condition=[=($1, $2)], joinType=[semi])
                EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
                  EnumerableTableScan(table=[[scott, EMP]])
                EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
                  EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Condition that returns a NULL key.
# Tested on Oracle.
select count(*) as c
from "scott".emp
where sal + 100 not in (
  select comm
  from "scott".emp);
+---+
| C |
+---+
| 0 |
+---+
(1 row)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
SELECT dname FROM "scott".dept WHERE 2000 > (SELECT emp.sal FROM "scott".emp where dept.deptno = emp.deptno ORDER BY emp.sal limit 1);

EnumerableCalc(expr#0..1=[{inputs}], DNAME=[$t1])
  EnumerableHashJoin(condition=[=($0, $2)], joinType=[semi])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..1=[{inputs}], expr#2=[2000.00:DECIMAL(12, 2)], expr#3=[CAST($t1):DECIMAL(12, 2)], expr#4=[>($t2, $t3)], proj#0..1=[{exprs}], $condition=[$t4])
      EnumerableAggregate(group=[{7}], agg#0=[MIN($5)])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
          EnumerableTableScan(table=[[scott, EMP]])
!plan
+------------+
| DNAME      |
+------------+
| ACCOUNTING |
| RESEARCH   |
| SALES      |
+------------+
(3 rows)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
SELECT dname FROM "scott".dept WHERE 4000 > (SELECT emp.sal FROM "scott".emp where dept.deptno = emp.deptno ORDER BY emp.sal desc nulls last limit 1);

EnumerableCalc(expr#0..1=[{inputs}], DNAME=[$t1])
  EnumerableHashJoin(condition=[=($0, $2)], joinType=[semi])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..1=[{inputs}], expr#2=[4000.00:DECIMAL(12, 2)], expr#3=[CAST($t1):DECIMAL(12, 2)], expr#4=[>($t2, $t3)], proj#0..1=[{exprs}], $condition=[$t4])
      EnumerableAggregate(group=[{7}], agg#0=[MAX($5)])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
          EnumerableTableScan(table=[[scott, EMP]])
!plan
+----------+
| DNAME    |
+----------+
| RESEARCH |
| SALES    |
+----------+
(2 rows)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
# The case of the subquery that returns 0 rows
SELECT dname FROM "scott".dept WHERE 2000 > (SELECT emp.sal FROM "scott".emp where dept.deptno = emp.deptno and mgr > 8000 ORDER BY emp.sal limit 1);

EnumerableCalc(expr#0..1=[{inputs}], DNAME=[$t1])
  EnumerableHashJoin(condition=[=($0, $2)], joinType=[semi])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..1=[{inputs}], expr#2=[2000.00:DECIMAL(12, 2)], expr#3=[CAST($t1):DECIMAL(12, 2)], expr#4=[>($t2, $t3)], proj#0..1=[{exprs}], $condition=[$t4])
      EnumerableAggregate(group=[{7}], agg#0=[MIN($5)])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t3):INTEGER], expr#9=[8000], expr#10=[>($t8, $t9)], expr#11=[IS NOT NULL($t7)], expr#12=[AND($t10, $t11)], proj#0..7=[{exprs}], $condition=[$t12])
          EnumerableTableScan(table=[[scott, EMP]])
!plan
+-------+
| DNAME |
+-------+
+-------+
(0 rows)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
SELECT dname FROM "scott".dept WHERE 2000 > (SELECT emp.sal FROM "scott".emp where dept.deptno = emp.deptno ORDER BY year(hiredate), emp.sal limit 1);

EnumerableCalc(expr#0..3=[{inputs}], DNAME=[$t3])
  EnumerableHashJoin(condition=[=($1, $2)], joinType=[inner])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[2000.00:DECIMAL(12, 2)], expr#4=[CAST($t1):DECIMAL(12, 2)], expr#5=[>($t3, $t4)], SAL=[$t1], DEPTNO=[$t0], $condition=[$t5])
      EnumerableAggregate(group=[{1, 3, 4}])
        EnumerableWindow(window#0=[window(partition {1} order by [2, 0] range between UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING aggs [FIRST_VALUE($0), FIRST_VALUE($2)])])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[FLAG(YEAR)], expr#9=[EXTRACT($t8, $t4)], expr#10=[IS NOT NULL($t7)], SAL=[$t5], DEPTNO=[$t7], $2=[$t9], $condition=[$t10])
            EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan
+----------+
| DNAME    |
+----------+
| RESEARCH |
| SALES    |
+----------+
(2 rows)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
# The case of the subquery that returns 0 rows
SELECT dname FROM "scott".dept WHERE 2000 > (SELECT emp.sal FROM "scott".emp where dept.deptno = emp.deptno and mgr > 8000 ORDER BY year(hiredate), emp.sal limit 1);

EnumerableCalc(expr#0..3=[{inputs}], DNAME=[$t3])
  EnumerableHashJoin(condition=[=($1, $2)], joinType=[inner])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[2000.00:DECIMAL(12, 2)], expr#4=[CAST($t1):DECIMAL(12, 2)], expr#5=[>($t3, $t4)], SAL=[$t1], DEPTNO=[$t0], $condition=[$t5])
      EnumerableAggregate(group=[{1, 3, 4}])
        EnumerableWindow(window#0=[window(partition {1} order by [2, 0] range between UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING aggs [FIRST_VALUE($0), FIRST_VALUE($2)])])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[FLAG(YEAR)], expr#9=[EXTRACT($t8, $t4)], expr#10=[CAST($t3):INTEGER], expr#11=[8000], expr#12=[>($t10, $t11)], expr#13=[IS NOT NULL($t7)], expr#14=[AND($t12, $t13)], SAL=[$t5], DEPTNO=[$t7], $2=[$t9], $condition=[$t14])
            EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan
+-------+
| DNAME |
+-------+
+-------+
(0 rows)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
SELECT dname, (SELECT emp.sal FROM "scott".emp where dept.deptno = emp.deptno ORDER BY emp.sal desc nulls last limit 1) FROM "scott".dept;

EnumerableCalc(expr#0..3=[{inputs}], DNAME=[$t1], EXPR$1=[$t3])
  EnumerableMergeJoin(condition=[=($0, $2)], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableAggregate(group=[{7}], agg#0=[MAX($5)])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
          EnumerableTableScan(table=[[scott, EMP]])
!plan
+------------+---------+
| DNAME      | EXPR$1  |
+------------+---------+
| ACCOUNTING | 5000.00 |
| OPERATIONS |         |
| RESEARCH   | 3000.00 |
| SALES      | 2850.00 |
+------------+---------+
(4 rows)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
# subquery contains null
SELECT dname, (SELECT emp.comm FROM "scott".emp where dept.deptno = emp.deptno ORDER BY emp.comm desc limit 1) FROM "scott".dept;

EnumerableCalc(expr#0..3=[{inputs}], DNAME=[$t1], EXPR$1=[$t2])
  EnumerableMergeJoin(condition=[=($0, $3)], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], w0$o0=[$t1], DEPTNO=[$t0])
        EnumerableAggregate(group=[{7, 8}])
          EnumerableWindow(window#0=[window(partition {7} order by [6 DESC] range between UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING aggs [FIRST_VALUE($6)])])
            EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
              EnumerableTableScan(table=[[scott, EMP]])
!plan
+------------+--------+
| DNAME      | EXPR$1 |
+------------+--------+
| ACCOUNTING |        |
| OPERATIONS |        |
| RESEARCH   |        |
| SALES      |        |
+------------+--------+
(4 rows)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
# subquery contains null
SELECT dname, (SELECT emp.comm FROM "scott".emp where dept.deptno = emp.deptno ORDER BY emp.comm limit 1) FROM "scott".dept;

EnumerableCalc(expr#0..3=[{inputs}], DNAME=[$t1], EXPR$1=[$t3])
  EnumerableMergeJoin(condition=[=($0, $2)], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableAggregate(group=[{7}], agg#0=[MIN($6)])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
          EnumerableTableScan(table=[[scott, EMP]])
!plan
+------------+--------+
| DNAME      | EXPR$1 |
+------------+--------+
| ACCOUNTING |        |
| OPERATIONS |        |
| RESEARCH   |        |
| SALES      |   0.00 |
+------------+--------+
(4 rows)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
# The case of the subquery that returns 0 rows
SELECT dname, (SELECT emp.sal FROM "scott".emp where dept.deptno = emp.deptno and mgr > 8000 ORDER BY emp.sal limit 1) FROM "scott".dept;

EnumerableCalc(expr#0..3=[{inputs}], DNAME=[$t1], EXPR$1=[$t3])
  EnumerableMergeJoin(condition=[=($0, $2)], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableAggregate(group=[{7}], agg#0=[MIN($5)])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t3):INTEGER], expr#9=[8000], expr#10=[>($t8, $t9)], expr#11=[IS NOT NULL($t7)], expr#12=[AND($t10, $t11)], proj#0..7=[{exprs}], $condition=[$t12])
          EnumerableTableScan(table=[[scott, EMP]])
!plan
+------------+--------+
| DNAME      | EXPR$1 |
+------------+--------+
| ACCOUNTING |        |
| OPERATIONS |        |
| RESEARCH   |        |
| SALES      |        |
+------------+--------+
(4 rows)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
SELECT dname, (SELECT emp.sal FROM "scott".emp where dept.deptno = emp.deptno ORDER BY year(hiredate), emp.sal limit 1) FROM "scott".dept;

EnumerableCalc(expr#0..3=[{inputs}], DNAME=[$t1], EXPR$1=[$t2])
  EnumerableMergeJoin(condition=[=($0, $3)], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..2=[{inputs}], SAL=[$t1], DEPTNO=[$t0])
        EnumerableAggregate(group=[{1, 3, 4}])
          EnumerableWindow(window#0=[window(partition {1} order by [2, 0] range between UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING aggs [FIRST_VALUE($0), FIRST_VALUE($2)])])
            EnumerableCalc(expr#0..7=[{inputs}], expr#8=[FLAG(YEAR)], expr#9=[EXTRACT($t8, $t4)], expr#10=[IS NOT NULL($t7)], SAL=[$t5], DEPTNO=[$t7], $2=[$t9], $condition=[$t10])
              EnumerableTableScan(table=[[scott, EMP]])
!plan
+------------+---------+
| DNAME      | EXPR$1  |
+------------+---------+
| ACCOUNTING | 2450.00 |
| OPERATIONS |         |
| RESEARCH   |  800.00 |
| SALES      |  950.00 |
+------------+---------+
(4 rows)

!ok

# [CALCITE-6652] RelDecorrelator can't decorrelate query with limit 1
# The case of the subquery that returns 0 rows
SELECT dname, (SELECT emp.sal FROM "scott".emp where dept.deptno = emp.deptno and mgr > 8000 ORDER BY year(hiredate), emp.sal limit 1) FROM "scott".dept;

EnumerableCalc(expr#0..3=[{inputs}], DNAME=[$t1], EXPR$1=[$t2])
  EnumerableMergeJoin(condition=[=($0, $3)], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..2=[{inputs}], SAL=[$t1], DEPTNO=[$t0])
        EnumerableAggregate(group=[{1, 3, 4}])
          EnumerableWindow(window#0=[window(partition {1} order by [2, 0] range between UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING aggs [FIRST_VALUE($0), FIRST_VALUE($2)])])
            EnumerableCalc(expr#0..7=[{inputs}], expr#8=[FLAG(YEAR)], expr#9=[EXTRACT($t8, $t4)], expr#10=[CAST($t3):INTEGER], expr#11=[8000], expr#12=[>($t10, $t11)], expr#13=[IS NOT NULL($t7)], expr#14=[AND($t12, $t13)], SAL=[$t5], DEPTNO=[$t7], $2=[$t9], $condition=[$t14])
              EnumerableTableScan(table=[[scott, EMP]])
!plan
+------------+--------+
| DNAME      | EXPR$1 |
+------------+--------+
| ACCOUNTING |        |
| OPERATIONS |        |
| RESEARCH   |        |
| SALES      |        |
+------------+--------+
(4 rows)

!ok

# Condition that happens to eliminate all NULL keys.
# The one missing row has {ename: 'MARTIN', comm: 1400}
# Tested on Oracle.
select count(*) as c
from "scott".emp
where sal + 100 not in (
  select comm from "scott".emp
  where job = 'SALESMAN');
+----+
| C  |
+----+
| 13 |
+----+
(1 row)

!ok

# Condition that provably eliminates all NULL keys.
# Tested on Oracle.
select count(*) as c
from "scott".emp
where sal + 100 not in (
  select comm
  from "scott".emp
  where comm < 1000);
+----+
| C  |
+----+
| 14 |
+----+
(1 row)

!ok

# Correlated condition in NOT IN.
# Tested on Oracle.
!if (fixed.calcite1513) {
select count(*) as c
from "scott".emp as e
where sal + 100 not in (
  select comm
  from "scott".emp
  where job = e.job);
     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30
!ok
!}

# [CALCITE-356] AssertionError while translating query with WITH and correlated sub-query
with t (a, b) as (select * from (values (1, 2)))
select * from t where exists (select 1 from "scott".emp where deptno = t.a);
EnumerableCalc(expr#0=[{inputs}], expr#1=[1], expr#2=[2], A=[$t1], B=[$t2])
  EnumerableAggregate(group=[{0}])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t7):INTEGER], expr#9=[1], expr#10=[=($t9, $t8)], DEPTNO0=[$t8], $condition=[$t10])
      EnumerableTableScan(table=[[scott, EMP]])
!plan

# Similar query, identical plan
with t as (select * from (values (1, 2)) as t(a, b))
select * from t where exists (select 1 from "scott".emp where deptno = t.a);
EnumerableCalc(expr#0=[{inputs}], expr#1=[1], expr#2=[2], A=[$t1], B=[$t2])
  EnumerableAggregate(group=[{0}])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t7):INTEGER], expr#9=[1], expr#10=[=($t9, $t8)], DEPTNO0=[$t8], $condition=[$t10])
      EnumerableTableScan(table=[[scott, EMP]])
!plan

# Uncorrelated
with t (a, b) as (select * from (values (60, 'b')))
select * from t where a in (select deptno from "scott".dept);
EnumerableCalc(expr#0=[{inputs}], expr#1=[60], expr#2=['b'], A=[$t1], B=[$t2])
  EnumerableAggregate(group=[{0}])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER NOT NULL], expr#4=[60], expr#5=[=($t4, $t3)], DEPTNO=[$t3], $condition=[$t5])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan
+---+---+
| A | B |
+---+---+
+---+---+
(0 rows)

!ok

with t (a, b) as (select * from (values (30, 'b')))
select * from t where a in (select deptno from "scott".dept);
EnumerableCalc(expr#0=[{inputs}], expr#1=[30], expr#2=['b'], A=[$t1], B=[$t2])
  EnumerableAggregate(group=[{0}])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER NOT NULL], expr#4=[30], expr#5=[=($t4, $t3)], DEPTNO=[$t3], $condition=[$t5])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan
+----+---+
| A  | B |
+----+---+
| 30 | b |
+----+---+
(1 row)

!ok

# [CALCITE-864] Correlation variable has incorrect row type if it is populated
# by right side of a Join
select *
from "scott".emp as e
join "scott".dept as d using (deptno)
where sal = (
  select max(sal)
  from "scott".emp as e2
  join "scott".dept as d2 using (deptno)
  where d2.deptno = d.deptno);
+--------+-------+-------+-----------+------+------------+---------+------+------------+----------+
| DEPTNO | EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DNAME      | LOC      |
+--------+-------+-------+-----------+------+------------+---------+------+------------+----------+
|     10 |  7839 | KING  | PRESIDENT |      | 1981-11-17 | 5000.00 |      | ACCOUNTING | NEW YORK |
|     20 |  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 |      | RESEARCH   | DALLAS   |
|     20 |  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 |      | RESEARCH   | DALLAS   |
|     30 |  7698 | BLAKE | MANAGER   | 7839 | 1981-01-05 | 2850.00 |      | SALES      | CHICAGO  |
+--------+-------+-------+-----------+------+------------+---------+------+------------+----------+
(4 rows)

!ok

# Simpler test case for [CALCITE-864]
select empno, ename, sal, e.deptno, loc
from "scott".emp as e
join "scott".dept as d using (deptno)
where e.sal = (
  select max(sal)
  from "scott".emp as e2
  where e2.deptno = e.deptno);
+-------+-------+---------+--------+----------+
| EMPNO | ENAME | SAL     | DEPTNO | LOC      |
+-------+-------+---------+--------+----------+
|  7698 | BLAKE | 2850.00 |     30 | CHICAGO  |
|  7788 | SCOTT | 3000.00 |     20 | DALLAS   |
|  7839 | KING  | 5000.00 |     10 | NEW YORK |
|  7902 | FORD  | 3000.00 |     20 | DALLAS   |
+-------+-------+---------+--------+----------+
(4 rows)

!ok

# Simpler test case for [CALCITE-864]
select *
from "scott".emp as e
join "scott".dept as d using (deptno)
where d.dname = (
  select max(dname)
  from "scott".dept as d2
  where d2.deptno = d.deptno);
+--------+-------+--------+-----------+------+------------+---------+---------+------------+----------+
| DEPTNO | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DNAME      | LOC      |
+--------+-------+--------+-----------+------+------------+---------+---------+------------+----------+
|     10 |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         | ACCOUNTING | NEW YORK |
|     10 |  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         | ACCOUNTING | NEW YORK |
|     10 |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         | ACCOUNTING | NEW YORK |
|     20 |  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         | RESEARCH   | DALLAS   |
|     20 |  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         | RESEARCH   | DALLAS   |
|     20 |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         | RESEARCH   | DALLAS   |
|     20 |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         | RESEARCH   | DALLAS   |
|     20 |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         | RESEARCH   | DALLAS   |
|     30 |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 | SALES      | CHICAGO  |
|     30 |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 | SALES      | CHICAGO  |
|     30 |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 | SALES      | CHICAGO  |
|     30 |  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         | SALES      | CHICAGO  |
|     30 |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 | SALES      | CHICAGO  |
|     30 |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         | SALES      | CHICAGO  |
+--------+-------+--------+-----------+------+------------+---------+---------+------------+----------+
(14 rows)

!ok

# Two EXISTS
# [CALCITE-1511] AssertionError while decorrelating query with two EXISTS sub-queries
select *
from "scott".dept as d
where exists (select 1 from "scott".emp where empno > d.deptno)
and exists (select 0 from "scott".emp where deptno = d.deptno and ename = 'SMITH');
+--------+----------+--------+
| DEPTNO | DNAME    | LOC    |
+--------+----------+--------+
|     20 | RESEARCH | DALLAS |
+--------+----------+--------+
(1 row)

!ok

# Two scalar sub-queries
select deptno,
  (select min(1) from "scott".emp where empno > d.deptno) as i0,
  (select min(0) from "scott".emp where deptno = d.deptno and ename = 'SMITH') as i1
from "scott".dept as d;
+--------+----+----+
| DEPTNO | I0 | I1 |
+--------+----+----+
|     10 |  1 |    |
|     20 |  1 |  0 |
|     30 |  1 |    |
|     40 |  1 |    |
+--------+----+----+
(4 rows)

!ok

# Correlated scalar sub-query
SELECT d.dname,
    (WITH clerks AS
      (SELECT *
       FROM "scott".emp
       WHERE deptno = d.deptno)
     SELECT min(sal)
     FROM clerks) AS min_clerk_sal
FROM "scott".dept AS d;
+------------+---------------+
| DNAME      | MIN_CLERK_SAL |
+------------+---------------+
| ACCOUNTING |       1300.00 |
| OPERATIONS |               |
| RESEARCH   |        800.00 |
| SALES      |        950.00 |
+------------+---------------+
(4 rows)

!ok

# As previous, minimal
SELECT (WITH t2 AS (SELECT t.a)
        SELECT a FROM t2) AS c
FROM (SELECT 1 AS a) AS t;
+---+
| C |
+---+
| 1 |
+---+
(1 row)

!ok

# As above, converting CTE to inline view
SELECT (SELECT a
        FROM (SELECT t.a) AS t2) AS c
FROM (SELECT 1 AS a) AS t;
+---+
| C |
+---+
| 1 |
+---+
(1 row)

!ok

# [CALCITE-6554] nested correlated sub-query in aggregation does not have inner correlation variable bound to inner projection
SELECT ename,
       (SELECT Sum(sal + COALESCE((SELECT Sum(sal) FROM "scott".emp AS subord2
                   WHERE
                           subord2.mgr =
                           subord.empno), 0))
        FROM   "scott".emp AS subord
        WHERE  subord.mgr = bosses.empno) AS deep2sal
FROM   "scott".emp AS bosses;
+--------+----------+
| ENAME  | DEEP2SAL |
+--------+----------+
| ADAMS  |          |
| ALLEN  |          |
| BLAKE  |  6550.00 |
| CLARK  |  1300.00 |
| FORD   |   800.00 |
| JAMES  |          |
| JONES  |  7900.00 |
| KING   | 22125.00 |
| MARTIN |          |
| MILLER |          |
| SCOTT  |  1100.00 |
| SMITH  |          |
| TURNER |          |
| WARD   |          |
+--------+----------+
(14 rows)

!ok

EnumerableCalc(expr#0..3=[{inputs}], ENAME=[$t1], DEEP2SAL=[$t3])
  EnumerableMergeJoin(condition=[=($0, $2)], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableAggregate(group=[{0}], EXPR$0=[SUM($1)])
        EnumerableCalc(expr#0..4=[{inputs}], expr#5=[IS NOT NULL($t4)], expr#6=[CAST($t4):DECIMAL(19, 2) NOT NULL], expr#7=[0.00:DECIMAL(19, 2)], expr#8=[CASE($t5, $t6, $t7)], expr#9=[+($t2, $t8)], MGR9=[$t1], $f0=[$t9])
          EnumerableMergeJoin(condition=[=($0, $3)], joinType=[left])
            EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t3)], EMPNO=[$t0], MGR=[$t3], SAL=[$t5], $condition=[$t8])
              EnumerableTableScan(table=[[scott, EMP]])
            EnumerableSort(sort0=[$0], dir0=[ASC])
              EnumerableAggregate(group=[{3}], EXPR$0=[SUM($5)])
                EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t3)], proj#0..7=[{exprs}], $condition=[$t8])
                  EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-1494] Inefficient plan for correlated sub-queries
# Plan must have only one scan each of emp and dept.
select sal
from "scott".emp
where empno IN (
  select deptno
  from "scott".dept
  where emp.job = dept.dname);
+-----+
| SAL |
+-----+
+-----+
(0 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], SAL=[$t1])
  EnumerableHashJoin(condition=[AND(=($2, $4), =($0, $3))], joinType=[semi])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t2):VARCHAR(14)], EMPNO=[$t0], SAL=[$t5], JOB0=[$t8])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):SMALLINT NOT NULL], expr#4=[IS NOT NULL($t1)], DEPTNO=[$t3], DNAME=[$t1], $condition=[$t4])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan

# As above, but for EXISTS
select *
from "scott".dept as d
where exists (
  select 0 from "scott".emp
  where deptno = d.deptno
  and ename = 'SMITH');
+--------+----------+--------+
| DEPTNO | DNAME    | LOC    |
+--------+----------+--------+
|     20 | RESEARCH | DALLAS |
+--------+----------+--------+
(1 row)

!ok
EnumerableHashJoin(condition=[=($0, $3)], joinType=[semi])
  EnumerableTableScan(table=[[scott, DEPT]])
  EnumerableCalc(expr#0..7=[{inputs}], expr#8=['SMITH':VARCHAR(10)], expr#9=[=($t1, $t8)], expr#10=[IS NOT NULL($t7)], expr#11=[AND($t9, $t10)], DEPTNO=[$t7], $condition=[$t11])
    EnumerableTableScan(table=[[scott, EMP]])
!plan

# [DRILL-5644]
select TJOIN1.RNUM, TJOIN1.C1,
  case when 10 in ( select C1 from ( values (1) ) T(C1) ) then 'yes' else 'no' end C3
from (
  values (0, 10, 15),
    (1, 20, 25),
    (2, cast(NULL as integer), 50)) TJOIN1 (RNUM, C1, C2);
+------+----+-----+
| RNUM | C1 | C3  |
+------+----+-----+
|    0 | 10 | no  |
|    1 | 20 | no  |
|    2 |    | no  |
+------+----+-----+
(3 rows)

!ok

# [CALCITE-2028] Un-correlated IN sub-query should be converted into a Join
# rather than a Correlate without correlation variables
SELECT *
FROM "scott".emp
WHERE job in (select job from "scott".emp ee where ee.hiredate = DATE '1980-12-17')
AND EXISTS (select * from "scott".emp e where emp.deptno = e.deptno);
+-------+--------+-------+------+------------+---------+------+--------+
| EMPNO | ENAME  | JOB   | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+--------+-------+------+------------+---------+------+--------+
|  7369 | SMITH  | CLERK | 7902 | 1980-12-17 |  800.00 |      |     20 |
|  7876 | ADAMS  | CLERK | 7788 | 1987-05-23 | 1100.00 |      |     20 |
|  7900 | JAMES  | CLERK | 7698 | 1981-12-03 |  950.00 |      |     30 |
|  7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 |      |     10 |
+-------+--------+-------+------+------------+---------+------+--------+
(4 rows)

!ok

# Variant of [CALCITE-2028] above
SELECT *
FROM "scott".emp
WHERE job in (select job from "scott".emp ee where ee.hiredate = DATE '1980-12-17')
OR EXISTS (select * from "scott".emp e where emp.deptno = e.deptno + 20);
+-------+--------+----------+------+------------+---------+---------+--------+
| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
+-------+--------+----------+------+------------+---------+---------+--------+
|  7369 | SMITH  | CLERK    | 7902 | 1980-12-17 |  800.00 |         |     20 |
|  7876 | ADAMS  | CLERK    | 7788 | 1987-05-23 | 1100.00 |         |     20 |
|  7900 | JAMES  | CLERK    | 7698 | 1981-12-03 |  950.00 |         |     30 |
|  7934 | MILLER | CLERK    | 7782 | 1982-01-23 | 1300.00 |         |     10 |
|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
|  7698 | BLAKE  | MANAGER  | 7839 | 1981-01-05 | 2850.00 |         |     30 |
|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
+-------+--------+----------+------+------------+---------+---------+--------+
(9 rows)

!ok

# [CALCITE-2071] Query with IN and OR in WHERE clause returns wrong result
select empno
from "scott".emp
where (empno in (select empno from "scott".emp)
    or empno in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25))
and empno in (7876, 7698, 7900);
+-------+
| EMPNO |
+-------+
|  7698 |
|  7876 |
|  7900 |
+-------+
(3 rows)

!ok

# Equivalent to above (by de Morgan's law)
select empno
from "scott".emp
where not (empno not in (select empno from "scott".emp)
  and empno not in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25))
and empno in (7876, 7698, 7900);
+-------+
| EMPNO |
+-------+
|  7698 |
|  7876 |
|  7900 |
+-------+
(3 rows)

!ok

# Not equivalent to above, but happens to have same result
select empno
from "scott".emp
where (empno = 12345
  or empno in (select empno from "scott".emp)
  or not empno in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                   15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25))
and empno in (7876, 7698, 7900);
+-------+
| EMPNO |
+-------+
|  7698 |
|  7876 |
|  7900 |
+-------+
(3 rows)

!ok

# Similar to above, but never suffered from [CALCITE-2071] because AND
select empno
from "scott".emp
where (empno in (select empno from "scott".emp)
      and empno in (7876, 7698, 7900))
and empno in (7876, 7698, 7900);
+-------+
| EMPNO |
+-------+
|  7698 |
|  7876 |
|  7900 |
+-------+
(3 rows)

!ok

!set outputformat psql

# [CALCITE-2329] Enhance SubQueryRemoveRule to rewrite IN operator with the constant from the left side more optimally
# Test project null IN null
select sal,
  cast(null as int) IN (
    select cast(null as int)
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | null
 1250.00 | null
 1250.00 | null
 1300.00 | null
 1500.00 | null
 1600.00 | null
 2450.00 | null
 2850.00 | null
 2975.00 | null
 3000.00 | null
 3000.00 | null
 5000.00 | null
  800.00 | null
  950.00 | null
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[null:BOOLEAN], expr#5=[IS NOT NULL($t3)], expr#6=[AND($t4, $t5)], SAL=[$t1], EXPR$1=[$t6])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[false], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project literal IN null non-correlated
select sal,
  123 IN (
    select cast(null as int)
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | null
 1250.00 | null
 1250.00 | null
 1300.00 | null
 1500.00 | null
 1600.00 | null
 2450.00 | null
 2850.00 | null
 2975.00 | null
 3000.00 | null
 3000.00 | null
 5000.00 | null
  800.00 | null
  950.00 | null
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS FALSE($t2)], expr#5=[null:BOOLEAN], expr#6=[IS NOT NULL($t3)], expr#7=[AND($t4, $t5, $t6)], expr#8=[IS NOT NULL($t2)], expr#9=[IS NOT FALSE($t2)], expr#10=[AND($t8, $t6, $t9)], expr#11=[OR($t7, $t10)], SAL=[$t1], EXPR$1=[$t11])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[false], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project null IN literal non-correlated
select sal,
  cast(null as int) IN (
    select 1
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | null
 1250.00 | null
 1250.00 | null
 1300.00 | null
 1500.00 | null
 1600.00 | null
 2450.00 | null
 2850.00 | null
 2975.00 | null
 3000.00 | null
 3000.00 | null
 5000.00 | null
  800.00 | null
  950.00 | null
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[null:BOOLEAN], expr#5=[IS NOT NULL($t3)], expr#6=[AND($t4, $t5)], SAL=[$t1], EXPR$1=[$t6])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project null IN required
select sal,
  cast(null as int) IN (
    select deptno
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | null
 1250.00 | null
 1250.00 | null
 1300.00 | null
 1500.00 | null
 1600.00 | null
 2450.00 | null
 2850.00 | null
 2975.00 | null
 3000.00 | null
 3000.00 | null
 5000.00 | null
  800.00 | null
  950.00 | null
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[null:BOOLEAN], expr#5=[IS NOT NULL($t3)], expr#6=[AND($t4, $t5)], SAL=[$t1], EXPR$1=[$t6])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project null IN nullable
select sal,
  cast(null as int) IN (
    select case when true then deptno else null end
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | null
 1250.00 | null
 1250.00 | null
 1300.00 | null
 1500.00 | null
 1600.00 | null
 2450.00 | null
 2850.00 | null
 2975.00 | null
 3000.00 | null
 3000.00 | null
 5000.00 | null
  800.00 | null
  950.00 | null
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[null:BOOLEAN], expr#5=[IS NOT NULL($t3)], expr#6=[AND($t4, $t5)], SAL=[$t1], EXPR$1=[$t6])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project literal IN required
select sal,
  10 IN (
    select deptno
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | true
 1250.00 | true
 1250.00 | true
 1300.00 | true
 1500.00 | true
 1600.00 | true
 2450.00 | true
 2850.00 | true
 2975.00 | true
 3000.00 | true
 3000.00 | true
 5000.00 | true
  800.00 | true
  950.00 | true
(14 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t2)], SAL=[$t1], EXPR$1=[$t3])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], expr#4=[10], expr#5=[CAST($t0):INTEGER NOT NULL], expr#6=[=($t4, $t5)], cs=[$t3], $condition=[$t6])
        EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project literal IN nullable
select sal,
  10 IN (
    select case when true then deptno else null end
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | true
 1250.00 | true
 1250.00 | true
 1300.00 | true
 1500.00 | true
 1600.00 | true
 2450.00 | true
 2850.00 | true
 2975.00 | true
 3000.00 | true
 3000.00 | true
 5000.00 | true
  800.00 | true
  950.00 | true
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS FALSE($t2)], expr#5=[null:BOOLEAN], expr#6=[IS NOT NULL($t3)], expr#7=[AND($t4, $t5, $t6)], expr#8=[IS NOT NULL($t2)], expr#9=[IS NOT FALSE($t2)], expr#10=[AND($t8, $t6, $t9)], expr#11=[OR($t7, $t10)], SAL=[$t1], EXPR$1=[$t11])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t0)], expr#4=[CAST($t0):INTEGER], expr#5=[10], expr#6=[=($t4, $t5)], cs=[$t3], $condition=[$t6])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project null NOT IN null non-correlated
select sal,
  cast(null as int) NOT IN (
    select cast(null as int)
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | null
 1250.00 | null
 1250.00 | null
 1300.00 | null
 1500.00 | null
 1600.00 | null
 2450.00 | null
 2850.00 | null
 2975.00 | null
 3000.00 | null
 3000.00 | null
 5000.00 | null
  800.00 | null
  950.00 | null
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], expr#5=[null:BOOLEAN], expr#6=[OR($t4, $t5)], SAL=[$t1], EXPR$1=[$t6])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[false], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project literal NOT IN null non-correlated
select sal,
  123 NOT IN (
    select cast(null as int)
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | null
 1250.00 | null
 1250.00 | null
 1300.00 | null
 1500.00 | null
 1600.00 | null
 2450.00 | null
 2850.00 | null
 2975.00 | null
 3000.00 | null
 3000.00 | null
 5000.00 | null
  800.00 | null
  950.00 | null
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], expr#5=[IS FALSE($t2)], expr#6=[null:BOOLEAN], expr#7=[AND($t5, $t6)], expr#8=[IS NOT FALSE($t2)], expr#9=[IS NULL($t2)], expr#10=[AND($t8, $t9)], expr#11=[OR($t4, $t7, $t10)], SAL=[$t1], EXPR$1=[$t11])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[false], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project null NOT IN literal non-correlated
select sal,
  cast(null as int) NOT IN (
    select 1
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | null
 1250.00 | null
 1250.00 | null
 1300.00 | null
 1500.00 | null
 1600.00 | null
 2450.00 | null
 2850.00 | null
 2975.00 | null
 3000.00 | null
 3000.00 | null
 5000.00 | null
  800.00 | null
  950.00 | null
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], expr#5=[null:BOOLEAN], expr#6=[OR($t4, $t5)], SAL=[$t1], EXPR$1=[$t6])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project null NOT IN required
select sal,
  cast(null as int) NOT IN (
    select deptno
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | null
 1250.00 | null
 1250.00 | null
 1300.00 | null
 1500.00 | null
 1600.00 | null
 2450.00 | null
 2850.00 | null
 2975.00 | null
 3000.00 | null
 3000.00 | null
 5000.00 | null
  800.00 | null
  950.00 | null
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], expr#5=[null:BOOLEAN], expr#6=[OR($t4, $t5)], SAL=[$t1], EXPR$1=[$t6])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project null NOT IN nullable
select sal,
  cast(null as int) NOT IN (
    select case when true then deptno else null end
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | null
 1250.00 | null
 1250.00 | null
 1300.00 | null
 1500.00 | null
 1600.00 | null
 2450.00 | null
 2850.00 | null
 2975.00 | null
 3000.00 | null
 3000.00 | null
 5000.00 | null
  800.00 | null
  950.00 | null
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], expr#5=[null:BOOLEAN], expr#6=[OR($t4, $t5)], SAL=[$t1], EXPR$1=[$t6])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project literal NOT IN required
select sal,
  10 NOT IN (
    select deptno
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | false
 1250.00 | false
 1250.00 | false
 1300.00 | false
 1500.00 | false
 1600.00 | false
 2450.00 | false
 2850.00 | false
 2975.00 | false
 3000.00 | false
 3000.00 | false
 5000.00 | false
  800.00 | false
  950.00 | false
(14 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NULL($t2)], SAL=[$t1], EXPR$1=[$t3])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], expr#4=[10], expr#5=[CAST($t0):INTEGER NOT NULL], expr#6=[=($t4, $t5)], cs=[$t3], $condition=[$t6])
        EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project literal NOT IN nullable
select sal,
  10 NOT IN (
    select case when true then deptno else null end
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | false
 1250.00 | false
 1250.00 | false
 1300.00 | false
 1500.00 | false
 1600.00 | false
 2450.00 | false
 2850.00 | false
 2975.00 | false
 3000.00 | false
 3000.00 | false
 5000.00 | false
  800.00 | false
  950.00 | false
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], expr#5=[IS FALSE($t2)], expr#6=[null:BOOLEAN], expr#7=[AND($t5, $t6)], expr#8=[IS NOT FALSE($t2)], expr#9=[IS NULL($t2)], expr#10=[AND($t8, $t9)], expr#11=[OR($t4, $t7, $t10)], SAL=[$t1], EXPR$1=[$t11])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t0)], expr#4=[CAST($t0):INTEGER], expr#5=[10], expr#6=[=($t4, $t5)], cs=[$t3], $condition=[$t6])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test project null IN required is unknown
select sal,
  cast(null as int) IN (
    select deptno
    from "scott".dept) is unknown
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | true
 1250.00 | true
 1250.00 | true
 1300.00 | true
 1500.00 | true
 1600.00 | true
 2450.00 | true
 2850.00 | true
 2975.00 | true
 3000.00 | true
 3000.00 | true
 5000.00 | true
  800.00 | true
  950.00 | true
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[null:BOOLEAN], expr#5=[IS NOT NULL($t3)], expr#6=[AND($t4, $t5)], expr#7=[IS NULL($t6)], SAL=[$t1], EXPR$1=[$t7])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter null IN null
select sal from "scott".emp
  where cast(null as int) IN (
    select cast(null as int)
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter literal IN null non-correlated
select sal from "scott".emp
  where 123 IN (
    select cast(null as int)
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter null IN literal non-correlated
select sal from "scott".emp
  where cast(null as int) IN (
    select 1
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter null IN required
select sal from "scott".emp
  where cast(null as int) IN (
    select deptno
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter null IN nullable
select sal from "scott".emp
  where cast(null as int) IN (
    select case when true then deptno else null end
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter literal IN required
select sal from "scott".emp
  where 10 IN (
    select deptno
    from "scott".dept);
 SAL
---------
 1100.00
 1250.00
 1250.00
 1300.00
 1500.00
 1600.00
 2450.00
 2850.00
 2975.00
 3000.00
 3000.00
 5000.00
  800.00
  950.00
(14 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], SAL=[$t1])
  EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], expr#4=[10], expr#5=[CAST($t0):INTEGER NOT NULL], expr#6=[=($t4, $t5)], cs=[$t3], $condition=[$t6])
        EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter literal IN nullable
select sal from "scott".emp
  where 10 IN (
    select case when true then deptno else null end
    from "scott".dept);
 SAL
---------
 1100.00
 1250.00
 1250.00
 1300.00
 1500.00
 1600.00
 2450.00
 2850.00
 2975.00
 3000.00
 3000.00
 5000.00
  800.00
  950.00
(14 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], SAL=[$t1])
  EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], expr#4=[10], expr#5=[CAST($t0):INTEGER], expr#6=[=($t4, $t5)], cs=[$t3], $condition=[$t6])
        EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter null NOT IN null non-correlated
select sal from "scott".emp
  where cast(null as int) NOT IN (
    select cast(null as int)
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], SAL=[$t1], $condition=[$t4])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[false], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter literal NOT IN null non-correlated
select sal from "scott".emp
  where 123 NOT IN (
    select cast(null as int)
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], expr#5=[NOT($t2)], expr#6=[IS NOT NULL($t2)], expr#7=[OR($t5, $t6)], expr#8=[IS NOT TRUE($t7)], expr#9=[OR($t4, $t8)], SAL=[$t1], $condition=[$t9])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[false], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter null NOT IN literal non-correlated
select sal from "scott".emp
  where cast(null as int) NOT IN (
    select 1
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], SAL=[$t1], $condition=[$t4])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter null NOT IN required
select sal from "scott".emp
  where cast(null as int) NOT IN (
    select deptno
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], SAL=[$t1], $condition=[$t4])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter null NOT IN nullable
select sal from "scott".emp
  where cast(null as int) NOT IN (
    select case when true then deptno else null end
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], SAL=[$t1], $condition=[$t4])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter literal NOT IN required
select sal from "scott".emp
  where 10 NOT IN (
    select deptno
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], expr#5=[NOT($t2)], expr#6=[IS NOT NULL($t2)], expr#7=[OR($t5, $t6)], expr#8=[IS NOT TRUE($t7)], expr#9=[OR($t4, $t8)], SAL=[$t1], $condition=[$t9])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], expr#4=[10], expr#5=[CAST($t0):INTEGER NOT NULL], expr#6=[=($t4, $t5)], cs=[$t3], $condition=[$t6])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter literal NOT IN nullable
select sal from "scott".emp
  where 10 NOT IN (
    select case when true then deptno else null end
    from "scott".dept);
 SAL
-----
(0 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NULL($t3)], expr#5=[NOT($t2)], expr#6=[IS NOT NULL($t2)], expr#7=[OR($t5, $t6)], expr#8=[IS NOT TRUE($t7)], expr#9=[OR($t4, $t8)], SAL=[$t1], $condition=[$t9])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t0)], expr#4=[CAST($t0):INTEGER], expr#5=[10], expr#6=[=($t4, $t5)], cs=[$t3], $condition=[$t6])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter null IN required is unknown
select sal from "scott".emp
  where cast(null as int) IN (
    select deptno
    from "scott".dept) is unknown;
 SAL
---------
 1100.00
 1250.00
 1250.00
 1300.00
 1500.00
 1600.00
 2450.00
 2850.00
 2975.00
 3000.00
 3000.00
 5000.00
  800.00
  950.00
(14 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], expr#4=[null:BOOLEAN], expr#5=[IS NOT NULL($t3)], expr#6=[AND($t4, $t5)], expr#7=[IS NULL($t6)], SAL=[$t1], $condition=[$t7])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], cs=[$t3])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

#-------------------------------

# Test filter null IN null correlated
select sal from "scott".emp e
  where cast(null as int) IN (
    select cast(null as int)
    from "scott".dept d where e.deptno=d.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter literal IN null correlated
select sal from "scott".emp e
  where 123 IN (
    select cast(null as int)
    from "scott".dept d where e.deptno=d.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter null IN literal correlated
select sal from "scott".emp e
  where cast(null as int) IN (
    select 1
    from "scott".dept d where e.deptno=d.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter null IN required correlated
select sal from "scott".emp e
  where cast(null as int) IN (
    select deptno
    from "scott".dept d where e.deptno=d.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter literal IN null liter with query that can not be trivially simplified
select sal from "scott".emp e
  where mod(cast(rand() as int), 2) = 3 OR 123 IN (
    select cast(null as int) from "scott".dept d
      where d.deptno = e.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], expr#5=[RAND()], expr#6=[CAST($t5):INTEGER NOT NULL], expr#7=[2], expr#8=[MOD($t6, $t7)], expr#9=[3], expr#10=[=($t8, $t9)], expr#11=[OR($t10, $t3)], SAL=[$t1], $condition=[$t11])
  EnumerableMergeJoin(condition=[=($2, $4)], joinType=[left])
    EnumerableSort(sort0=[$2], dir0=[ASC])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], cs=[$t1], DEPTNO=[$t0])
        EnumerableWindow(window#0=[window(partition {0} aggs [FIRST_VALUE($1)])], constants=[[false]])
          EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter null IN nullable correlated
select sal from "scott".emp e
  where cast(null as int) IN (
    select case when true then deptno else null end
    from "scott".dept d where e.deptno=d.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter literal IN required correlated
select sal from "scott".emp e
  where 10 IN (
    select deptno
    from "scott".dept d where e.deptno=d.deptno);
 SAL
---------
 1300.00
 2450.00
 5000.00
(3 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], SAL=[$t1])
  EnumerableHashJoin(condition=[=($2, $3)], joinType=[semi])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[10], expr#4=[CAST($t0):INTEGER NOT NULL], expr#5=[=($t3, $t4)], DEPTNO=[$t0], $condition=[$t5])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter literal IN nullable correlated
select sal from "scott".emp e
  where 10 IN (
    select case when true then deptno else null end
    from "scott".dept d where e.deptno=d.deptno);
 SAL
---------
 1300.00
 2450.00
 5000.00
(3 rows)

!ok
EnumerableCalc(expr#0..2=[{inputs}], SAL=[$t1])
  EnumerableHashJoin(condition=[=($2, $3)], joinType=[semi])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[10], expr#4=[CAST($t0):INTEGER], expr#5=[=($t3, $t4)], DEPTNO=[$t0], $condition=[$t5])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter null NOT IN null correlated
select sal from "scott".emp e
  where cast(null as int) NOT IN (
    select cast(null as int)
    from "scott".dept d where e.deptno=d.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter literal NOT IN null correlated
select sal from "scott".emp e
  where 123 NOT IN (
    select cast(null as int)
    from "scott".dept d where e.deptno=d.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], expr#5=[NOT($t3)], expr#6=[IS NOT NULL($t3)], expr#7=[OR($t5, $t6)], expr#8=[IS NOT TRUE($t7)], SAL=[$t1], $condition=[$t8])
  EnumerableMergeJoin(condition=[=($2, $4)], joinType=[left])
    EnumerableSort(sort0=[$2], dir0=[ASC])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], cs=[$t1], DEPTNO=[$t0])
        EnumerableWindow(window#0=[window(partition {0} aggs [FIRST_VALUE($1)])], constants=[[false]])
          EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter null NOT IN literal correlated
select sal from "scott".emp e
  where cast(null as int) NOT IN (
    select 1
    from "scott".dept d where e.deptno=d.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter null NOT IN required correlated
select sal from "scott".emp e
  where cast(null as int) NOT IN (
    select deptno
    from "scott".dept d where e.deptno=d.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter null NOT IN nullable correlated
select sal from "scott".emp e
  where cast(null as int) NOT IN (
    select case when true then deptno else null end
    from "scott".dept d where e.deptno=d.deptno);
 SAL
-----
(0 rows)

!ok
EnumerableValues(tuples=[[]])
!plan

# Test filter literal NOT IN required correlated
select sal from "scott".emp e
  where 10 NOT IN (
    select deptno
    from "scott".dept d where e.deptno=d.deptno);
 SAL
---------
 1100.00
 1250.00
 1250.00
 1500.00
 1600.00
 2850.00
 2975.00
 3000.00
 3000.00
  800.00
  950.00
(11 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], expr#5=[NOT($t3)], expr#6=[IS NOT NULL($t3)], expr#7=[OR($t5, $t6)], expr#8=[IS NOT TRUE($t7)], SAL=[$t1], $condition=[$t8])
  EnumerableMergeJoin(condition=[=($2, $4)], joinType=[left])
    EnumerableSort(sort0=[$2], dir0=[ASC])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], cs=[$t1], DEPTNO1=[$t0])
        EnumerableWindow(window#0=[window(partition {0} aggs [FIRST_VALUE($1)])], constants=[[true]])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[10], expr#4=[CAST($t0):INTEGER NOT NULL], expr#5=[=($t3, $t4)], DEPTNO=[$t0], $condition=[$t5])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter literal NOT IN nullable correlated
select sal from "scott".emp e
  where 10 NOT IN (
    select case when true then deptno else null end
    from "scott".dept d where e.deptno=d.deptno);
 SAL
---------
 1100.00
 1250.00
 1250.00
 1500.00
 1600.00
 2850.00
 2975.00
 3000.00
 3000.00
  800.00
  950.00
(11 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], expr#5=[NOT($t3)], expr#6=[IS NOT NULL($t3)], expr#7=[OR($t5, $t6)], expr#8=[IS NOT TRUE($t7)], SAL=[$t1], $condition=[$t8])
  EnumerableMergeJoin(condition=[=($2, $4)], joinType=[left])
    EnumerableSort(sort0=[$2], dir0=[ASC])
      EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])
        EnumerableTableScan(table=[[scott, EMP]])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], cs=[$t1], DEPTNO=[$t0])
        EnumerableWindow(window#0=[window(partition {0} aggs [FIRST_VALUE($1)])], constants=[[true]])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER], expr#4=[10], expr#5=[=($t3, $t4)], DEPTNO=[$t0], $condition=[$t5])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test filter null IN required is unknown correlated
select sal from "scott".emp e
  where cast(null as int) IN (
    select deptno
    from "scott".dept d where e.deptno=d.deptno) is unknown;
 SAL
---------
 1100.00
 1250.00
 1250.00
 1300.00
 1500.00
 1600.00
 2450.00
 2850.00
 2975.00
 3000.00
 3000.00
 5000.00
  800.00
  950.00
(14 rows)

!ok
EnumerableCalc(expr#0..7=[{inputs}], SAL=[$t5])
  EnumerableTableScan(table=[[scott, EMP]])
!plan


# Test project constant IN an expression that is sometimes null
select sal,
  20 IN (
    select case when deptno > 10 then deptno else null end
    from "scott".dept)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | true
 1250.00 | true
 1250.00 | true
 1300.00 | true
 1500.00 | true
 1600.00 | true
 2450.00 | true
 2850.00 | true
 2975.00 | true
 3000.00 | true
 3000.00 | true
 5000.00 | true
  800.00 | true
  950.00 | true
(14 rows)

!ok

# Test project constant IN an nullable expression in an empty relation
select sal,
  20 IN (
    select case when deptno > 10 then deptno else null end
    from "scott".dept
    where deptno < 0)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | false
 1250.00 | false
 1250.00 | false
 1300.00 | false
 1500.00 | false
 1600.00 | false
 2450.00 | false
 2850.00 | false
 2975.00 | false
 3000.00 | false
 3000.00 | false
 5000.00 | false
  800.00 | false
  950.00 | false
(14 rows)

!ok

# Test project null IN an nullable expression in an empty relation
select sal,
  cast(null as integer) IN (
    select case when deptno > 10 then deptno else null end
    from "scott".dept
    where deptno < 0)
from "scott".emp;
 SAL     | EXPR$1
---------+--------
 1100.00 | false
 1250.00 | false
 1250.00 | false
 1300.00 | false
 1500.00 | false
 1600.00 | false
 2450.00 | false
 2850.00 | false
 2975.00 | false
 3000.00 | false
 3000.00 | false
 5000.00 | false
  800.00 | false
  950.00 | false
(14 rows)

!ok

# Test nested sub-query in PROJECT within FILTER
select * from emp where deptno IN (select (select max(deptno) from "scott".emp t1) from "scott".emp t2);
 EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO
-------+--------+----------+------+------------+---------+---------+--------
  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30
  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30
  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30
  7698 | BLAKE  | MANAGER  | 7839 | 1981-01-05 | 2850.00 |         |     30
  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30
  7900 | JAMES  | CLERK    | 7698 | 1981-12-03 |  950.00 |         |     30
(6 rows)

!ok
EnumerableHashJoin(condition=[=($7, $9)], joinType=[semi])
  EnumerableTableScan(table=[[scott, EMP]])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableAggregate(group=[{}], EXPR$0=[MAX($7)])
      EnumerableTableScan(table=[[scott, EMP]])
!plan

# Test nested sub-query in FILTER within PROJECT
select (select max(deptno) from "scott".emp where deptno IN (select deptno from "scott".emp)) from emp ;
 EXPR$0
--------
     30
     30
     30
     30
     30
     30
     30
     30
     30
     30
     30
     30
     30
     30
(14 rows)

!ok
EnumerableCalc(expr#0..1=[{inputs}], EXPR$0=[$t1])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableAggregate(group=[{}], EXPR$0=[MAX($1)])
      EnumerableHashJoin(condition=[=($1, $9)], joinType=[semi])
        EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
          EnumerableTableScan(table=[[scott, EMP]])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

!use scott

# [CALCITE-1513] Correlated NOT IN query throws AssertionError
select count(*) as c
from "scott".emp as e
where sal + 100 not in (
  select deptno
  from dept
  where dname = e.ename);
 C
----
 14
(1 row)

!ok
EnumerableAggregate(group=[{}], C=[COUNT()])
  EnumerableCalc(expr#0..7=[{inputs}], expr#8=[0], expr#9=[=($t1, $t8)], expr#10=[IS NULL($t0)], expr#11=[IS NOT NULL($t7)], expr#12=[<($t2, $t1)], expr#13=[OR($t10, $t11, $t12)], expr#14=[IS NOT TRUE($t13)], expr#15=[OR($t9, $t14)], proj#0..7=[{exprs}], $condition=[$t15])
    EnumerableMergeJoin(condition=[AND(=($3, $5), =($4, $6))], joinType=[left])
      EnumerableSort(sort0=[$3], sort1=[$4], dir0=[ASC], dir1=[ASC])
        EnumerableCalc(expr#0..6=[{inputs}], expr#7=[100], expr#8=[+($t2, $t7)], expr#9=[CAST($t1):VARCHAR(14)], SAL=[$t2], c=[$t4], ck=[$t5], $f5=[$t8], ENAME0=[$t9])
          EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($3, $6)], joinType=[left])
            EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t1):VARCHAR(14)], proj#0..1=[{exprs}], SAL=[$t5], ENAME0=[$t8])
              EnumerableTableScan(table=[[scott, EMP]])
            EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t2)], expr#4=[0], expr#5=[CASE($t3, $t2, $t4)], c=[$t5], ck=[$t5], DNAME=[$t0])
              EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
                EnumerableAggregate(group=[{0}])
                  EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t1):VARCHAR(14)], ENAME0=[$t8])
                    EnumerableTableScan(table=[[scott, EMP]])
                EnumerableCalc(expr#0..2=[{inputs}], expr#3=[1:BIGINT], expr#4=[IS NOT NULL($t1)], DNAME=[$t1], $f1=[$t3], $condition=[$t4])
                  EnumerableTableScan(table=[[scott, DEPT]])
      EnumerableSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])
        EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):DECIMAL(13, 2) NOT NULL], expr#4=[true], expr#5=[IS NOT NULL($t1)], DEPTNO=[$t3], DNAME=[$t1], i=[$t4], $condition=[$t5])
          EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Correlated ANY sub-query
select empno from "scott".emp as e
where e.empno > ANY(
  select 2 from "scott".dept e2 where e2.deptno = e.deptno) ;
EnumerableCalc(expr#0..6=[{inputs}], EMPNO=[$t5])
  EnumerableNestedLoopJoin(condition=[AND(IS NOT DISTINCT FROM($6, $4), OR(AND(>($5, $0), IS NOT TRUE(OR(IS NULL($3), =($1, 0)))), AND(>($5, $0), IS NOT TRUE(OR(IS NULL($3), =($1, 0))), IS NOT TRUE(>($5, $0)), <=($1, $2))))], joinType=[inner])
    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[IS NOT NULL($t3)], expr#6=[0], expr#7=[CASE($t5, $t3, $t6)], m=[$t2], c=[$t7], d=[$t7], trueLiteral=[$t4], DEPTNO=[$t0])
      EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableAggregate(group=[{7}])
          EnumerableTableScan(table=[[scott, EMP]])
        EnumerableCalc(expr#0..2=[{inputs}], expr#3=[2], expr#4=[1:BIGINT], expr#5=[true], DEPTNO=[$t0], EXPR$0=[$t3], $f2=[$t4], $f3=[$t5])
          EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
      EnumerableTableScan(table=[[scott, EMP]])
!plan
 EMPNO
-------
  7369
  7499
  7521
  7566
  7654
  7698
  7782
  7788
  7839
  7844
  7876
  7900
  7902
  7934
(14 rows)

!ok

# # inner query produces empty result therefore ANY should produce 'false'
select empno,
e.deptno > ANY(
  select 2 from "scott".dept e2 where e2.deptno = e.empno) from "scott".emp as e;

EnumerableCalc(expr#0..6=[{inputs}], expr#7=[>($t1, $t2)], expr#8=[IS TRUE($t7)], expr#9=[IS NULL($t5)], expr#10=[0], expr#11=[=($t3, $t10)], expr#12=[OR($t9, $t11)], expr#13=[IS NOT TRUE($t12)], expr#14=[AND($t8, $t13)], expr#15=[>($t3, $t4)], expr#16=[IS TRUE($t15)], expr#17=[null:BOOLEAN], expr#18=[IS NOT TRUE($t7)], expr#19=[AND($t16, $t17, $t13, $t18)], expr#20=[IS NOT TRUE($t15)], expr#21=[AND($t7, $t13, $t18, $t20)], expr#22=[OR($t14, $t19, $t21)], EMPNO=[$t0], EXPR$1=[$t22])
  EnumerableHashJoin(condition=[=($0, $6)], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], DEPTNO=[$t7])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[IS NOT NULL($t3)], expr#6=[0], expr#7=[CASE($t5, $t3, $t6)], m=[$t2], c=[$t7], d=[$t7], trueLiteral=[$t4], DEPTNO0=[$t0])
      EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0])
          EnumerableTableScan(table=[[scott, EMP]])
        EnumerableAggregate(group=[{0}], m=[MIN($1)], c=[COUNT()], trueLiteral=[LITERAL_AGG(true)])
          EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):SMALLINT NOT NULL], expr#4=[2], DEPTNO0=[$t3], EXPR$0=[$t4])
            EnumerableTableScan(table=[[scott, DEPT]])
!plan
 EMPNO | EXPR$1
-------+--------
  7369 | false
  7499 | false
  7521 | false
  7566 | false
  7654 | false
  7698 | false
  7782 | false
  7788 | false
  7839 | false
  7844 | false
  7876 | false
  7900 | false
  7902 | false
  7934 | false
(14 rows)

!ok

# [CALCITE-4560] Wrong plan when decorrelating EXISTS subquery with COALESCE in the predicate
# The employee KING has no manager (NULL) so before the fix the following query was missing
# this employee from the result set.
select ename
from "scott".emp as e1
where exists
    (select 1 from "scott".emp as e2 where coalesce(e1.mgr,0)=coalesce(e2.mgr,0));
# The plan before the fix was wrong but also inefficient since it required the generation of
# a value generator (see RelDecorrelator code). The value generator is not present in the
# following plan (two scans of EMP table instead of three).
EnumerableCalc(expr#0..2=[{inputs}], ENAME=[$t1])
  EnumerableHashJoin(condition=[=($2, $3)], joinType=[semi])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t3)], expr#9=[CAST($t3):INTEGER NOT NULL], expr#10=[0], expr#11=[CASE($t8, $t9, $t10)], proj#0..1=[{exprs}], $f3=[$t11])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t3)], expr#9=[CAST($t3):INTEGER NOT NULL], expr#10=[0], expr#11=[CASE($t8, $t9, $t10)], $f8=[$t11])
      EnumerableTableScan(table=[[scott, EMP]])
!plan
 ENAME
--------
 ADAMS
 ALLEN
 BLAKE
 CLARK
 FORD
 JAMES
 JONES
 KING
 MARTIN
 MILLER
 SCOTT
 SMITH
 TURNER
 WARD
(14 rows)

!ok

!set outputformat mysql
# Correlated SOME sub-query with not equality
# Both sides Not NUll.
select empno
from "scott".emp emp1
where empno <> some (select emp2.empno from "scott".emp emp2 where emp2.empno = emp1.empno);
EnumerableCalc(expr#0..6=[{inputs}], expr#7=[<>($t2, $t1)], expr#8=[1], expr#9=[<=($t3, $t8)], expr#10=[<>($t0, $t4)], expr#11=[IS NULL($t5)], expr#12=[0], expr#13=[=($t1, $t12)], expr#14=[OR($t11, $t13)], expr#15=[IS NOT TRUE($t14)], expr#16=[AND($t7, $t9, $t10, $t15)], expr#17=[=($t3, $t8)], expr#18=[IS NOT NULL($t3)], expr#19=[AND($t7, $t18)], expr#20=[IS NOT TRUE($t19)], expr#21=[AND($t17, $t10, $t15, $t20)], expr#22=[AND($t7, $t9)], expr#23=[IS NOT TRUE($t22)], expr#24=[IS NOT TRUE($t17)], expr#25=[AND($t15, $t23, $t24)], expr#26=[OR($t16, $t21, $t25)], EMPNO=[$t0], $condition=[$t26])
  EnumerableHashJoin(condition=[=($0, $6)], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..5=[{inputs}], expr#6=[IS NOT NULL($t2)], expr#7=[0], expr#8=[CASE($t6, $t2, $t7)], expr#9=[IS NOT NULL($t3)], expr#10=[CASE($t9, $t3, $t7)], c=[$t8], d=[$t8], dd=[$t10], m=[$t4], trueLiteral=[$t5], EMPNO1=[$t0])
      EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0])
          EnumerableTableScan(table=[[scott, EMP]])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[1:BIGINT], expr#9=[true], EMPNO1=[$t0], $f1=[$t8], $f2=[$t8], EMPNO=[$t0], $f4=[$t9])
          EnumerableTableScan(table=[[scott, EMP]])
!plan
+-------+
| EMPNO |
+-------+
+-------+
(0 rows)

!ok

# Previous, as scalar sub-query.
select empno, empno <> some (select emp2.empno from "scott".emp emp2 where emp2.empno = emp1.empno) as x
from "scott".emp emp1;
+-------+-------+
| EMPNO | X     |
+-------+-------+
|  7369 | false |
|  7499 | false |
|  7521 | false |
|  7566 | false |
|  7654 | false |
|  7698 | false |
|  7782 | false |
|  7788 | false |
|  7839 | false |
|  7844 | false |
|  7876 | false |
|  7900 | false |
|  7902 | false |
|  7934 | false |
+-------+-------+
(14 rows)

!ok

# left side NOT NULL, correlated sub-query nullable.
select *
from "scott".emp emp1
where empno <> some (select comm from "scott".emp where deptno = emp1.deptno);
EnumerableCalc(expr#0..13=[{inputs}], expr#14=[<>($t10, $t9)], expr#15=[1], expr#16=[<=($t11, $t15)], expr#17=[AND($t14, $t16)], expr#18=[=($t11, $t15)], expr#19=[OR($t17, $t18)], expr#20=[<>($t0, $t12)], expr#21=[IS NULL($t13)], expr#22=[0], expr#23=[=($t9, $t22)], expr#24=[OR($t21, $t23)], expr#25=[IS NOT TRUE($t24)], expr#26=[AND($t19, $t20, $t25)], expr#27=[IS NOT TRUE($t19)], expr#28=[AND($t25, $t27)], expr#29=[OR($t26, $t28)], proj#0..7=[{exprs}], $condition=[$t29])
  EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($7, $8)], joinType=[left])
    EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..6=[{inputs}], expr#7=[IS NOT NULL($t2)], expr#8=[0], expr#9=[CASE($t7, $t2, $t8)], expr#10=[IS NOT NULL($t3)], expr#11=[CASE($t10, $t3, $t8)], expr#12=[IS NOT NULL($t4)], expr#13=[CASE($t12, $t4, $t8)], DEPTNO=[$t0], c=[$t9], d=[$t11], dd=[$t13], m=[$t5], trueLiteral=[$t6])
      EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableAggregate(group=[{7}])
          EnumerableTableScan(table=[[scott, EMP]])
        EnumerableCalc(expr#0..5=[{inputs}], expr#6=[CAST($t1):BIGINT NOT NULL], expr#7=[CAST($t2):BIGINT NOT NULL], expr#8=[CAST($t5):BOOLEAN NOT NULL], DEPTNO=[$t0], c=[$t6], d=[$t7], dd=[$t3], m=[$t4], trueLiteral=[$t8])
          EnumerableAggregate(group=[{1}], c=[MIN($2) FILTER $7], d=[MIN($3) FILTER $7], dd=[COUNT($0) FILTER $6], m=[MIN($4) FILTER $7], trueLiteral=[MIN(true, $5) FILTER $7])
            EnumerableCalc(expr#0..6=[{inputs}], expr#7=[0], expr#8=[=($t6, $t7)], expr#9=[2], expr#10=[=($t6, $t9)], proj#0..5=[{exprs}], $g_0=[$t8], $g_2=[$t10])
              EnumerableAggregate(group=[{6, 7}], groups=[[{6, 7}, {7}]], c=[COUNT()], d=[COUNT($6)], m=[MAX($6)], trueLiteral=[LITERAL_AGG(true)], $g=[GROUPING($6, $7)])
                EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
                  EnumerableTableScan(table=[[scott, EMP]])
!plan
+-------+--------+----------+------+------------+---------+---------+--------+
| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
+-------+--------+----------+------+------------+---------+---------+--------+
|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
|  7698 | BLAKE  | MANAGER  | 7839 | 1981-01-05 | 2850.00 |         |     30 |
|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
|  7900 | JAMES  | CLERK    | 7698 | 1981-12-03 |  950.00 |         |     30 |
+-------+--------+----------+------+------------+---------+---------+--------+
(6 rows)

!ok

# Previous, as scalar sub-query.
select *, empno <> some (select comm from "scott".emp where deptno = emp1.deptno) as x
from "scott".emp as emp1;
+-------+--------+-----------+------+------------+---------+---------+--------+------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | X    |
+-------+--------+-----------+------+------------+---------+---------+--------+------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |      |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 | true |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 | true |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |      |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 | true |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 | true |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |      |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |      |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |      |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 | true |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |      |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 | true |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |      |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |      |
+-------+--------+-----------+------+------------+---------+---------+--------+------+
(14 rows)

!ok

# left side NOT NULL, correlated sub-query empty.
select *
from "scott".emp as emp1
where empno <> some (select 2 from "scott".dept dept1 where dept1.deptno = emp1.empno);
EnumerableCalc(expr#0..13=[{inputs}], expr#14=[<>($t9, $t8)], expr#15=[1], expr#16=[<=($t10, $t15)], expr#17=[<>($t0, $t11)], expr#18=[IS NULL($t12)], expr#19=[0], expr#20=[=($t8, $t19)], expr#21=[OR($t18, $t20)], expr#22=[IS NOT TRUE($t21)], expr#23=[AND($t14, $t16, $t17, $t22)], expr#24=[=($t10, $t15)], expr#25=[IS NOT NULL($t10)], expr#26=[AND($t14, $t25)], expr#27=[IS NOT TRUE($t26)], expr#28=[AND($t24, $t17, $t22, $t27)], expr#29=[AND($t14, $t16)], expr#30=[IS NOT TRUE($t29)], expr#31=[IS NOT TRUE($t24)], expr#32=[AND($t22, $t30, $t31)], expr#33=[OR($t23, $t28, $t32)], proj#0..7=[{exprs}], $condition=[$t33])
  EnumerableHashJoin(condition=[=($0, $13)], joinType=[left])
    EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..5=[{inputs}], expr#6=[IS NOT NULL($t2)], expr#7=[0], expr#8=[CASE($t6, $t2, $t7)], expr#9=[IS NOT NULL($t3)], expr#10=[CASE($t9, $t3, $t7)], c=[$t8], d=[$t8], dd=[$t10], m=[$t4], trueLiteral=[$t5], DEPTNO0=[$t0])
      EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0])
          EnumerableTableScan(table=[[scott, EMP]])
        EnumerableCalc(expr#0..4=[{inputs}], expr#5=[CAST($t1):BIGINT NOT NULL], expr#6=[CAST($t3):INTEGER NOT NULL], expr#7=[CAST($t4):BOOLEAN NOT NULL], DEPTNO0=[$t0], c=[$t5], dd=[$t2], m=[$t6], trueLiteral=[$t7])
          EnumerableAggregate(group=[{0}], c=[MIN($2) FILTER $6], dd=[COUNT($1) FILTER $5], m=[MIN($3) FILTER $6], trueLiteral=[MIN(true, $4) FILTER $6])
            EnumerableCalc(expr#0..5=[{inputs}], expr#6=[0], expr#7=[=($t5, $t6)], expr#8=[1], expr#9=[=($t5, $t8)], proj#0..4=[{exprs}], $g_0=[$t7], $g_1=[$t9])
              EnumerableAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}]], c=[COUNT()], m=[MAX($1)], trueLiteral=[LITERAL_AGG(true)], $g=[GROUPING($0, $1)])
                EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):SMALLINT NOT NULL], expr#4=[2], DEPTNO0=[$t3], EXPR$0=[$t4])
                  EnumerableTableScan(table=[[scott, DEPT]])
!plan
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

# Previous, as scalar sub-query.
select *, empno <> some (select 2 from "scott".dept dept1 where dept1.deptno = emp1.empno) as x
from "scott".emp as emp1;
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | X     |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 | false |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 | false |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 | false |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 | false |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 | false |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 | false |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 | false |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 | false |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 | false |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 | false |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 | false |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 | false |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 | false |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 | false |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
(14 rows)

!ok

# left side nullable, correlated sub-query empty.
select *
from "scott".emp as emp1
where comm <> some (select 2 from "scott".dept dept1 where dept1.deptno = emp1.empno);
EnumerableCalc(expr#0..13=[{inputs}], expr#14=[<>($t9, $t8)], expr#15=[1], expr#16=[<=($t10, $t15)], expr#17=[AND($t14, $t16)], expr#18=[=($t10, $t15)], expr#19=[OR($t17, $t18)], expr#20=[<>($t6, $t11)], expr#21=[IS NULL($t12)], expr#22=[IS NULL($t6)], expr#23=[0], expr#24=[=($t8, $t23)], expr#25=[OR($t21, $t22, $t24)], expr#26=[IS NOT TRUE($t25)], expr#27=[AND($t19, $t20, $t26)], expr#28=[IS NOT TRUE($t19)], expr#29=[AND($t26, $t28)], expr#30=[OR($t27, $t29)], proj#0..7=[{exprs}], $condition=[$t30])
  EnumerableHashJoin(condition=[=($0, $13)], joinType=[left])
    EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..5=[{inputs}], expr#6=[IS NOT NULL($t2)], expr#7=[0], expr#8=[CASE($t6, $t2, $t7)], expr#9=[IS NOT NULL($t3)], expr#10=[CASE($t9, $t3, $t7)], c=[$t8], d=[$t8], dd=[$t10], m=[$t4], trueLiteral=[$t5], DEPTNO0=[$t0])
      EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0])
          EnumerableTableScan(table=[[scott, EMP]])
        EnumerableCalc(expr#0..4=[{inputs}], expr#5=[CAST($t1):BIGINT NOT NULL], expr#6=[CAST($t3):INTEGER NOT NULL], expr#7=[CAST($t4):BOOLEAN NOT NULL], DEPTNO0=[$t0], c=[$t5], dd=[$t2], m=[$t6], trueLiteral=[$t7])
          EnumerableAggregate(group=[{0}], c=[MIN($2) FILTER $6], dd=[COUNT($1) FILTER $5], m=[MIN($3) FILTER $6], trueLiteral=[MIN(true, $4) FILTER $6])
            EnumerableCalc(expr#0..5=[{inputs}], expr#6=[0], expr#7=[=($t5, $t6)], expr#8=[1], expr#9=[=($t5, $t8)], proj#0..4=[{exprs}], $g_0=[$t7], $g_1=[$t9])
              EnumerableAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}]], c=[COUNT()], m=[MAX($1)], trueLiteral=[LITERAL_AGG(true)], $g=[GROUPING($0, $1)])
                EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):SMALLINT NOT NULL], expr#4=[2], DEPTNO0=[$t3], EXPR$0=[$t4])
                  EnumerableTableScan(table=[[scott, DEPT]])
!plan
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

# Previous, as scalar sub-query.
select *, comm <> some (select 2 from "scott".dept dept1 where dept1.deptno = emp1.empno) as x
from "scott".emp as emp1;
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | X     |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 | false |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 | false |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 | false |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 | false |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 | false |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 | false |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 | false |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 | false |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 | false |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 | false |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 | false |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 | false |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 | false |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 | false |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
(14 rows)

!ok

# left side nullable, correlated sub-query nullable.
select *
from "scott".emp emp1
where emp1.comm <> some (select comm from "scott".emp emp2 where emp2.sal = emp1.sal);
EnumerableCalc(expr#0..13=[{inputs}], expr#14=[<>($t10, $t9)], expr#15=[1], expr#16=[<=($t11, $t15)], expr#17=[AND($t14, $t16)], expr#18=[=($t11, $t15)], expr#19=[OR($t17, $t18)], expr#20=[<>($t6, $t12)], expr#21=[IS NULL($t13)], expr#22=[IS NULL($t6)], expr#23=[0], expr#24=[=($t9, $t23)], expr#25=[OR($t21, $t22, $t24)], expr#26=[IS NOT TRUE($t25)], expr#27=[AND($t19, $t20, $t26)], expr#28=[IS NOT TRUE($t19)], expr#29=[AND($t26, $t28)], expr#30=[OR($t27, $t29)], proj#0..7=[{exprs}], $condition=[$t30])
  EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($5, $8)], joinType=[left])
    EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..6=[{inputs}], expr#7=[IS NOT NULL($t2)], expr#8=[0], expr#9=[CASE($t7, $t2, $t8)], expr#10=[IS NOT NULL($t3)], expr#11=[CASE($t10, $t3, $t8)], expr#12=[IS NOT NULL($t4)], expr#13=[CASE($t12, $t4, $t8)], SAL=[$t0], c=[$t9], d=[$t11], dd=[$t13], m=[$t5], trueLiteral=[$t6])
      EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableAggregate(group=[{5}])
          EnumerableTableScan(table=[[scott, EMP]])
        EnumerableCalc(expr#0..5=[{inputs}], expr#6=[CAST($t1):BIGINT NOT NULL], expr#7=[CAST($t2):BIGINT NOT NULL], expr#8=[CAST($t5):BOOLEAN NOT NULL], SAL=[$t0], c=[$t6], d=[$t7], dd=[$t3], m=[$t4], trueLiteral=[$t8])
          EnumerableAggregate(group=[{0}], c=[MIN($2) FILTER $7], d=[MIN($3) FILTER $7], dd=[COUNT($1) FILTER $6], m=[MIN($4) FILTER $7], trueLiteral=[MIN(true, $5) FILTER $7])
            EnumerableCalc(expr#0..6=[{inputs}], expr#7=[0], expr#8=[=($t6, $t7)], expr#9=[1], expr#10=[=($t6, $t9)], proj#0..5=[{exprs}], $g_0=[$t8], $g_1=[$t10])
              EnumerableAggregate(group=[{5, 6}], groups=[[{5, 6}, {5}]], c=[COUNT()], d=[COUNT($6)], m=[MAX($6)], trueLiteral=[LITERAL_AGG(true)], $g=[GROUPING($5, $6)])
                EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t5)], proj#0..7=[{exprs}], $condition=[$t8])
                  EnumerableTableScan(table=[[scott, EMP]])
!plan
+-------+--------+----------+------+------------+---------+---------+--------+
| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
+-------+--------+----------+------+------------+---------+---------+--------+
|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
+-------+--------+----------+------+------------+---------+---------+--------+
(2 rows)

!ok

# Previous, as scalar sub-query.
select *, emp1.comm <> some (select comm from "scott".emp where sal = emp1.sal) as x
from "scott".emp emp1;
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | X     |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |       |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 | false |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 | true  |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |       |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 | true  |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |       |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |       |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |       |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |       |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 | false |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |       |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |       |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |       |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |       |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
(14 rows)

!ok

WITH tb as (select array(SELECT * FROM (VALUES (TRUE), (NULL)) as x(a)) as a)
SELECT TRUE = ALL (
    SELECT b
    FROM UNNEST(a) AS x1(b)
) AS test
FROM tb;
+------+
| TEST |
+------+
|      |
+------+
(1 row)

!ok

# [CALCITE-4486] UNIQUE predicate
!use scott
!set outputformat mysql

# singleton keys have unique value which excludes fully or partially null rows.
select deptno
from "scott".dept
where unique (select comm from "scott".emp where comm is not null);
+--------+
| DEPTNO |
+--------+
|     10 |
|     30 |
|     40 |
|     20 |
+--------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], $condition=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
        EnumerableAggregate(group=[{6}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t6)], proj#0..7=[{exprs}], $condition=[$t8])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, as scalar sub-query.
select deptno, unique (select comm from "scott".emp where comm is not null) as u
from "scott".dept;
+--------+------+
| DEPTNO | U    |
+--------+------+
|     10 | true |
|     20 | true |
|     30 | true |
|     40 | true |
+--------+------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], U=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
        EnumerableAggregate(group=[{6}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t6)], proj#0..7=[{exprs}], $condition=[$t8])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, but NOT UNIQUE.
select deptno, not unique (select comm from "scott".emp where comm is not null) as u
from "scott".dept;
+--------+-------+
| DEPTNO | U     |
+--------+-------+
|     10 | false |
|     20 | false |
|     30 | false |
|     40 | false |
+--------+-------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NOT NULL($t1)], DEPTNO=[$t0], U=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
        EnumerableAggregate(group=[{6}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t6)], proj#0..7=[{exprs}], $condition=[$t8])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# singleton keys have unique value which includes partial null rows.
select deptno
from "scott".dept
where unique (select comm from "scott".emp);
+--------+
| DEPTNO |
+--------+
|     10 |
|     30 |
|     40 |
|     20 |
+--------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], $condition=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
        EnumerableAggregate(group=[{6}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t6)], proj#0..7=[{exprs}], $condition=[$t8])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, as scalar sub-query.
select deptno, unique (select comm from "scott".emp) as u
from "scott".dept;
+--------+------+
| DEPTNO | U    |
+--------+------+
|     10 | true |
|     20 | true |
|     30 | true |
|     40 | true |
+--------+------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], U=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
        EnumerableAggregate(group=[{6}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t6)], proj#0..7=[{exprs}], $condition=[$t8])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# singleton keys which includes fully null rows.
select deptno
from "scott".dept
where unique (select comm from "scott".emp where comm is null);
+--------+
| DEPTNO |
+--------+
|     10 |
|     30 |
|     40 |
|     20 |
+--------+
(4 rows)

!ok

EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
  EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Previous, as scalar sub-query.
select deptno, unique (select comm from "scott".emp where comm is null) as u
from "scott".dept;
+--------+------+
| DEPTNO | U    |
+--------+------+
|     10 | true |
|     20 | true |
|     30 | true |
|     40 | true |
+--------+------+
(4 rows)

!ok

EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], DEPTNO=[$t0], U=[$t3])
  EnumerableTableScan(table=[[scott, DEPT]])
!plan

# composite keys have unique value which excludes fully or partially null rows.
select deptno
from "scott".dept
where unique (select comm, sal from "scott".emp where comm is not null);
+--------+
| DEPTNO |
+--------+
|     10 |
|     30 |
|     40 |
|     20 |
+--------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], $condition=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], expr#4=[1], expr#5=[>($t2, $t4)], i=[$t3], $condition=[$t5])
        EnumerableAggregate(group=[{5, 6}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t6)], expr#9=[IS NOT NULL($t5)], expr#10=[AND($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, as scalar sub-query.
select deptno, unique (select comm, sal from "scott".emp where comm is not null) as u
from "scott".dept;
+--------+------+
| DEPTNO | U    |
+--------+------+
|     10 | true |
|     20 | true |
|     30 | true |
|     40 | true |
+--------+------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], U=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], expr#4=[1], expr#5=[>($t2, $t4)], i=[$t3], $condition=[$t5])
        EnumerableAggregate(group=[{5, 6}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t6)], expr#9=[IS NOT NULL($t5)], expr#10=[AND($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
            EnumerableTableScan(table=[[scott, EMP]])
!plan



# composite keys have unique value which includes fully or partially null rows.
select deptno
from "scott".dept
where unique (select comm, sal from "scott".emp);
+--------+
| DEPTNO |
+--------+
|     10 |
|     30 |
|     40 |
|     20 |
+--------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], $condition=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], expr#4=[1], expr#5=[>($t2, $t4)], i=[$t3], $condition=[$t5])
        EnumerableAggregate(group=[{5, 6}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t6)], expr#9=[IS NOT NULL($t5)], expr#10=[AND($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, as scalar sub-query.
select deptno, unique (select comm, sal from "scott".emp) as u
from "scott".dept;
+--------+------+
| DEPTNO | U    |
+--------+------+
|     10 | true |
|     20 | true |
|     30 | true |
|     40 | true |
+--------+------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], U=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], expr#4=[1], expr#5=[>($t2, $t4)], i=[$t3], $condition=[$t5])
        EnumerableAggregate(group=[{5, 6}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t6)], expr#9=[IS NOT NULL($t5)], expr#10=[AND($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# singleton keys have duplicate value
select deptno
from "scott".dept
where unique (select deptno from "scott".emp);
+--------+
| DEPTNO |
+--------+
+--------+
(0 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], $condition=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
        EnumerableAggregate(group=[{7}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, as scalar sub-query.
select deptno, unique (select deptno from "scott".emp) as u
from "scott".dept;
+--------+-------+
| DEPTNO | U     |
+--------+-------+
|     10 | false |
|     20 | false |
|     30 | false |
|     40 | false |
+--------+-------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], U=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
        EnumerableAggregate(group=[{7}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# composite keys have duplicate value.
select deptno
from "scott".dept
where unique (select deptno, sal from "scott".emp where sal = 3000);
+--------+
| DEPTNO |
+--------+
+--------+
(0 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], $condition=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
        EnumerableAggregate(group=[{7}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[3000.00:DECIMAL(12, 2)], expr#10=[=($t8, $t9)], expr#11=[IS NOT NULL($t7)], expr#12=[AND($t10, $t11)], proj#0..7=[{exprs}], $condition=[$t12])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, as scalar sub-query.
select deptno, unique (select deptno, sal from "scott".emp where sal = 3000) as u
from "scott".dept;
+--------+-------+
| DEPTNO | U     |
+--------+-------+
|     10 | false |
|     20 | false |
|     30 | false |
|     40 | false |
+--------+-------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], U=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
        EnumerableAggregate(group=[{7}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[3000.00:DECIMAL(12, 2)], expr#10=[=($t8, $t9)], expr#11=[IS NOT NULL($t7)], expr#12=[AND($t10, $t11)], proj#0..7=[{exprs}], $condition=[$t12])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, but NOT UNIQUE.
select deptno, not unique (select deptno, sal from "scott".emp where sal = 3000) as u
from "scott".dept;
+--------+------+
| DEPTNO | U    |
+--------+------+
|     10 | true |
|     20 | true |
|     30 | true |
|     40 | true |
+--------+------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NOT NULL($t1)], DEPTNO=[$t0], U=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableAggregate(group=[{0}])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
        EnumerableAggregate(group=[{7}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t5):DECIMAL(12, 2)], expr#9=[3000.00:DECIMAL(12, 2)], expr#10=[=($t8, $t9)], expr#11=[IS NOT NULL($t7)], expr#12=[AND($t10, $t11)], proj#0..7=[{exprs}], $condition=[$t12])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# as above, but sub-query empty.
select deptno
from "scott".dept
where unique (select deptno from "scott".emp where deptno = 35);
+--------+
| DEPTNO |
+--------+
|     10 |
|     30 |
|     40 |
|     20 |
+--------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], $condition=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
      EnumerableAggregate(group=[{7}], c=[COUNT()])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t7):INTEGER], expr#9=[35], expr#10=[=($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
          EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, as scalar sub-query.
select deptno, unique (select deptno from "scott".emp where deptno = 35) as u
from "scott".dept;
+--------+------+
| DEPTNO | U    |
+--------+------+
|     10 | true |
|     20 | true |
|     30 | true |
|     40 | true |
+--------+------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t1)], DEPTNO=[$t0], U=[$t2])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], $condition=[$t4])
      EnumerableAggregate(group=[{7}], c=[COUNT()])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t7):INTEGER], expr#9=[35], expr#10=[=($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
          EnumerableTableScan(table=[[scott, EMP]])
!plan

# singleton keys which a uniqueness constraint indicates that the relation is already unique.
select *
from "scott".dept
where unique (select deptno from "scott".dept);
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
(4 rows)

!ok

EnumerableTableScan(table=[[scott, DEPT]])
!plan

# as above, sub-query with limit.
select *
from "scott".dept
where unique (select deptno from "scott".emp limit 1);
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
(4 rows)

!ok

EnumerableTableScan(table=[[scott, DEPT]])
!plan

# as above, sub-query with distinct.
select deptno
from "scott".dept
where unique (select distinct deptno, sal from "scott".emp where sal = 3000);
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
|     40 |
+--------+
(4 rows)

!ok

EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
  EnumerableTableScan(table=[[scott, DEPT]])
!plan

# as above, sub-query with group by.
select deptno
from "scott".dept
where unique (select job from "scott".emp group by job);
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
|     40 |
+--------+
(4 rows)

!ok

EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
  EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Correlated UNIQUE predicate.
select *
from "scott".dept
where unique (
    select 1 from "scott".emp where dept.deptno = emp.deptno);
+--------+------------+--------+
| DEPTNO | DNAME      | LOC    |
+--------+------------+--------+
|     40 | OPERATIONS | BOSTON |
+--------+------------+--------+
(1 row)

!ok

EnumerableCalc(expr#0..4=[{inputs}], expr#5=[IS NULL($t3)], proj#0..2=[{exprs}], $condition=[$t5])
  EnumerableMergeJoin(condition=[=($0, $4)], joinType=[left])
    EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], DEPTNO=[$t0], $condition=[$t4])
        EnumerableAggregate(group=[{7}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, as scalar sub-query.
select *, unique (select 1 from "scott".emp where dept.deptno = emp.deptno) as u
from "scott".dept;
+--------+------------+----------+-------+
| DEPTNO | DNAME      | LOC      | U     |
+--------+------------+----------+-------+
|     10 | ACCOUNTING | NEW YORK | false |
|     20 | RESEARCH   | DALLAS   | false |
|     30 | SALES      | CHICAGO  | false |
|     40 | OPERATIONS | BOSTON   | true  |
+--------+------------+----------+-------+
(4 rows)

!ok

EnumerableCalc(expr#0..4=[{inputs}], expr#5=[IS NULL($t3)], proj#0..2=[{exprs}], U=[$t5])
  EnumerableMergeJoin(condition=[=($0, $4)], joinType=[left])
    EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], DEPTNO=[$t0], $condition=[$t4])
        EnumerableAggregate(group=[{7}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# as above, but NOT UNIQUE.
select *
from "scott".dept
where not unique (
    select 1 from "scott".emp where dept.deptno = emp.deptno);
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
+--------+------------+----------+
(3 rows)

!ok

EnumerableHashJoin(condition=[=($0, $3)], joinType=[semi])
  EnumerableTableScan(table=[[scott, DEPT]])
  EnumerableCalc(expr#0..1=[{inputs}], expr#2=[1], expr#3=[>($t1, $t2)], DEPTNO=[$t0], $condition=[$t3])
    EnumerableAggregate(group=[{7}], c=[COUNT()])
      EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
        EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, as scalar sub-query.
select *, not unique (select 1 from "scott".emp where dept.deptno = emp.deptno) as u
from "scott".dept;
+--------+------------+----------+-------+
| DEPTNO | DNAME      | LOC      | U     |
+--------+------------+----------+-------+
|     10 | ACCOUNTING | NEW YORK | true  |
|     20 | RESEARCH   | DALLAS   | true  |
|     30 | SALES      | CHICAGO  | true  |
|     40 | OPERATIONS | BOSTON   | false |
+--------+------------+----------+-------+
(4 rows)

!ok

EnumerableCalc(expr#0..4=[{inputs}], expr#5=[IS NOT NULL($t3)], proj#0..2=[{exprs}], U=[$t5])
  EnumerableMergeJoin(condition=[=($0, $4)], joinType=[left])
    EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableSort(sort0=[$1], dir0=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], expr#3=[1], expr#4=[>($t1, $t3)], i=[$t2], DEPTNO=[$t0], $condition=[$t4])
        EnumerableAggregate(group=[{7}], c=[COUNT()])
          EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NOT NULL($t7)], proj#0..7=[{exprs}], $condition=[$t8])
            EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-4805] Calcite should convert a small IN-list as if the
# user had written OR, even if the IN-list contains NULL.

# The IN-list contains partial null value.
select * from "scott".emp where comm in (300, 500, null);
+-------+-------+----------+------+------------+---------+--------+--------+
| EMPNO | ENAME | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |
+-------+-------+----------+------+------------+---------+--------+--------+
|  7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 |     30 |
|  7521 | WARD  | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 |     30 |
+-------+-------+----------+------+------------+---------+--------+--------+
(2 rows)

!ok

EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t6):DECIMAL(12, 2)], expr#9=[Sarg[300.00:DECIMAL(12, 2), 500.00:DECIMAL(12, 2)]:DECIMAL(12, 2)], expr#10=[SEARCH($t8, $t9)], proj#0..7=[{exprs}], $condition=[$t10])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous, as scalar sub-query.
select *, comm in (300, 500, null) as i from "scott".emp;
+-------+--------+-----------+------+------------+---------+---------+--------+------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | I    |
+-------+--------+-----------+------+------------+---------+---------+--------+------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |      |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 | true |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 | true |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |      |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |      |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |      |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |      |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |      |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |      |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |      |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |      |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |      |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |      |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |      |
+-------+--------+-----------+------+------------+---------+---------+--------+------+
(14 rows)

!ok

EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t6):DECIMAL(12, 2)], expr#9=[Sarg[300.00:DECIMAL(12, 2), 500.00:DECIMAL(12, 2)]:DECIMAL(12, 2)], expr#10=[SEARCH($t8, $t9)], expr#11=[null:BOOLEAN], expr#12=[OR($t10, $t11)], proj#0..7=[{exprs}], I=[$t12])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

# As above, but NOT IN.
select * from "scott".emp where comm not in (300, 500, null);
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

EnumerableValues(tuples=[[]])
!plan

# Previous, as scalar sub-query.
select *, comm not in (300, 500, null) as i from "scott".emp;
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | I     |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |       |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 | false |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 | false |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |       |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |       |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |       |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |       |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |       |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |       |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |       |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |       |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |       |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |       |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |       |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
(14 rows)

!ok

EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t6):DECIMAL(12, 2)], expr#9=[Sarg[(-..300.00:DECIMAL(12, 2)), (300.00:DECIMAL(12, 2)..500.00:DECIMAL(12, 2)), (500.00:DECIMAL(12, 2)..+)]:DECIMAL(12, 2)], expr#10=[SEARCH($t8, $t9)], expr#11=[null:BOOLEAN], expr#12=[AND($t10, $t11)], proj#0..7=[{exprs}], I=[$t12])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

# Previous NOT IN expressions in conjunction form
select *, (comm <> 300 and comm <> 500 and comm <> null) as i from "scott".emp;
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | I     |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |       |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 | false |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 | false |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |       |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |       |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |       |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |       |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |       |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |       |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |       |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |       |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |       |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |       |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |       |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+
(14 rows)

!ok
EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t6):DECIMAL(12, 2)], expr#9=[Sarg[(-..300.00:DECIMAL(12, 2)), (300.00:DECIMAL(12, 2)..500.00:DECIMAL(12, 2)), (500.00:DECIMAL(12, 2)..+)]:DECIMAL(12, 2)], expr#10=[SEARCH($t8, $t9)], expr#11=[null:BOOLEAN], expr#12=[AND($t10, $t11)], proj#0..7=[{exprs}], I=[$t12])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

# The IN-list only contains null value.
select * from "scott".emp where empno in (null);
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

EnumerableValues(tuples=[[]])
!plan

# Previous, as scalar sub-query.
select *, empno in (null) as i from "scott".emp;
+-------+--------+-----------+------+------------+---------+---------+--------+---+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | I |
+-------+--------+-----------+------+------------+---------+---------+--------+---+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |   |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |   |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |   |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |   |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |   |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |   |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |   |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |   |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |   |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |   |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |   |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |   |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |   |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |   |
+-------+--------+-----------+------+------------+---------+---------+--------+---+
(14 rows)

!ok

EnumerableCalc(expr#0..7=[{inputs}], expr#8=[null:BOOLEAN], proj#0..8=[{exprs}])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

# As above, but NOT IN.
select * from "scott".emp where empno not in (null);
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

EnumerableValues(tuples=[[]])
!plan

# Previous, as scalar sub-query.
select *, empno not in (null) as i from "scott".emp;
+-------+--------+-----------+------+------------+---------+---------+--------+---+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | I |
+-------+--------+-----------+------+------------+---------+---------+--------+---+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |   |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |   |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |   |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |   |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |   |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |   |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |   |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |   |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |   |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |   |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |   |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |   |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |   |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |   |
+-------+--------+-----------+------+------------+---------+---------+--------+---+
(14 rows)

!ok

EnumerableCalc(expr#0..7=[{inputs}], expr#8=[null:BOOLEAN], proj#0..8=[{exprs}])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-4844] IN-list that references columns is wrongly converted to Values, and gives incorrect results

!set insubquerythreshold 0

SELECT empno, ename, mgr FROM "scott".emp WHERE 7782 IN (empno, mgr);
+-------+--------+------+
| EMPNO | ENAME  | MGR  |
+-------+--------+------+
|  7782 | CLARK  | 7839 |
|  7934 | MILLER | 7782 |
+-------+--------+------+
(2 rows)

!ok

EnumerableCalc(expr#0..7=[{inputs}], expr#8=[7782], expr#9=[CAST($t0):INTEGER NOT NULL], expr#10=[=($t8, $t9)], expr#11=[CAST($t3):INTEGER], expr#12=[=($t8, $t11)], expr#13=[OR($t10, $t12)], proj#0..1=[{exprs}], MGR=[$t3], $condition=[$t13])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

SELECT empno, ename, mgr FROM "scott".emp WHERE (7782, 7839) IN ((empno, mgr), (mgr, empno));
+-------+-------+------+
| EMPNO | ENAME | MGR  |
+-------+-------+------+
|  7782 | CLARK | 7839 |
+-------+-------+------+
(1 row)

!ok

EnumerableCalc(expr#0..7=[{inputs}], expr#8=[7782], expr#9=[CAST($t0):INTEGER NOT NULL], expr#10=[=($t8, $t9)], expr#11=[7839], expr#12=[CAST($t3):INTEGER], expr#13=[=($t11, $t12)], expr#14=[AND($t10, $t13)], expr#15=[=($t8, $t12)], expr#16=[=($t11, $t9)], expr#17=[AND($t15, $t16)], expr#18=[OR($t14, $t17)], proj#0..1=[{exprs}], MGR=[$t3], $condition=[$t18])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

SELECT empno, ename, mgr FROM "scott".emp WHERE (7782, 7839) IN ((empno, 7839), (7782, mgr));
+-------+-------+------+
| EMPNO | ENAME | MGR  |
+-------+-------+------+
|  7566 | JONES | 7839 |
|  7698 | BLAKE | 7839 |
|  7782 | CLARK | 7839 |
+-------+-------+------+
(3 rows)

!ok

EnumerableCalc(expr#0..7=[{inputs}], expr#8=[7782], expr#9=[CAST($t0):INTEGER NOT NULL], expr#10=[=($t8, $t9)], expr#11=[7839], expr#12=[CAST($t3):INTEGER], expr#13=[=($t11, $t12)], expr#14=[OR($t10, $t13)], proj#0..1=[{exprs}], MGR=[$t3], $condition=[$t14])
  EnumerableTableScan(table=[[scott, EMP]])
!plan

# [CALCITE-4846] IN-list that includes NULL converted to Values throws exception

select * from "scott".emp where empno not in (null, 7782);
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

EnumerableCalc(expr#0..12=[{inputs}], expr#13=[0], expr#14=[=($t8, $t13)], expr#15=[IS NULL($t12)], expr#16=[>=($t9, $t8)], expr#17=[AND($t15, $t16)], expr#18=[OR($t14, $t17)], proj#0..7=[{exprs}], $condition=[$t18])
  EnumerableMergeJoin(condition=[=($10, $11)], joinType=[left])
    EnumerableSort(sort0=[$10], dir0=[ASC])
      EnumerableCalc(expr#0..9=[{inputs}], expr#10=[CAST($t0):INTEGER NOT NULL], proj#0..10=[{exprs}])
        EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
          EnumerableTableScan(table=[[scott, EMP]])
          EnumerableAggregate(group=[{}], c=[COUNT()], ck=[COUNT($0)])
            EnumerableValues(tuples=[[{ null }, { 7782 }]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableCalc(expr#0=[{inputs}], expr#1=[true], proj#0..1=[{exprs}])
        EnumerableValues(tuples=[[{ null }, { 7782 }]])
!plan

select * from "scott".emp where (empno, deptno) not in ((1, 2), (3, null));
+-------+--------+-----------+------+------------+---------+---------+--------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
+-------+--------+-----------+------+------------+---------+---------+--------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |
+-------+--------+-----------+------+------------+---------+---------+--------+
(14 rows)

!ok

EnumerableCalc(expr#0..14=[{inputs}], expr#15=[0], expr#16=[=($t8, $t15)], expr#17=[IS NULL($t14)], expr#18=[>=($t9, $t8)], expr#19=[IS NOT NULL($t7)], expr#20=[AND($t17, $t18, $t19)], expr#21=[OR($t16, $t20)], proj#0..7=[{exprs}], $condition=[$t21])
  EnumerableMergeJoin(condition=[AND(=($10, $12), =($11, $13))], joinType=[left])
    EnumerableSort(sort0=[$10], sort1=[$11], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..9=[{inputs}], expr#10=[CAST($t0):INTEGER NOT NULL], expr#11=[CAST($t7):INTEGER], proj#0..11=[{exprs}])
        EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
          EnumerableTableScan(table=[[scott, EMP]])
          EnumerableAggregate(group=[{}], c=[COUNT()], ck=[COUNT() FILTER $0])
            EnumerableValues(tuples=[[{ true }, { true }]])
    EnumerableSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], proj#0..2=[{exprs}])
        EnumerableValues(tuples=[[{ 3, null }, { 1, 2 }]])
!plan

# As above, but the IN-list includes all null value
select * from "scott".emp where (mgr, deptno) not in ((1, 2), (3, null), (cast(null as integer), cast(null as integer)));
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

EnumerableCalc(expr#0..14=[{inputs}], expr#15=[0], expr#16=[=($t8, $t15)], expr#17=[IS NULL($t14)], expr#18=[>=($t9, $t8)], expr#19=[IS NOT NULL($t3)], expr#20=[IS NOT NULL($t7)], expr#21=[AND($t17, $t18, $t19, $t20)], expr#22=[OR($t16, $t21)], proj#0..7=[{exprs}], $condition=[$t22])
  EnumerableMergeJoin(condition=[AND(=($10, $12), =($11, $13))], joinType=[left])
    EnumerableSort(sort0=[$10], sort1=[$11], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..9=[{inputs}], expr#10=[CAST($t3):INTEGER], expr#11=[CAST($t7):INTEGER], proj#0..11=[{exprs}])
        EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
          EnumerableTableScan(table=[[scott, EMP]])
          EnumerableAggregate(group=[{}], c=[COUNT()], ck=[COUNT() FILTER $0])
            EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NOT NULL($t0)], expr#3=[IS NOT NULL($t1)], expr#4=[OR($t2, $t3)], $f2=[$t4])
              EnumerableValues(tuples=[[{ 3, null }, { null, null }, { 1, 2 }]])
    EnumerableSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], proj#0..2=[{exprs}])
        EnumerableValues(tuples=[[{ 3, null }, { null, null }, { 1, 2 }]])
!plan

select * from "scott".emp where (empno, deptno) not in ((1, 2), (3, null), (cast(null as integer), cast(null as integer)));
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

select * from "scott".emp where (empno, deptno) not in ((7369, 20), (7499, 30));
+-------+--------+-----------+------+------------+---------+---------+--------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
+-------+--------+-----------+------+------------+---------+---------+--------+
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |
+-------+--------+-----------+------+------------+---------+---------+--------+
(12 rows)

!ok

EnumerableCalc(expr#0..14=[{inputs}], expr#15=[0], expr#16=[=($t8, $t15)], expr#17=[IS NULL($t14)], expr#18=[>=($t9, $t8)], expr#19=[IS NOT NULL($t7)], expr#20=[AND($t17, $t18, $t19)], expr#21=[OR($t16, $t20)], proj#0..7=[{exprs}], $condition=[$t21])
  EnumerableMergeJoin(condition=[AND(=($10, $12), =($11, $13))], joinType=[left])
    EnumerableSort(sort0=[$10], sort1=[$11], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..9=[{inputs}], expr#10=[CAST($t0):INTEGER NOT NULL], expr#11=[CAST($t7):INTEGER], proj#0..11=[{exprs}])
        EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
          EnumerableTableScan(table=[[scott, EMP]])
          EnumerableAggregate(group=[{}], c=[COUNT()], ck=[COUNT() FILTER $0])
            EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], $f2=[$t2])
              EnumerableValues(tuples=[[{ 7369, 20 }, { 7499, 30 }]])
    EnumerableSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], proj#0..2=[{exprs}])
        EnumerableValues(tuples=[[{ 7369, 20 }, { 7499, 30 }]])
!plan

# [CALCITE-5117] Optimize the EXISTS sub-query by Metadata RowCount

# Test case about sub-query is guaranteed to produce at least one row
select *
from dept as d
where EXISTS (select count(*) from emp e where d.deptno = e.deptno);
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
(4 rows)

!ok

EnumerableTableScan(table=[[scott, DEPT]])
!plan

# As above, but the filter condition always false
select *
from dept as d
where EXISTS (select count(*) from emp e where d.deptno = e.deptno and 1 = 2);
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
(4 rows)

!ok

EnumerableTableScan(table=[[scott, DEPT]])
!plan


# As above, but the Sum aggregation function
select *
from dept as d
where EXISTS (select sum(1) from emp e where d.deptno = e.deptno and 1 = 2);
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
(4 rows)

!ok

EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test case about sub-query is guaranteed to produce no row
select *
from dept as d
where NOT EXISTS (select count(*) from emp e having false);
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
(4 rows)

!ok

EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test case about nested row
select (select (1, 2));
+--------+
| EXPR$0 |
+--------+
| {1, 2} |
+--------+
(1 row)

!ok

EnumerableCalc(expr#0=[{inputs}], expr#1=[1], expr#2=[2], expr#3=[ROW($t1, $t2)], expr#4=[CAST($t3):RecordType(INTEGER EXPR$0, INTEGER EXPR$1)], EXPR$0=[$t4])
  EnumerableValues(tuples=[[{ 0 }]])
!plan

# Test case for correlated sub-query
SELECT ARRAY(SELECT s.x) FROM (SELECT 1 as x) s;
+--------+
| EXPR$0 |
+--------+
| [1]    |
+--------+
(1 row)

!ok

# Test case for [CALCITE-5310] JSON_OBJECT in scalar sub-query throws AssertionError
SELECT (SELECT json_object('1': (a.attidentity = 'a'), '2': v) FROM UNNEST(ARRAY[1]) as v) as options
FROM UNNEST(ARRAY['a', 'b']) AS a(attidentity);
+-------------------+
| OPTIONS           |
+-------------------+
| {"1":false,"2":1} |
| {"1":true,"2":1}  |
+-------------------+
(2 rows)

!ok

# Test case for [CALCITE-5680] Wrong plan for multiple IN sub-queries with only literal operands
# Note that the first sub-query produces empty result using a fake dept name
select empno from "scott".emp as e
where 10 in (
  select deptno from "scott".dept where dname = 'FAKE-DEPT')
or 20 in (
  select deptno from "scott".dept where dname = 'RESEARCH');
+-------+
| EMPNO |
+-------+
|  7369 |
|  7499 |
|  7521 |
|  7566 |
|  7654 |
|  7698 |
|  7782 |
|  7788 |
|  7839 |
|  7844 |
|  7876 |
|  7900 |
|  7902 |
|  7934 |
+-------+
(14 rows)

!ok

# Test case for [CALCITE-5691] IN sub-query inside FILTER clause throws IndexOutOfBoundsException
select
  count(*) filter (where empno in (select deptno from emp))
from emp;
+--------+
| EXPR$0 |
+--------+
|      0 |
+--------+
(1 row)

!ok

# Test case for [CALCITE-5691] IN sub-query inside FILTER clause throws IndexOutOfBoundsException
select deptno in (select deptno from emp) is true
from emp;
+--------+
| EXPR$0 |
+--------+
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
+--------+
(14 rows)

!ok

# [CALCITE-5626] Sub-query with fully-qualified table name throws
# 'table not found' during validation
select ename, deptno
from emp
where deptno in (select dept.deptno
  from "scott".dept
  where "scott".dept.deptno > 20);
+--------+--------+
| ENAME  | DEPTNO |
+--------+--------+
| ALLEN  |     30 |
| BLAKE  |     30 |
| JAMES  |     30 |
| MARTIN |     30 |
| TURNER |     30 |
| WARD   |     30 |
+--------+--------+
(6 rows)

!ok

# Similar to previous
select ename, deptno
from emp
where deptno in (select deptno
  from "scott".dept
  where "scott".dept.deptno > 20);
+--------+--------+
| ENAME  | DEPTNO |
+--------+--------+
| ALLEN  |     30 |
| BLAKE  |     30 |
| JAMES  |     30 |
| MARTIN |     30 |
| TURNER |     30 |
| WARD   |     30 |
+--------+--------+
(6 rows)

!ok

# Similar to previous
select count("scott".emp.sal) as c
from "scott".emp
where "scott".emp.deptno in (select "scott".dept.deptno
  from "scott".dept
  where "scott".dept.deptno > 20);
+---+
| C |
+---+
| 6 |
+---+
(1 row)

!ok

select *
from "scott".emp as e
where exists (
  select empno
  from "scott".emp as ee
  where e.empno = ee.empno or e.comm >= ee.sal
);
+-------+--------+-----------+------+------------+---------+---------+--------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
+-------+--------+-----------+------+------------+---------+---------+--------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |
+-------+--------+-----------+------+------------+---------+---------+--------+
(14 rows)

!ok


SELECT
  e1.COMM,
  EXISTS (
    SELECT 1
    FROM EMP e2
    WHERE e2.COMM IS NULL OR e2.COMM > e1.COMM * 10
  ) AS exists_flag
FROM EMP e1;
+---------+-------------+
| COMM    | EXISTS_FLAG |
+---------+-------------+
|    0.00 | true        |
| 1400.00 | true        |
|  300.00 | true        |
|  500.00 | true        |
|         | true        |
|         | true        |
|         | true        |
|         | true        |
|         | true        |
|         | true        |
|         | true        |
|         | true        |
|         | true        |
|         | true        |
+---------+-------------+
(14 rows)

!ok

SELECT
  i1.COMM,
  i1.COMM = ANY(SELECT COMM FROM EMP WHERE COMM=i1.COMM)
FROM EMP i1 ORDER BY COMM;
+---------+--------+
| COMM    | EXPR$1 |
+---------+--------+
|    0.00 | true   |
|  300.00 | true   |
|  500.00 | true   |
| 1400.00 | true   |
|         | false  |
|         | false  |
|         | false  |
|         | false  |
|         | false  |
|         | false  |
|         | false  |
|         | false  |
|         | false  |
|         | false  |
+---------+--------+
(14 rows)

!ok

SELECT deptno
FROM dept d
WHERE 0 IN (
    SELECT COUNT(*)
    FROM emp e
    WHERE d.deptno = e.deptno
);
+--------+
| DEPTNO |
+--------+
|     40 |
+--------+
(1 row)

!ok

SELECT deptno
FROM dept d
WHERE 'Regular' IN (
    SELECT CASE WHEN SUM(sal) > 10 then 'VIP' else 'Regular' END expr
    FROM emp e
    WHERE d.deptno = e.deptno
);
+--------+
| DEPTNO |
+--------+
|     40 |
+--------+
(1 row)

!ok

# Test case for [CALCITE-5789]
select deptno from dept d1 where exists (
 select 1 from dept d2 where d2.deptno = d1.deptno and exists (
  select 1 from dept d3 where d3.deptno = d2.deptno and d3.dname = d1.dname));
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
|     40 |
+--------+
(4 rows)

!ok
EnumerableCalc(expr#0..3=[{inputs}], DEPTNO=[$t2])
  EnumerableHashJoin(condition=[AND(=($0, $2), =($1, $3))], joinType=[inner])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableMergeJoin(condition=[=($0, $2)], joinType=[inner])
        EnumerableCalc(expr#0..2=[{inputs}], DEPTNO=[$t0])
          EnumerableTableScan(table=[[scott, DEPT]])
        EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t1)], DNAME=[$t1], DEPTNO=[$t0], $condition=[$t3])
          EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..2=[{inputs}], proj#0..1=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test case for CALCITE-5683 which throws an exception during the de-correlation phase
SELECT d1.dname, d1.deptno + (
  SELECT max(e1.empno)
  FROM emp e1
  WHERE d1.deptno = e1.deptno and
        e1.sal = (
          SELECT max(sal)
          FROM emp e2
          WHERE e1.sal = e2.sal and
                e1.deptno = e2.deptno and
                d1.deptno <= e2.deptno))
FROM dept d1;
+------------+--------+
| DNAME      | EXPR$1 |
+------------+--------+
| ACCOUNTING |   7944 |
| OPERATIONS |        |
| RESEARCH   |   7922 |
| SALES      |   7930 |
+------------+--------+
(4 rows)

!ok

# Test case for CALCITE-5683 which throws an exception during the de-correlation phase
SELECT d1.dname, d1.deptno + (
  SELECT max(e1.empno)
  FROM emp e1
  WHERE d1.deptno = e1.deptno and
        e1.sal = (SELECT max(sal)
                  FROM emp e2
                  WHERE e1.sal = e2.sal and
                        e1.deptno = e2.deptno and
                        d1.deptno < e2.deptno))
FROM dept d1;
+------------+--------+
| DNAME      | EXPR$1 |
+------------+--------+
| ACCOUNTING |        |
| OPERATIONS |        |
| RESEARCH   |        |
| SALES      |        |
+------------+--------+
(4 rows)

!ok

# [CALCITE-5716] Two level nested correlated subquery translates to incorrect ON condition
SELECT deptno FROM dept d1 WHERE EXISTS (
 SELECT 1 FROM dept d2 WHERE d2.deptno = d1.deptno and EXISTS (
  SELECT 1 FROM dept d3 WHERE d3.dname = d1.dname));
+--------+
| DEPTNO |
+--------+
|     10 |
|     20 |
|     30 |
|     40 |
+--------+
(4 rows)

!ok

# [CALCITE-5716] Two level nested correlated subquery translates to incorrect ON condition
SELECT dept.deptno, (
  SELECT max(emp.empno)
  FROM emp
  WHERE empno = (SELECT max(empno) AS maxDept
                 FROM emp e2
                 WHERE e2.deptno = dept.deptno)
        AND emp.deptno = dept.deptno),
  dept.dname
FROM dept;
+--------+--------+------------+
| DEPTNO | EXPR$1 | DNAME      |
+--------+--------+------------+
|     10 |   7934 | ACCOUNTING |
|     20 |   7902 | RESEARCH   |
|     30 |   7900 | SALES      |
|     40 |        | OPERATIONS |
+--------+--------+------------+
(4 rows)

!ok

# [CALCITE-7034] IllegalArgumentException when correlate subQuery in on clause and use rightside columns
SELECT e1.*
FROM emp e1
JOIN dept d
  ON e1.deptno = d.deptno
  AND d.deptno IN (
    SELECT e3.empno
    FROM emp e3
    WHERE d.deptno > e3.comm
  )
ORDER BY e1.empno, e1.deptno;
+-------+-------+-----+-----+----------+-----+------+--------+
| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
+-------+-------+-----+-----+----------+-----+------+--------+
+-------+-------+-----+-----+----------+-----+------+--------+
(0 rows)

!ok

# [CALCITE-7034] IllegalArgumentException when correlate subQuery in on clause and use rightside columns
SELECT e1.*, d.deptno
FROM emp e1
LEFT JOIN dept d
  ON e1.deptno = d.deptno
  AND d.deptno IN (
    SELECT e3.deptno
    FROM emp e3
    WHERE d.deptno > e3.comm
  )
ORDER BY e1.empno;
+-------+--------+-----------+------+------------+---------+---------+--------+--------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO |
+-------+--------+-----------+------+------------+---------+---------+--------+--------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |        |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |     30 |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |     30 |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |        |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |     30 |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |     30 |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |        |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |        |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |        |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |     30 |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |        |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |     30 |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |        |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |        |
+-------+--------+-----------+------+------------+---------+---------+--------+--------+
(14 rows)

!ok

# [CALCITE-7034] IllegalArgumentException when correlate subQuery in on clause and use rightside columns
SELECT e1.*
FROM emp e1
LEFT JOIN dept d
  ON e1.deptno = d.deptno
  AND e1.empno IN (
    SELECT e3.empno
    FROM emp e3
    WHERE e1.comm > e3.comm
  )
ORDER BY e1.empno, e1.deptno;
+-------+--------+-----------+------+------------+---------+---------+--------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
+-------+--------+-----------+------+------------+---------+---------+--------+
|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20 |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
|  7566 | JONES  | MANAGER   | 7839 | 1981-02-04 | 2975.00 |         |     20 |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-01-05 | 2850.00 |         |     30 |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10 |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |         |     20 |
|  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10 |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |         |     20 |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30 |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20 |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10 |
+-------+--------+-----------+------+------------+---------+---------+--------+
(14 rows)

!ok

# [CALCITE-6041] MAP sub-query gives NullPointerException
# map size > 1
SELECT map(SELECT empno, deptno from emp where deptno < 20);
+-----------------------------+
| EXPR$0                      |
+-----------------------------+
| {7782=10, 7839=10, 7934=10} |
+-----------------------------+
(1 row)

!ok

# [CALCITE-6041] MAP sub-query gives NullPointerException
# map size = 1
SELECT map(SELECT empno, deptno from emp where empno = 7369);
+-----------+
| EXPR$0    |
+-----------+
| {7369=20} |
+-----------+
(1 row)

!ok

# [CALCITE-6041] MAP sub-query gives NullPointerException
# empty map
SELECT map(SELECT empno, deptno from emp where false);
+--------+
| EXPR$0 |
+--------+
| {}     |
+--------+
(1 row)

!ok

# [CALCITE-6063] ARRAY subquery with OrderBy loses Sort
# normal behavior
SELECT array(SELECT empno FROM emp);
+--------------------------------------------------------------------------------------+
| EXPR$0                                                                               |
+--------------------------------------------------------------------------------------+
| [7369, 7499, 7521, 7566, 7654, 7698, 7782, 7788, 7839, 7844, 7876, 7900, 7902, 7934] |
+--------------------------------------------------------------------------------------+
(1 row)

!ok

# [CALCITE-6063] ARRAY subquery with OrderBy loses Sort
# with filter
SELECT array(SELECT empno FROM emp WHERE empno > 7800);
+--------------------------------------+
| EXPR$0                               |
+--------------------------------------+
| [7839, 7844, 7876, 7900, 7902, 7934] |
+--------------------------------------+
(1 row)

!ok

# [CALCITE-6063] ARRAY subquery with OrderBy loses Sort
# with filter and order by
SELECT array(SELECT empno FROM emp WHERE empno > 7800 ORDER BY empno DESC);
+--------------------------------------+
| EXPR$0                               |
+--------------------------------------+
| [7934, 7902, 7900, 7876, 7844, 7839] |
+--------------------------------------+
(1 row)

!ok

# [CALCITE-6063] ARRAY subquery with OrderBy loses Sort
# with filter and order by and limit
SELECT array(SELECT empno FROM emp WHERE empno > 7800 ORDER BY empno DESC LIMIT 2);
+--------------+
| EXPR$0       |
+--------------+
| [7934, 7902] |
+--------------+
(1 row)

!ok

# [CALCITE-6468] RelDecorrelator throws AssertionError if correlated variable
# is used as Aggregate group key
WITH agg_sal AS
 (SELECT deptno, sum(sal) AS total FROM emp GROUP BY deptno)
SELECT 1 FROM agg_sal s1
WHERE s1.total > (SELECT avg(total) FROM agg_sal s2 WHERE s1.deptno = s2.deptno);
+--------+
| EXPR$0 |
+--------+
+--------+
(0 rows)

!ok

# [CALCITE-6506] Type inference for IN list is incorrect

# Test LHS is not nullable and RHS is not nullable
select empno, empno in (7369, 7499, 7521) from emp;
+-------+--------+
| EMPNO | EXPR$1 |
+-------+--------+
|  7369 | true   |
|  7499 | true   |
|  7521 | true   |
|  7566 | false  |
|  7654 | false  |
|  7698 | false  |
|  7782 | false  |
|  7788 | false  |
|  7839 | false  |
|  7844 | false  |
|  7876 | false  |
|  7900 | false  |
|  7902 | false  |
|  7934 | false  |
+-------+--------+
(14 rows)

!ok


EnumerableCalc(expr#0..3=[{inputs}], expr#4=[IS NOT NULL($t3)], EMPNO=[$t0], EXPR$1=[$t4])
  EnumerableMergeJoin(condition=[=($1, $2)], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t0):INTEGER NOT NULL], EMPNO=[$t0], EMPNO0=[$t8])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[true], proj#0..1=[{exprs}])
      EnumerableValues(tuples=[[{ 7369 }, { 7499 }, { 7521 }]])
!plan

# Test LHS is nullable and RHS is not nullable
select comm, comm in (500, 300, 0) from emp;
+---------+--------+
| COMM    | EXPR$1 |
+---------+--------+
|    0.00 | true   |
| 1400.00 | false  |
|  300.00 | true   |
|  500.00 | true   |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
+---------+--------+
(14 rows)

!ok

EnumerableCalc(expr#0..6=[{inputs}], expr#7=[IS NULL($t1)], expr#8=[null:BOOLEAN], expr#9=[0], expr#10=[<>($t2, $t9)], expr#11=[AND($t7, $t8, $t10)], expr#12=[IS NOT NULL($t6)], expr#13=[IS NOT NULL($t1)], expr#14=[AND($t12, $t10, $t13)], expr#15=[<($t3, $t2)], expr#16=[IS NULL($t6)], expr#17=[AND($t15, $t8, $t10, $t13, $t16)], expr#18=[OR($t11, $t14, $t17)], COMM=[$t1], EXPR$1=[$t18])
  EnumerableMergeJoin(condition=[=($4, $5)], joinType=[left])
    EnumerableSort(sort0=[$4], dir0=[ASC])
      EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t1):DECIMAL(12, 2)], proj#0..4=[{exprs}])
        EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
          EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], COMM=[$t6])
            EnumerableTableScan(table=[[scott, EMP]])
          EnumerableCalc(expr#0=[{inputs}], c=[$t0], ck=[$t0])
            EnumerableAggregate(group=[{}], c=[COUNT()])
              EnumerableValues(tuples=[[{ 500.00 }, { 300.00 }, { 0.00 }]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableCalc(expr#0=[{inputs}], expr#1=[true], proj#0..1=[{exprs}])
        EnumerableValues(tuples=[[{ 500.00 }, { 300.00 }, { 0.00 }]])
!plan

# Test LHS is nullable and RHS is nullable

select comm, comm in (500, 300, 0, null) from emp;
+---------+--------+
| COMM    | EXPR$1 |
+---------+--------+
|    0.00 | true   |
| 1400.00 |        |
|  300.00 | true   |
|  500.00 | true   |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
+---------+--------+
(14 rows)

!ok

EnumerableCalc(expr#0..6=[{inputs}], expr#7=[IS NULL($t1)], expr#8=[null:BOOLEAN], expr#9=[0], expr#10=[<>($t2, $t9)], expr#11=[AND($t7, $t8, $t10)], expr#12=[IS NOT NULL($t6)], expr#13=[IS NOT NULL($t1)], expr#14=[AND($t12, $t10, $t13)], expr#15=[<($t3, $t2)], expr#16=[IS NULL($t6)], expr#17=[AND($t15, $t8, $t10, $t13, $t16)], expr#18=[OR($t11, $t14, $t17)], COMM=[$t1], EXPR$1=[$t18])
  EnumerableMergeJoin(condition=[=($4, $5)], joinType=[left])
    EnumerableSort(sort0=[$4], dir0=[ASC])
      EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t1):DECIMAL(12, 2)], proj#0..4=[{exprs}])
        EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
          EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], COMM=[$t6])
            EnumerableTableScan(table=[[scott, EMP]])
          EnumerableAggregate(group=[{}], c=[COUNT()], ck=[COUNT($0)])
            EnumerableValues(tuples=[[{ 500.00 }, { 300.00 }, { 0.00 }, { null }]])
    EnumerableSort(sort0=[$0], dir0=[ASC])
      EnumerableCalc(expr#0=[{inputs}], expr#1=[true], proj#0..1=[{exprs}])
        EnumerableValues(tuples=[[{ 500.00 }, { 300.00 }, { 0.00 }, { null }]])
!plan

# Test LHS is (not nullable, not nullable) and RHS is (not nullable, not nullable)

select empno, (empno, empno) in ((7369, 7369), (7499, 7499), (7521, 7521)) from emp;
+-------+--------+
| EMPNO | EXPR$1 |
+-------+--------+
|  7369 | true   |
|  7499 | true   |
|  7521 | true   |
|  7566 | false  |
|  7654 | false  |
|  7698 | false  |
|  7782 | false  |
|  7788 | false  |
|  7839 | false  |
|  7844 | false  |
|  7876 | false  |
|  7900 | false  |
|  7902 | false  |
|  7934 | false  |
+-------+--------+
(14 rows)

!ok

EnumerableCalc(expr#0..5=[{inputs}], expr#6=[IS NOT NULL($t5)], EMPNO=[$t0], EXPR$1=[$t6])
  EnumerableMergeJoin(condition=[AND(=($1, $3), =($2, $4))], joinType=[left])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t0):INTEGER NOT NULL], EMPNO=[$t0], EMPNO0=[$t8], EMPNO1=[$t8])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], proj#0..2=[{exprs}])
        EnumerableValues(tuples=[[{ 7369, 7369 }, { 7499, 7499 }, { 7521, 7521 }]])
!plan


# Test LHS is (nullable, nullable) and RHS is (not nullable, not nullable)
select comm, (comm, comm) in ((500, 500), (300, 300), (0, 0)) from emp;
+---------+--------+
| COMM    | EXPR$1 |
+---------+--------+
|    0.00 | true   |
| 1400.00 | false  |
|  300.00 | true   |
|  500.00 | true   |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
+---------+--------+
(14 rows)

!ok

EnumerableCalc(expr#0..8=[{inputs}], expr#9=[IS NULL($t1)], expr#10=[null:BOOLEAN], expr#11=[0], expr#12=[<>($t2, $t11)], expr#13=[AND($t9, $t10, $t12)], expr#14=[IS NOT NULL($t8)], expr#15=[IS NOT NULL($t1)], expr#16=[AND($t14, $t12, $t15)], expr#17=[<($t3, $t2)], expr#18=[IS NULL($t8)], expr#19=[AND($t17, $t10, $t12, $t15, $t18)], expr#20=[OR($t13, $t16, $t19)], COMM=[$t1], EXPR$1=[$t20])
  EnumerableMergeJoin(condition=[AND(=($4, $6), =($5, $7))], joinType=[left])
    EnumerableSort(sort0=[$4], sort1=[$5], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t1):DECIMAL(12, 2)], proj#0..4=[{exprs}], COMM1=[$t4])
        EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
          EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], COMM=[$t6])
            EnumerableTableScan(table=[[scott, EMP]])
          EnumerableAggregate(group=[{}], c=[COUNT()], ck=[COUNT() FILTER $0])
            EnumerableValues(tuples=[[{ true }, { true }, { true }]])
    EnumerableSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], proj#0..2=[{exprs}])
        EnumerableValues(tuples=[[{ 500.00, 500.00 }, { 300.00, 300.00 }, { 0.00, 0.00 }]])
!plan

# Test LHS is (nullable, nullable) and RHS is (nullable, nullable)

select comm, (comm, comm) in ((500, 500), (300, 300), (0, 0), (null , null)) from emp;
+---------+--------+
| COMM    | EXPR$1 |
+---------+--------+
|    0.00 | true   |
| 1400.00 |        |
|  300.00 | true   |
|  500.00 | true   |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
|         |        |
+---------+--------+
(14 rows)

!ok

EnumerableCalc(expr#0..8=[{inputs}], expr#9=[IS NULL($t1)], expr#10=[null:BOOLEAN], expr#11=[0], expr#12=[<>($t2, $t11)], expr#13=[AND($t9, $t10, $t12)], expr#14=[IS NOT NULL($t8)], expr#15=[IS NOT NULL($t1)], expr#16=[AND($t14, $t12, $t15)], expr#17=[<($t3, $t2)], expr#18=[IS NULL($t8)], expr#19=[AND($t17, $t10, $t12, $t15, $t18)], expr#20=[OR($t13, $t16, $t19)], COMM=[$t1], EXPR$1=[$t20])
  EnumerableMergeJoin(condition=[AND(=($4, $6), =($5, $7))], joinType=[left])
    EnumerableSort(sort0=[$4], sort1=[$5], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t1):DECIMAL(12, 2)], proj#0..4=[{exprs}], COMM1=[$t4])
        EnumerableNestedLoopJoin(condition=[true], joinType=[inner])
          EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], COMM=[$t6])
            EnumerableTableScan(table=[[scott, EMP]])
          EnumerableAggregate(group=[{}], c=[COUNT()], ck=[COUNT() FILTER $0])
            EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NOT NULL($t0)], expr#3=[IS NOT NULL($t1)], expr#4=[OR($t2, $t3)], $f2=[$t4])
              EnumerableValues(tuples=[[{ 500.00, 500.00 }, { 300.00, 300.00 }, { 0.00, 0.00 }, { null, null }]])
    EnumerableSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])
      EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], proj#0..2=[{exprs}])
        EnumerableValues(tuples=[[{ 500.00, 500.00 }, { 300.00, 300.00 }, { 0.00, 0.00 }, { null, null }]])
!plan

# [CALCITE-5156] Support implicit integer types cast for IN Sub-query

# Test case about the IN sub-query left operand type is INTEGER and right operand type is TINYINT
select *
from dept
where deptno + 20 in (select deptno from dept);
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
+--------+------------+----------+
(2 rows)

!ok

EnumerableCalc(expr#0..3=[{inputs}], proj#0..2=[{exprs}])
  EnumerableHashJoin(condition=[=($3, $4)], joinType=[semi])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[20], expr#4=[+($t0, $t3)], proj#0..2=[{exprs}], $f3=[$t4])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER NOT NULL], DEPTNO=[$t3])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test case about the IN sub-query left operand type is BIGINT and right operand type is TINYINT
select *
from dept
where cast(deptno as bigint) in (select deptno from dept);
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
(4 rows)

!ok

EnumerableCalc(expr#0..3=[{inputs}], proj#0..2=[{exprs}])
  EnumerableHashJoin(condition=[=($3, $4)], joinType=[semi])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):BIGINT NOT NULL], proj#0..3=[{exprs}])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t0):BIGINT NOT NULL], DEPTNO=[$t3])
      EnumerableTableScan(table=[[scott, DEPT]])
!plan

# Test case about the IN sub-query left operand type is INTEGER and right operand type is BIGINT
select *
from dept
where deptno + 10 in (select count(*) + 10 from emp where comm is null);
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
+--------+------------+----------+
(1 row)

!ok

EnumerableCalc(expr#0..3=[{inputs}], proj#0..2=[{exprs}])
  EnumerableHashJoin(condition=[=($3, $4)], joinType=[semi])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[10], expr#4=[+($t0, $t3)], expr#5=[CAST($t4):BIGINT NOT NULL], proj#0..2=[{exprs}], $f3=[$t5])
      EnumerableTableScan(table=[[scott, DEPT]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[10], expr#2=[+($t0, $t1)], EXPR$0=[$t2])
      EnumerableAggregate(group=[{}], agg#0=[COUNT()])
        EnumerableCalc(expr#0..7=[{inputs}], expr#8=[IS NULL($t6)], proj#0..7=[{exprs}], $condition=[$t8])
          EnumerableTableScan(table=[[scott, EMP]])
!plan

# Test case about the IN sub-query left operand type is SMALLINT and right operand type is TINYINT
select *
from emp
where cast(empno - 7349 as smallint)  in (select deptno from emp) and ename = 'SMITH';
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok

EnumerableCalc(expr#0..8=[{inputs}], proj#0..7=[{exprs}])
  EnumerableHashJoin(condition=[=($8, $9)], joinType=[semi])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[7349], expr#9=[-($t0, $t8)], expr#10=[CAST($t9):SMALLINT NOT NULL], expr#11=['SMITH':VARCHAR(10)], expr#12=[=($t1, $t11)], proj#0..7=[{exprs}], $f8=[$t10], $condition=[$t12])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t7):SMALLINT], DEPTNO=[$t8])
      EnumerableTableScan(table=[[scott, EMP]])
!plan

# Test case about the IN sub-query left operand type is SMALLINT and right operand type is INTEGER
select *
from emp
where empno in (select deptno + 7349 from emp);
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok

EnumerableCalc(expr#0..8=[{inputs}], proj#0..7=[{exprs}])
  EnumerableHashJoin(condition=[=($8, $9)], joinType=[semi])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t0):INTEGER NOT NULL], proj#0..8=[{exprs}])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[7349], expr#9=[+($t7, $t8)], EXPR$0=[$t9])
      EnumerableTableScan(table=[[scott, EMP]])
!plan

# Test case about the IN sub-query left operand type is SMALLINT and right operand type is BIGINT
select *
from emp
where empno in (select cast(deptno + 7349 as bigint) from emp);
+-------+-------+-------+------+------------+--------+------+--------+
| EMPNO | ENAME | JOB   | MGR  | HIREDATE   | SAL    | COMM | DEPTNO |
+-------+-------+-------+------+------------+--------+------+--------+
|  7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 |      |     20 |
+-------+-------+-------+------+------------+--------+------+--------+
(1 row)

!ok

EnumerableCalc(expr#0..8=[{inputs}], proj#0..7=[{exprs}])
  EnumerableHashJoin(condition=[=($8, $9)], joinType=[semi])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[CAST($t0):BIGINT NOT NULL], proj#0..8=[{exprs}])
      EnumerableTableScan(table=[[scott, EMP]])
    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[7349], expr#9=[+($t7, $t8)], expr#10=[CAST($t9):BIGINT], EXPR$0=[$t10])
      EnumerableTableScan(table=[[scott, EMP]])
!plan


# [CALCITE-6650] Optimize the IN sub-query and SOME sub-query by Metadata RowCount

!use post

# Test case about SOME sub-query when sub-query return 0 row
select * from emp where deptno > some(select deptno from dept where false);
+-------+--------+--------+
| ENAME | DEPTNO | GENDER |
+-------+--------+--------+
+-------+--------+--------+
(0 rows)

!ok

EnumerableValues(tuples=[[]])
!plan

# Same as previous; but is Scalar sub-query
select deptno, deptno > some(select deptno from dept where false) from emp;
+--------+--------+
| DEPTNO | EXPR$1 |
+--------+--------+
|     10 | false  |
|     20 | false  |
|     30 | false  |
|     10 | false  |
|     30 | false  |
|     50 | false  |
|     50 | false  |
|     60 | false  |
|        | false  |
+--------+--------+
(9 rows)

!ok

EnumerableCalc(expr#0=[{inputs}], expr#1=[false], expr#2=[CAST($t1):BOOLEAN], DEPTNO=[$t0], EXPR$1=[$t2])
  EnumerableValues(tuples=[[{ 10 }, { 10 }, { 20 }, { 30 }, { 30 }, { 50 }, { 50 }, { 60 }, { null }]])
!plan

# Same as previous; but LHS is NULL
select deptno, null > some(select deptno from dept where false) from emp;
+--------+--------+
| DEPTNO | EXPR$1 |
+--------+--------+
|     10 | false  |
|     20 | false  |
|     30 | false  |
|     10 | false  |
|     30 | false  |
|     50 | false  |
|     50 | false  |
|     60 | false  |
|        | false  |
+--------+--------+
(9 rows)

!ok

EnumerableCalc(expr#0=[{inputs}], expr#1=[false], expr#2=[CAST($t1):BOOLEAN], DEPTNO=[$t0], EXPR$1=[$t2])
  EnumerableValues(tuples=[[{ 10 }, { 10 }, { 20 }, { 30 }, { 30 }, { 50 }, { 50 }, { 60 }, { null }]])
!plan

# Test case about ANY sub-query when sub-query return 0 row
select * from emp where deptno > any(select deptno from dept where false);
+-------+--------+--------+
| ENAME | DEPTNO | GENDER |
+-------+--------+--------+
+-------+--------+--------+
(0 rows)

!ok

EnumerableValues(tuples=[[]])
!plan

# Same as previous; but is Scalar sub-query
select deptno, deptno > any(select deptno from dept where false) from emp;
+--------+--------+
| DEPTNO | EXPR$1 |
+--------+--------+
|     10 | false  |
|     10 | false  |
|     20 | false  |
|     30 | false  |
|     30 | false  |
|     50 | false  |
|     50 | false  |
|     60 | false  |
|        | false  |
+--------+--------+
(9 rows)

!ok

EnumerableCalc(expr#0=[{inputs}], expr#1=[false], expr#2=[CAST($t1):BOOLEAN], DEPTNO=[$t0], EXPR$1=[$t2])
  EnumerableValues(tuples=[[{ 10 }, { 10 }, { 20 }, { 30 }, { 30 }, { 50 }, { 50 }, { 60 }, { null }]])
!plan

# Test case about UNIQUE sub-query when sub-query return 0 row
select * from emp where unique (select deptno from dept where false);
+-------+--------+--------+
| ENAME | DEPTNO | GENDER |
+-------+--------+--------+
| Adam  |     50 | M      |
| Alice |     30 | F      |
| Bob   |     10 | M      |
| Eric  |     20 | M      |
| Eve   |     50 | F      |
| Grace |     60 | F      |
| Jane  |     10 | F      |
| Susan |     30 | F      |
| Wilma |        | F      |
+-------+--------+--------+
(9 rows)

!ok

EnumerableValues(tuples=[[{ 'Jane ', 10, 'F' }, { 'Bob  ', 10, 'M' }, { 'Eric ', 20, 'M' }, { 'Susan', 30, 'F' }, { 'Alice', 30, 'F' }, { 'Adam ', 50, 'M' }, { 'Eve  ', 50, 'F' }, { 'Grace', 60, 'F' }, { 'Wilma', null, 'F' }]])
!plan

# Same as previous; but is Scalar sub-query
select unique (select deptno from dept where false) from emp;
+--------+
| EXPR$0 |
+--------+
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
| true   |
+--------+
(9 rows)

!ok

EnumerableCalc(expr#0=[{inputs}], expr#1=[true], EXPR$0=[$t1])
  EnumerableValues(tuples=[[{ 10 }, { 10 }, { 20 }, { 30 }, { 30 }, { 50 }, { 50 }, { 60 }, { null }]])
!plan


# Test case about NOT UNIQUE sub-query when sub-query return 0 row
select * from emp where not unique (select deptno from dept where false);
+-------+--------+--------+
| ENAME | DEPTNO | GENDER |
+-------+--------+--------+
+-------+--------+--------+
(0 rows)

!ok

EnumerableValues(tuples=[[]])
!plan

# Same as previous; but is Scalar sub-query
select not unique (select deptno from dept where false) from dept;
+--------+
| EXPR$0 |
+--------+
| false  |
| false  |
| false  |
| false  |
+--------+
(4 rows)

!ok

EnumerableCalc(expr#0..1=[{inputs}], expr#2=[false], EXPR$0=[$t2])
  EnumerableValues(tuples=[[{ 10, 'Sales      ' }, { 20, 'Marketing  ' }, { 30, 'Engineering' }, { 40, 'Empty      ' }]])
!plan

# [CALCITE-4758] When SOME sub-query is SqlNodeList and converted to VALUES, Calcite returns incorrect result

# LHS include NULL value and RHS is not nullable
select deptno from emp where deptno not in (50, 20);
+--------+
| DEPTNO |
+--------+
|     10 |
|     30 |
|     10 |
|     30 |
|     60 |
+--------+
(5 rows)

!ok

# [CALCITE-7025] Verifying the Quantify operator without compatible types, should throw an exception about the Quantify Operator
select * from emp where false > some(select deptno from dept);
Values passed to > SOME operator must have compatible types
!error

# [CALCITE-4756] When subquery include NULL value, Calcite should return the right result
select 1 in (values(null), (null));
+--------+
| EXPR$0 |
+--------+
|        |
+--------+
(1 row)

!ok

EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS FALSE($t1)], expr#4=[null:BOOLEAN], expr#5=[IS NOT NULL($t2)], expr#6=[AND($t3, $t4, $t5)], expr#7=[IS NOT NULL($t1)], expr#8=[IS NOT FALSE($t1)], expr#9=[AND($t7, $t5, $t8)], expr#10=[OR($t6, $t9)], EXPR$0=[$t10])
  EnumerableNestedLoopJoin(condition=[true], joinType=[left])
    EnumerableValues(tuples=[[{ 0 }]])
    EnumerableLimit(fetch=[1])
      EnumerableSort(sort0=[$0], dir0=[DESC])
        EnumerableAggregate(group=[{0}], c=[COUNT()])
          EnumerableCalc(expr#0=[{inputs}], expr#1=[IS NOT NULL($t0)], cs=[$t1])
            EnumerableValues(tuples=[[{ null }, { null }]])
!plan

# [CALCITE-1583] Wrong results for query with correlated subqueries with aggregate subquery expression
# Correlated sub-query with aggregate expression can optimized by Metadata RowCount
select * from emp where exists (select count(deptno) from dept where dept.deptno = emp.deptno);
+-------+--------+--------+
| ENAME | DEPTNO | GENDER |
+-------+--------+--------+
| Adam  |     50 | M      |
| Alice |     30 | F      |
| Bob   |     10 | M      |
| Eric  |     20 | M      |
| Eve   |     50 | F      |
| Grace |     60 | F      |
| Jane  |     10 | F      |
| Susan |     30 | F      |
| Wilma |        | F      |
+-------+--------+--------+
(9 rows)

!ok
EnumerableValues(tuples=[[{ 'Jane ', 10, 'F' }, { 'Bob  ', 10, 'M' }, { 'Eric ', 20, 'M' }, { 'Susan', 30, 'F' }, { 'Alice', 30, 'F' }, { 'Adam ', 50, 'M' }, { 'Eve  ', 50, 'F' }, { 'Grace', 60, 'F' }, { 'Wilma', null, 'F' }]])
!plan


# Same as previous; but the sub-query with always false condition.
select * from emp where exists (select count(deptno) from dept where dept.deptno = emp.deptno and 1 = 2);
+-------+--------+--------+
| ENAME | DEPTNO | GENDER |
+-------+--------+--------+
| Adam  |     50 | M      |
| Alice |     30 | F      |
| Bob   |     10 | M      |
| Eric  |     20 | M      |
| Eve   |     50 | F      |
| Grace |     60 | F      |
| Jane  |     10 | F      |
| Susan |     30 | F      |
| Wilma |        | F      |
+-------+--------+--------+
(9 rows)

!ok
EnumerableValues(tuples=[[{ 'Jane ', 10, 'F' }, { 'Bob  ', 10, 'M' }, { 'Eric ', 20, 'M' }, { 'Susan', 30, 'F' }, { 'Alice', 30, 'F' }, { 'Adam ', 50, 'M' }, { 'Eve  ', 50, 'F' }, { 'Grace', 60, 'F' }, { 'Wilma', null, 'F' }]])
!plan


# Same as previous; but the sub-query with true correlated condition sometimes and condition is always false.
select * from emp where deptno <> (select count(deptno) from dept where dept.deptno = emp.deptno);
+-------+--------+--------+
| ENAME | DEPTNO | GENDER |
+-------+--------+--------+
| Adam  |     50 | M      |
| Alice |     30 | F      |
| Bob   |     10 | M      |
| Eric  |     20 | M      |
| Eve   |     50 | F      |
| Grace |     60 | F      |
| Jane  |     10 | F      |
| Susan |     30 | F      |
+-------+--------+--------+
(8 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], expr#5=[IS NULL($t4)], expr#6=[CAST($t1):BIGINT], expr#7=[0:BIGINT], expr#8=[<>($t6, $t7)], expr#9=[AND($t5, $t8)], expr#10=[<>($t6, $t4)], expr#11=[OR($t9, $t10)], proj#0..2=[{exprs}], $condition=[$t11])
  EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($1, $3)], joinType=[left])
    EnumerableValues(tuples=[[{ 'Jane ', 10, 'F' }, { 'Bob  ', 10, 'M' }, { 'Eric ', 20, 'M' }, { 'Susan', 30, 'F' }, { 'Alice', 30, 'F' }, { 'Adam ', 50, 'M' }, { 'Eve  ', 50, 'F' }, { 'Grace', 60, 'F' }, { 'Wilma', null, 'F' }]])
    EnumerableCalc(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t2)], expr#4=[0], expr#5=[CASE($t3, $t2, $t4)], DEPTNO=[$t0], EXPR$0=[$t5])
      EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($0, $1)], joinType=[left])
        EnumerableAggregate(group=[{0}])
          EnumerableValues(tuples=[[{ 10 }, { 10 }, { 20 }, { 30 }, { 30 }, { 50 }, { 50 }, { 60 }, { null }]])
        EnumerableCalc(expr#0..1=[{inputs}], expr#2=[1:BIGINT], DEPTNO=[$t0], $f1=[$t2])
          EnumerableValues(tuples=[[{ 10, 'Sales      ' }, { 20, 'Marketing  ' }, { 30, 'Engineering' }, { 40, 'Empty      ' }]])
!plan

# Same as previous; but the sub-query with always false correlated condition and return true sometimes.
select * from emp where deptno <> (select count(deptno) + 10  from dept where dept.deptno = emp.deptno and 1 = 2);
+-------+--------+--------+
| ENAME | DEPTNO | GENDER |
+-------+--------+--------+
| Adam  |     50 | M      |
| Alice |     30 | F      |
| Eric  |     20 | M      |
| Eve   |     50 | F      |
| Grace |     60 | F      |
| Susan |     30 | F      |
+-------+--------+--------+
(6 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], expr#5=[CAST($t1):BIGINT], expr#6=[IS NULL($t4)], expr#7=[0:BIGINT], expr#8=[CASE($t6, $t7, $t4)], expr#9=[10], expr#10=[+($t8, $t9)], expr#11=[<>($t5, $t10)], proj#0..2=[{exprs}], $condition=[$t11])
  EnumerableNestedLoopJoin(condition=[IS NOT DISTINCT FROM($1, $3)], joinType=[left])
    EnumerableValues(tuples=[[{ 'Jane ', 10, 'F' }, { 'Bob  ', 10, 'M' }, { 'Eric ', 20, 'M' }, { 'Susan', 30, 'F' }, { 'Alice', 30, 'F' }, { 'Adam ', 50, 'M' }, { 'Eve  ', 50, 'F' }, { 'Grace', 60, 'F' }, { 'Wilma', null, 'F' }]])
    EnumerableCalc(expr#0=[{inputs}], expr#1=[0], expr#2=[CAST($t1):BIGINT NOT NULL], DEPTNO=[$t0], $f1=[$t2])
      EnumerableAggregate(group=[{0}])
        EnumerableValues(tuples=[[{ 10 }, { 10 }, { 20 }, { 30 }, { 30 }, { 50 }, { 50 }, { 60 }, { null }]])
!plan

# End sub-query.iq
