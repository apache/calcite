# big-query.iq - Babel test for BigQuery dialect of SQL
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# In this file (due to the use of 'scott-big-query' below, and unlike typical
# Quidem tests), types are aliased to be consistent with BigQuery's type names,
# not Calcite's usual type names. # In particular:
#  * DATETIME is what Calcite calls TIMESTAMP;
#  * TIMESTAMP is what Calcite calls TIMESTAMP WITH LOCAL TIME ZONE;
#  * DATE and TIME are the same as Calcite;
#  * BYTES means VARBINARY(*);
#  * STRING means VARCHAR(*).
#
# The DATETIME() and TIMESTAMP() functions are also substituted so that they
# produce values that BigQuery would call DATETIME and TIMESTAMP.
#
!use scott-big-query
!set outputformat mysql

# TODO: create a means to set the current date/time/timestamp for the
#   current session CURRENT_TIMESTAMP etc. will return those values.
#   Then enable the CURRENT_x tests.
!if (false) {
!set timestamp '2022-06-03 12:15:48.678'
!}

# TODO: create a means to set the session timezone.
# They will affect all queries that are tagged as follows:
#   Display of results may differ, depending upon the environment and
#   time zone where this query was executed.
!if (false) {
!set timezone 'America/Pacific'
!}

# BigQuery allows CTEs called 'table' and 'date'
!if (false) {
with table as (select 1 as x)
select *
from table;
!ok

with date as (select 1 as x)
select *
from date;
!ok
!}


#####################################################################
# DATE, DATETIME, TIME and TIMESTAMP functions ######################

#####################################################################
# CURRENT_DATE
#
# CURRENT_DATE([time_zone])
#
# Returns the current date as of the specified or default time
# zone. Parentheses are optional when called with no arguments.
#
# This function supports an optional time_zone parameter. This
# parameter is a string representing the time zone to use. If no time
# zone is specified, the default time zone, UTC, is used. See Time
# zone definitions for information on how to specify a time zone.
#
# If the time_zone parameter evaluates to NULL, this function returns NULL.
#
# Returns DATE

!if (false) {
SELECT CURRENT_DATE() AS the_date;
+--------------+
| the_date     |
+--------------+
| 2016-12-25   |
+--------------+
!ok
!}

!if (false) {
SELECT CURRENT_DATE AS the_date;
+--------------+
| the_date     |
+--------------+
| 2016-12-25   |
+--------------+
!ok
!}

!if (false) {
SELECT CURRENT_DATE("Europe/Moscow") AS the_date;
+--------------+
| the_date     |
+--------------+
| 2016-12-26   |
+--------------+
!ok

SELECT CURRENT_DATE(null) AS the_date;
+----------+
| the_date |
+----------+
|          |
+----------+
!ok
!}

# When a column named current_date is present, the column name and the
# function call without parentheses are ambiguous. To ensure the
# function call, add parentheses; to ensure the column name, qualify
# it with its range variable. For example, the following query will
# select the function in the the_date column and the table column in
# the current_date column.

!if (false) {
WITH t AS (SELECT 'column value' AS `current_date`)
SELECT current_date() AS the_date, t.current_date FROM t;
+------------+--------------+
| the_date   | current_date |
+------------+--------------+
| 2016-12-25 | column value |
+------------+--------------+
!ok
!}

#####################################################################
# CURRENT_DATETIME
#
# CURRENT_DATETIME([time_zone])
#
# Returns the current time as a DATETIME object. Parentheses are
# optional when called with no arguments.
#
# This function supports an optional time_zone parameter. See Time
# zone definitions for information on how to specify a time zone.
#
# Returns DATETIME

SELECT CURRENT_DATETIME() > DATETIME '2008-12-25 15:30:00' as now;
+------+
| now  |
+------+
| true |
+------+
(1 row)

!ok

SELECT CURRENT_DATETIME > DATETIME '2008-12-25 15:30:00' as now;
+------+
| now  |
+------+
| true |
+------+
(1 row)

!ok

# When a column named current_datetime is present, the column name and
# the function call without parentheses are ambiguous. To ensure the
# function call, add parentheses; to ensure the column name, qualify
# it with its range variable. For example, the following query will
# select the function in the now column and the table column in the
# current_datetime column.

WITH t AS (SELECT 'column value' AS `current_datetime`)
SELECT current_datetime() > DATETIME '2008-12-25 15:30:00' as now, t.current_datetime FROM t;
+------+------------------+
| now  | current_datetime |
+------+------------------+
| true | column value     |
+------+------------------+
(1 row)

!ok

SELECT CURRENT_DATETIME('UTC') > DATETIME '2008-12-25 15:30:00';
+--------+
| EXPR$0 |
+--------+
| true   |
+--------+
(1 row)

!ok

#####################################################################
# CURRENT_TIME
#
# CURRENT_TIME([time_zone])
#
#
# Returns the current time as a TIME object. Parentheses are optional
# when called with no arguments.
#
# This function supports an optional time_zone parameter. See Time
# zone definitions for information on how to specify a time zone.
#
# Returns TIME

!if (false) {
SELECT CURRENT_TIME() as now;

+----------------------------+
| now                        |
+----------------------------+
| 15:31:38.776361            |
+----------------------------+
!ok
!}

# When a column named current_time is present, the column name and the
# function call without parentheses are ambiguous. To ensure the
# function call, add parentheses; to ensure the column name, qualify
# it with its range variable. For example, the following query will
# select the function in the now column and the table column in the
# current_time column.

!if (false) {
WITH t AS (SELECT 'column value' AS `current_time`)
SELECT current_time() as now, t.current_time FROM t;

+-----------------+--------------+
| now             | current_time |
+-----------------+--------------+
| 15:31:38.776361 | column value |
+-----------------+--------------+
!ok
!}

#####################################################################
# CURRENT_TIMESTAMP
# Parentheses are optional
!if (false) {
select current_timestamp() as now;
+---------------------+
| now                 |
+---------------------+
| 2022-06-02 17:58:58 |
+---------------------+
(1 row)

!ok
!}

!if (false) {
select current_timestamp as now;
+---------------------+
| now                 |
+---------------------+
| 2022-06-02 17:58:58 |
+---------------------+
(1 row)

!ok
!}

# When a column named current_timestamp is present, the column name
# and the function call without parentheses are ambiguous. To ensure
# the function call, add parentheses; to ensure the column name,
# qualify it with its range variable. For example, the following query
# will select the function in the now column and the table column in
# the current_timestamp column.
!if (false) {
WITH t AS (SELECT 'column value' AS `current_timestamp`)
SELECT current_timestamp() AS now, t.current_timestamp FROM t;
+--------------------------------+-------------------+
| now                            | current_timestamp |
+--------------------------------+-------------------+
| 2020-06-02 23:57:12.120174 UTC | column value      |
+--------------------------------+-------------------+
!ok
!}

#####################################################################
# EXTRACT
#
# EXTRACT(part FROM date_expression)
#   Returns the value corresponding to the specified date part
# EXTRACT(part FROM datetime_expression)
#   Returns a value that corresponds to the specified part from a
#   supplied datetime_expression.
# EXTRACT(part FROM time_expression)
#   Returns a value that corresponds to the specified part from a
#   supplied time_expression.
# EXTRACT(part FROM timestamp_expression [AT TIME ZONE time_zone])
#
# For date, the part must be one of:
#
#   DAYOFWEEK: Returns values in the range [1,7] with Sunday as the
#     first day of the week.
#   DAY
#   DAYOFYEAR
#   WEEK: Returns the week number of the date in the range [0,
#     53]. Weeks begin with Sunday, and dates prior to the first
#     Sunday of the year are in week 0.
#   WEEK(<WEEKDAY>): Returns the week number of the date in the range
#     [0, 53]. Weeks begin on WEEKDAY. Dates prior to the first
#     WEEKDAY of the year are in week 0. Valid values for WEEKDAY are
#     SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and
#     SATURDAY.
#   ISOWEEK: Returns the ISO 8601 week number of the
#     date_expression. ISOWEEKs begin on Monday. Return values are in
#     the range [1, 53]. The first ISOWEEK of each ISO year begins on
#     the Monday before the first Thursday of the Gregorian calendar
#     year.
#   MONTH
#   QUARTER: Returns values in the range [1,4].
#   YEAR
#   ISOYEAR: Returns the ISO 8601 week-numbering year, which is the
#     Gregorian calendar year containing the Thursday of the week to
#     which date_expression belongs.
#
# For time, allowed part values are:
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#
# For timestamp and datetime, allowed part values are:
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#   DAYOFWEEK: Returns values in the range [1,7] with Sunday as the
#     first day of of the week.
#   DAY
#   DAYOFYEAR
#   WEEK: Returns the week number of the date in the range [0,
#     53]. Weeks begin with Sunday, and dates prior to the first Sunday of
#     the year are in week 0.
#   WEEK(<WEEKDAY>): Returns the week number of datetime_expression in
#     the range [0, 53]. Weeks begin on WEEKDAY. datetimes prior to the
#     first WEEKDAY of the year are in week 0. Valid values for WEEKDAY
#     are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and
#     SATURDAY.
#   ISOWEEK: Returns the ISO 8601 week number of the
#     datetime_expression. ISOWEEKs begin on Monday. Return values are
#     in the range [1, 53]. The first ISOWEEK of each ISO year begins
#     on the Monday before the first Thursday of the Gregorian
#     calendar year.
#   MONTH
#   QUARTER
#   YEAR
#   ISOYEAR: Returns the ISO 8601 week-numbering year, which is the
#     Gregorian calendar year containing the Thursday of the week to
#     which date_expression belongs.
#   DATE
#   TIME
#
# Returned values truncate lower order time periods. For example, when
# extracting seconds, EXTRACT truncates the millisecond and
# microsecond values.
#
# Returns INT64, except in the following cases:
#   If part is DATE, returns a DATE object.
#   If part is TIME, returns a TIME object.

# In the following example, EXTRACT returns a value corresponding to
# the DAY date part.

SELECT EXTRACT(DAY FROM DATE '2013-12-25') AS the_day;
+---------+
| the_day |
+---------+
|      25 |
+---------+
(1 row)

!ok

SELECT
  EXTRACT(DAYOFWEEK FROM DATE '2008-12-25') as day_of_week,
  EXTRACT(DOW FROM DATE '2008-12-25') as dow;
+-------------+-----+
| day_of_week | dow |
+-------------+-----+
|           5 |   5 |
+-------------+-----+
(1 row)

!ok

SELECT
  EXTRACT(DAYOFYEAR FROM DATE '2008-12-25') as day_of_year,
  EXTRACT(DOY FROM DATE '2008-12-25') as doy;
+-------------+-----+
| day_of_year | doy |
+-------------+-----+
|         360 | 360 |
+-------------+-----+
(1 row)

!ok

# In the following example, EXTRACT returns values corresponding to
# different date parts from a column of dates near the end of the
# year.

!if (false) {
SELECT
  d,
  EXTRACT(ISOYEAR FROM d) AS isoyear,
  EXTRACT(ISOWEEK FROM d) AS isoweek,
  EXTRACT(YEAR FROM d) AS year,
  EXTRACT(WEEK FROM d) AS week
FROM UNNEST(
  ARRAY [DATE '2015-12-23',
         DATE '2015-12-24',
         DATE '2015-12-25',
         DATE '2015-12-26',
         DATE '2015-12-27',
         DATE '2015-12-28',
         DATE '2015-12-29',
         DATE '2015-12-30',
         DATE '2015-12-31',
         DATE '2016-01-01',
         DATE '2016-01-02',
         DATE '2016-01-03',
         DATE '2016-01-04',
         DATE '2016-01-05',
         DATE '2016-01-06',
         DATE '2016-01-07',
         DATE '2016-01-08',
         DATE '2016-01-09']) AS d
ORDER BY d;
+------------+---------+---------+------+------+
| date       | isoyear | isoweek | year | week |
+------------+---------+---------+------+------+
| 2015-12-23 | 2015    | 52      | 2015 | 51   |
| 2015-12-24 | 2015    | 52      | 2015 | 51   |
| 2015-12-25 | 2015    | 52      | 2015 | 51   |
| 2015-12-26 | 2015    | 52      | 2015 | 51   |
| 2015-12-27 | 2015    | 52      | 2015 | 52   |
| 2015-12-28 | 2015    | 53      | 2015 | 52   |
| 2015-12-29 | 2015    | 53      | 2015 | 52   |
| 2015-12-30 | 2015    | 53      | 2015 | 52   |
| 2015-12-31 | 2015    | 53      | 2015 | 52   |
| 2016-01-01 | 2015    | 53      | 2016 | 0    |
| 2016-01-02 | 2015    | 53      | 2016 | 0    |
| 2016-01-03 | 2015    | 53      | 2016 | 1    |
| 2016-01-04 | 2016    | 1       | 2016 | 1    |
| 2016-01-05 | 2016    | 1       | 2016 | 1    |
| 2016-01-06 | 2016    | 1       | 2016 | 1    |
| 2016-01-07 | 2016    | 1       | 2016 | 1    |
| 2016-01-08 | 2016    | 1       | 2016 | 1    |
| 2016-01-09 | 2016    | 1       | 2016 | 1    |
+------------+---------+---------+------+------+
!ok
!}

# In the following example, date_expression falls on a Sunday. EXTRACT
# calculates the first column using weeks that begin on Sunday, and it
# calculates the second column using weeks that begin on Monday.

!if (false) {
WITH t AS (SELECT DATE('2017-11-05') AS d)
SELECT
  d,
  EXTRACT(WEEK(SUNDAY) FROM d) AS week_sunday,
  EXTRACT(WEEK(MONDAY) FROM d) AS week_monday FROM t;
+------------+-------------+-------------+
| date       | week_sunday | week_monday |
+------------+-------------+-------------+
| 2017-11-05 | 45          | 44          |
+------------+-------------+-------------+
!ok
!}

# In the following example, EXTRACT returns a value corresponding to
# the HOUR time part.
!if (false) {
SELECT EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00)) as hour;
+------------------+
| hour             |
+------------------+
| 15               |
+------------------+
!ok
!}

# In the following example, EXTRACT returns values corresponding to
# different time parts from a column of datetimes.
!if (false) {
WITH Datetimes AS (
  SELECT DATETIME '2005-01-03 12:34:56' AS dt UNION ALL
  SELECT DATETIME '2007-12-31' UNION ALL
  SELECT DATETIME '2009-01-01' UNION ALL
  SELECT DATETIME '2009-12-31' UNION ALL
  SELECT DATETIME '2017-01-02' UNION ALL
  SELECT DATETIME '2017-05-26'
)
SELECT
  datetime,
  EXTRACT(ISOYEAR FROM dt) AS isoyear,
  EXTRACT(ISOWEEK FROM dt) AS isoweek,
  EXTRACT(YEAR FROM dt) AS year,
  EXTRACT(WEEK FROM dt) AS week
FROM Datetimes
ORDER BY dt;
+---------------------+---------+---------+------+------+
| dt                  | isoyear | isoweek | year | week |
+---------------------+---------+---------+------+------+
| 2005-01-03T12:34:56 | 2005    | 1       | 2005 | 1    |
| 2007-12-31T00:00:00 | 2008    | 1       | 2007 | 52   |
| 2009-01-01T00:00:00 | 2009    | 1       | 2009 | 0    |
| 2009-12-31T00:00:00 | 2009    | 53      | 2009 | 52   |
| 2017-01-02T00:00:00 | 2017    | 1       | 2017 | 1    |
| 2017-05-26T00:00:00 | 2017    | 21      | 2017 | 21   |
+---------------------+---------+---------+------+------+
!ok
!}

# In the following example, datetime_expression falls on a
# Sunday. EXTRACT calculates the first column using weeks that begin
# on Sunday, and it calculates the second column using weeks that
# begin on Monday.
!if (false) {
WITH t AS (SELECT DATETIME(TIMESTAMP "2017-11-05 00:00:00+00", "UTC") AS dt)
SELECT
  dt,
  EXTRACT(WEEK(SUNDAY) FROM dt) AS week_sunday,
  EXTRACT(WEEK(MONDAY) FROM dt) AS week_monday
FROM t;
+---------------------+-------------+---------------+
| dt                  | week_sunday | week_monday   |
+---------------------+-------------+---------------+
| 2017-11-05T00:00:00 | 45          | 44            |
+---------------------+-------------+---------------+
!ok
!}

!if (false) {
WITH Input AS (SELECT TIMESTAMP("2008-12-25 05:30:00+00") AS timestamp_value)
SELECT
  EXTRACT(DAY FROM timestamp_value AT TIME ZONE "UTC") AS the_day_utc,
  EXTRACT(DAY FROM timestamp_value AT TIME ZONE "America/Los_Angeles") AS the_day_california
FROM Input;
+-------------+--------------------+
| the_day_utc | the_day_california |
+-------------+--------------------+
| 25          | 24                 |
+-------------+--------------------+
!ok
!}

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
WITH Timestamps AS (
  SELECT TIMESTAMP("2005-01-03 12:34:56+00") AS timestamp_value UNION ALL
  SELECT TIMESTAMP("2007-12-31 12:00:00+00") UNION ALL
  SELECT TIMESTAMP("2009-01-01 12:00:00+00") UNION ALL
  SELECT TIMESTAMP("2009-12-31 12:00:00+00") UNION ALL
  SELECT TIMESTAMP("2017-01-02 12:00:00+00") UNION ALL
  SELECT TIMESTAMP("2017-05-26 12:00:00+00")
)
SELECT
  timestamp_value,
  EXTRACT(ISOYEAR FROM timestamp_value) AS isoyear,
  EXTRACT(ISOWEEK FROM timestamp_value) AS isoweek,
  EXTRACT(YEAR FROM timestamp_value) AS year,
  EXTRACT(WEEK FROM timestamp_value) AS week
FROM Timestamps
ORDER BY timestamp_value;
+-------------------------+---------+---------+------+------+
| timestamp_value         | isoyear | isoweek | year | week |
+-------------------------+---------+---------+------+------+
| 2005-01-03 12:34:56 UTC | 2005    | 1       | 2005 | 1    |
| 2007-12-31 12:00:00 UTC | 2008    | 1       | 2007 | 52   |
| 2009-01-01 12:00:00 UTC | 2009    | 1       | 2009 | 0    |
| 2009-12-31 12:00:00 UTC | 2009    | 53      | 2009 | 52   |
| 2017-01-02 12:00:00 UTC | 2017    | 1       | 2017 | 1    |
| 2017-05-26 12:00:00 UTC | 2017    | 21      | 2017 | 21   |
+-------------------------+---------+---------+------+------+
!ok
!}

# In the following example, timestamp_expression falls on a Monday.
# EXTRACT calculates the first column using weeks that begin on
# Sunday, and it calculates the second column using weeks that begin
# on Monday.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
WITH t AS (SELECT TIMESTAMP("2017-11-05 00:00:00+00") AS timestamp_value)
SELECT
  timestamp_value,
  EXTRACT(WEEK(SUNDAY) FROM timestamp_value) AS week_sunday,
  EXTRACT(WEEK(MONDAY) FROM timestamp_value) AS week_monday
FROM t;
+-------------------------+-------------+---------------+
| timestamp_value         | week_sunday | week_monday   |
+-------------------------+-------------+---------------+
| 2017-11-05 00:00:00 UTC | 45          | 44            |
+-------------------------+-------------+---------------+
!ok
!}

#####################################################################
# SAFE_ADD
#
# SAFE_ADD(value1, value2)
#
# Equivalent to the addition operator (+), but returns NULL if overflow/underflow occurs.
SELECT SAFE_ADD(5, 4) as result;
+--------+
| result |
+--------+
|      9 |
+--------+
(1 row)

!ok

# Overflow occurs if result is greater than 2^63 - 1
SELECT SAFE_ADD(9223372036854775807, 2) as overflow_result;
+-----------------+
| overflow_result |
+-----------------+
|                 |
+-----------------+
(1 row)

!ok

# Underflow occurs if result is less than -2^63
SELECT SAFE_ADD(-9223372036854775806, -3) as underflow_result;
+------------------+
| underflow_result |
+------------------+
|                  |
+------------------+
(1 row)

!ok

SELECT SAFE_ADD(CAST(1.7e308 as DOUBLE), CAST(1.7e308 as DOUBLE)) as double_overflow;
+-----------------+
| double_overflow |
+-----------------+
|                 |
+-----------------+
(1 row)

!ok

!if (fixed.calcite6328) {
SELECT SAFE_ADD(9, cast(9.999999999999999999e75 as DECIMAL(38, 19))) as decimal_overflow;
+------------------+
| decimal_overflow |
+------------------+
|                  |
+------------------+
(1 row)

!ok
!}

# NaN arguments should return NaN
SELECT SAFE_ADD(CAST('NaN' AS DOUBLE), CAST(3 as BIGINT)) as NaN_result;
+------------+
| NaN_result |
+------------+
|        NaN |
+------------+
(1 row)

!ok

#####################################################################
# SAFE_DIVIDE
#
# SAFE_DIVIDE(value1, value2)
#
# Equivalent to the divide operator (/), but returns NULL if
# overflow/underflow occurs or if value2 is zero.
SELECT SAFE_DIVIDE(20, 4) as result;
+--------+
| result |
+--------+
|    5.0 |
+--------+
(1 row)

!ok

# Dividing by zero should return NULL
SELECT SAFE_DIVIDE(-9223372036854775806, 0) as zero_result;
+-------------+
| zero_result |
+-------------+
|             |
+-------------+
(1 row)

!ok

SELECT SAFE_DIVIDE(CAST(1.7e308 as DOUBLE),
        CAST(1.7e-308 as DOUBLE)) as double_overflow;
+-----------------+
| double_overflow |
+-----------------+
|                 |
+-----------------+
(1 row)

!ok

!if (fixed.calcite6328) {
SELECT SAFE_DIVIDE(CAST(-3.5e75 AS DECIMAL(76, 0)),
        CAST(3.5e-75 AS DECIMAL(76, 0))) as decimal_overflow;
+------------------+
| decimal_overflow |
+------------------+
|                  |
+------------------+
(1 row)

!ok
!}

# NaN arguments should return NaN
SELECT SAFE_DIVIDE(CAST('NaN' AS DOUBLE), CAST(3 as BIGINT)) as NaN_result;
+------------+
| NaN_result |
+------------+
|        NaN |
+------------+
(1 row)

!ok

# Expression parameters should be valid
SELECT SAFE_DIVIDE(1, CAST(1 AS DOUBLE) / CAST(9223372036854775807 AS DOUBLE)) as expr_result;
+----------------------+
| expr_result          |
+----------------------+
| 9.223372036854776E18 |
+----------------------+
(1 row)

!ok

#####################################################################
# SAFE_MULTIPLY
#
# SAFE_MULTIPLY(value1, value2)
#
# Equivalent to the mulitply operator (*), but returns NULL if overflow/underflow occurs.
SELECT SAFE_MULTIPLY(5, 4) as result;
+--------+
| result |
+--------+
|     20 |
+--------+
(1 row)

!ok

# Overflow occurs if result is greater than 2^63 - 1
SELECT SAFE_MULTIPLY(9223372036854775807, 2) as overflow_result;
+-----------------+
| overflow_result |
+-----------------+
|                 |
+-----------------+
(1 row)

!ok

# Underflow occurs if result is less than -2^63
SELECT SAFE_MULTIPLY(-9223372036854775806, 3) as underflow_result;
+------------------+
| underflow_result |
+------------------+
|                  |
+------------------+
(1 row)

!ok

SELECT SAFE_MULTIPLY(CAST(1.7e308 as DOUBLE), CAST(3 as BIGINT)) as double_overflow;
+-----------------+
| double_overflow |
+-----------------+
|                 |
+-----------------+
(1 row)

!ok

!if (fixed.calcite6328) {
SELECT SAFE_MULTIPLY(CAST(-3.5e75 AS DECIMAL(76, 0)), CAST(10 AS BIGINT)) as decimal_overflow;
+------------------+
| decimal_overflow |
+------------------+
|                  |
+------------------+
(1 row)

!ok
!}

# NaN arguments should return NaN
SELECT SAFE_MULTIPLY(CAST('NaN' AS DOUBLE), CAST(3 as BIGINT)) as NaN_result;
+------------+
| NaN_result |
+------------+
|        NaN |
+------------+
(1 row)

!ok

#####################################################################
# SAFE_NEGATE
#
# SAFE_NEGATE(value)
#
# Returns value * -1, or NULL on overflow.
SELECT SAFE_NEGATE(5) as result;
+--------+
| result |
+--------+
|     -5 |
+--------+
(1 row)

!ok

SELECT SAFE_NEGATE(-5) as result;
+--------+
| result |
+--------+
|      5 |
+--------+
(1 row)

!ok

SELECT SAFE_NEGATE(-9223372036854775808) as overflow_result;
+-----------------+
| overflow_result |
+-----------------+
|                 |
+-----------------+
(1 row)

!ok

SELECT SAFE_NEGATE(1 + 2 + 3 + 4) as expr_result;
+-------------+
| expr_result |
+-------------+
|         -10 |
+-------------+
(1 row)

!ok

#####################################################################
# SAFE_SUBTRACT
#
# SAFE_SUBTRACT(value1, value2)
#
# Equivalent to the subtraction operator (-), but returns NULL if overflow/underflow occurs.
SELECT SAFE_SUBTRACT(5, 4) as result;
+--------+
| result |
+--------+
|      1 |
+--------+
(1 row)

!ok

# Overflow occurs if result is greater than 2^63 - 1
SELECT SAFE_SUBTRACT(9223372036854775807, -2) as overflow_result;
+-----------------+
| overflow_result |
+-----------------+
|                 |
+-----------------+
(1 row)

!ok

# Underflow occurs if result is less than -2^63
SELECT SAFE_SUBTRACT(-9223372036854775806, 3) as underflow_result;
+------------------+
| underflow_result |
+------------------+
|                  |
+------------------+
(1 row)

!ok

SELECT SAFE_SUBTRACT(CAST(1.7e308 as DOUBLE), CAST(-1.7e308 as DOUBLE)) as double_overflow;
+-----------------+
| double_overflow |
+-----------------+
|                 |
+-----------------+
(1 row)

!ok

!if (fixed.calcite6328) {
SELECT SAFE_SUBTRACT(9, cast(-9.999999999999999999e75 as DECIMAL(38, 19))) as decimal_overflow;
+------------------+
| decimal_overflow |
+------------------+
|                  |
+------------------+
(1 row)

!ok
!}

# NaN arguments should return NaN
SELECT SAFE_SUBTRACT(CAST('NaN' AS DOUBLE), CAST(3 as BIGINT)) as NaN_result;
+------------+
| NaN_result |
+------------+
|        NaN |
+------------+
(1 row)

!ok

# Expression parameters should be valid
SELECT SAFE_SUBTRACT(1 + 2 + 3, 5) as expr_result;
+-------------+
| expr_result |
+-------------+
|           1 |
+-------------+
(1 row)

!ok

#####################################################################
# NOT EQUAL Operator (value1 != value2)
#
# Compares value1 and value2 and returns TRUE if not equal.
SELECT (5 != 3) as result;
+--------+
| result |
+--------+
| true   |
+--------+
(1 row)

!ok

SELECT (5 != 5) as result;
+--------+
| result |
+--------+
| false  |
+--------+
(1 row)

!ok

#####################################################################
# MODULO % OPERATOR (value1 % value2)
#
# Returns the remainder of dividing value1 by value2.
SELECT (5 % 3) as result;
+--------+
| result |
+--------+
|      2 |
+--------+
(1 row)

!ok

SELECT (19 % 19) as result;
+--------+
| result |
+--------+
|      0 |
+--------+
(1 row)

!ok

#####################################################################
# REGEXP_CONTAINS(value, regexp)
#
# Takes two STRING values. Returns TRUE if value is a partial match
# for the regular expression, regexp.
# If the regexp argument is invalid, the function returns an error.
# Uses java.util.regex as a standard for regex processing
# in Calcite instead of RE2 used by BigQuery/GoogleSQL.

SELECT
  email,
  REGEXP_CONTAINS(email, '@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+') AS is_valid
FROM
  (SELECT
    ARRAY['foo@example.com', 'bar@example.org', 'www.example.net']
    AS addresses),
  UNNEST(addresses) AS email;
+-----------------+----------+
| email           | is_valid |
+-----------------+----------+
| bar@example.org | true     |
| foo@example.com | true     |
| www.example.net | false    |
+-----------------+----------+
(3 rows)

!ok

SELECT
  email,
  REGEXP_CONTAINS(email, '^([\w.+-]+@foo\.com|[\w.+-]+@bar\.org)\s*$')
    AS valid_email_address,
  REGEXP_CONTAINS(email, '^[\w.+-]+@foo\.com|[\w.+-]+@bar\.org\s*$')
    AS without_parentheses
FROM
  (SELECT
    ARRAY['a@foo.com', 'a@foo.computer', 'b@bar.org', '!b@bar.org', 'c@buz.net']
    AS addresses),
  UNNEST(addresses) AS email;
+----------------+---------------------+---------------------+
| email          | valid_email_address | without_parentheses |
+----------------+---------------------+---------------------+
| a@foo.computer | false               | true                |
| c@buz.net      | false               | false               |
| !b@bar.org     | false               | true                |
| a@foo.com      | true                | true                |
| b@bar.org      | true                | true                |
+----------------+---------------------+---------------------+
(5 rows)

!ok

SELECT REGEXP_CONTAINS('abc def ghi', '(abc');
Invalid regular expression for REGEXP_CONTAINS: 'Unclosed group near index 4 (abc'
!error

SELECT REGEXP_CONTAINS('abc def ghi', '[z-a]');
Invalid regular expression for REGEXP_CONTAINS: 'Illegal character range near index 3 [z-a]    ^'
!error

SELECT REGEXP_CONTAINS('abc def ghi', '{2,1}');
Invalid regular expression for REGEXP_CONTAINS: 'Illegal repetition range near index 4 {2,1}     ^'
!error

#####################################################################
# REGEXP_EXTRACT(value, regexp[, position[, occurrence]])
#
# Returns the substring in value that matches the regexp.
# Returns NULL if there is no match, or if position or occurrence are beyond range.
# Returns an exception if regex, position or occurrence are invalid.

WITH email_addresses AS
  (SELECT 'foo@example.com' as email
  UNION ALL
  SELECT 'bar@example.org' as email
  UNION ALL
  SELECT 'baz@example.net' as email)
SELECT
  REGEXP_EXTRACT(email, '^[a-zA-Z0-9_.+-]+')
  AS user_name
FROM email_addresses;
+-----------+
| user_name |
+-----------+
| foo       |
| bar       |
| baz       |
+-----------+
(3 rows)

!ok

WITH
characters AS (
 SELECT 'ab' AS value, '.b' AS regex UNION ALL
 SELECT 'ab' AS value, '(.)b' AS regex UNION ALL
 SELECT 'xyztb' AS value, '(.)+b' AS regex UNION ALL
 SELECT 'ab' AS value, '(z)?b' AS regex
)
SELECT value, regex, REGEXP_EXTRACT(value, regex) AS result FROM characters;
+-------+-------+--------+
| value | regex | result |
+-------+-------+--------+
| ab    | (.)b  | a      |
| ab    | (z)?b |        |
| ab    | .b    | ab     |
| xyztb | (.)+b | t      |
+-------+-------+--------+
(4 rows)

!ok

WITH example AS
(SELECT 'Hello Helloo and Hellooo' AS value, 'H?ello+' AS regex, 1 as position,
1 AS occurrence UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 1, 2 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 1, 3 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 1, 4 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 2, 1 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 3, 1 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 3, 2 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 3, 3 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 20, 1 UNION ALL
SELECT 'cats&dogs&rabbits' ,'\\w+&', 1, 2 UNION ALL
SELECT 'cats&dogs&rabbits', '\\w+&', 2, 3
)
SELECT value, regex, position, occurrence, REGEXP_EXTRACT(value, regex,
position, occurrence) AS regexp_value FROM example;
+--------------------------+---------+----------+------------+--------------+
| value                    | regex   | position | occurrence | regexp_value |
+--------------------------+---------+----------+------------+--------------+
| Hello Helloo and Hellooo | H?ello+ |        1 |          1 | Hello        |
| Hello Helloo and Hellooo | H?ello+ |        1 |          2 | Helloo       |
| Hello Helloo and Hellooo | H?ello+ |        1 |          3 | Hellooo      |
| Hello Helloo and Hellooo | H?ello+ |        1 |          4 |              |
| Hello Helloo and Hellooo | H?ello+ |        2 |          1 | ello         |
| Hello Helloo and Hellooo | H?ello+ |       20 |          1 |              |
| Hello Helloo and Hellooo | H?ello+ |        3 |          1 | Helloo       |
| Hello Helloo and Hellooo | H?ello+ |        3 |          2 | Hellooo      |
| Hello Helloo and Hellooo | H?ello+ |        3 |          3 |              |
| cats&dogs&rabbits        | \\w+&   |        1 |          2 |              |
| cats&dogs&rabbits        | \\w+&   |        2 |          3 |              |
+--------------------------+---------+----------+------------+--------------+
(11 rows)

!ok

SELECT REGEXP_EXTRACT("abcadcabcaecghi", "a.+c");
+--------------+
| EXPR$0       |
+--------------+
| abcadcabcaec |
+--------------+
(1 row)

!ok

SELECT REGEXP_EXTRACT("abcadcabcaecghi", "abc(a.c)", 4);
+--------+
| EXPR$0 |
+--------+
| aec    |
+--------+
(1 row)

!ok

SELECT REGEXP_EXTRACT("abcadcabcaecghi", "a.c", 25);
+--------+
| EXPR$0 |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT REGEXP_EXTRACT("abcadcabcaecghi", "a.c", 1, 5);
+--------+
| EXPR$0 |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT REGEXP_EXTRACT("abc def ghi", "{2,1}");
Invalid regular expression for REGEXP_EXTRACT: 'Illegal repetition range near index 4 {2,1}     ^'
!error

SELECT REGEXP_EXTRACT("abcadcabcaecghi", "(abc)ax(a.c)");
Multiple capturing groups (count=2) not allowed in regex input for REGEXP_EXTRACT
!error

SELECT REGEXP_EXTRACT("abcadcabcaecghi", "a.c", -4);
Invalid integer input '-4' for argument 'position' in REGEXP_EXTRACT
!error

SELECT REGEXP_EXTRACT("abcadcabcaecghi", "a.c", 3, 0);
Invalid integer input '0' for argument 'occurrence' in REGEXP_EXTRACT
!error

#####################################################################
# REGEXP_EXTRACT_ALL(value, regexp)
#
# Returns an array of all substrings in value that matches the regexp.
# Returns an empty array if there is no match.
# Returns an exception if regex is invalid or has more than one capturing group.

WITH code_markdown AS
  (SELECT 'Try `function(x)` or `function(y)`' as code)
SELECT
  REGEXP_EXTRACT_ALL(code, '`(.+?)`') AS example
FROM code_markdown;
+----------------------------+
| example                    |
+----------------------------+
| [function(x), function(y)] |
+----------------------------+
(1 row)

!ok

SELECT REGEXP_EXTRACT_ALL("abcadcabcaecghi", "abc(a.c)");
+------------+
| EXPR$0     |
+------------+
| [adc, aec] |
+------------+
(1 row)

!ok

SELECT REGEXP_EXTRACT_ALL("abacadaeafa", "a.a");
+-----------------+
| EXPR$0          |
+-----------------+
| [aba, ada, afa] |
+-----------------+
(1 row)

!ok

SELECT REGEXP_EXTRACT_ALL("12345abc123", "a[0-9]");
+--------+
| EXPR$0 |
+--------+
| []     |
+--------+
(1 row)

!ok

SELECT REGEXP_EXTRACT_ALL("abc def ghi", "{4,1}");
Invalid regular expression for REGEXP_EXTRACT_ALL: 'Illegal repetition range near index 4 {4,1}     ^'
!error

SELECT REGEXP_EXTRACT_ALL("abcadcabcaecghi", "(a.c).(.*)$");
Multiple capturing groups (count=2) not allowed in regex input for REGEXP_EXTRACT_ALL
!error

#####################################################################
# REGEXP_INSTR(value, regexp[, position[, occurrence[, occurrence_position]]])
#
# Returns the lowest 1-based position of regexp in value.
# Returns 0 if there is no match, regex is empty or if position or occurrence are beyond range.
# Returns an exception if regex, position, occurrence or occurrence_position are invalid.

WITH example AS (
  SELECT 'ab@cd-ef' AS source_value, '@[^-]*' AS regexp UNION ALL
  SELECT 'ab@d-ef', '@[^-]*' UNION ALL
  SELECT 'abc@cd-ef', '@[^-]*' UNION ALL
  SELECT 'abc-ef', '@[^-]*')
SELECT source_value, regexp, REGEXP_INSTR(source_value, regexp) AS instr
FROM example;
+--------------+--------+-------+
| source_value | regexp | instr |
+--------------+--------+-------+
| ab@cd-ef     | @[^-]* |     3 |
| ab@d-ef      | @[^-]* |     3 |
| abc-ef       | @[^-]* |     0 |
| abc@cd-ef    | @[^-]* |     4 |
+--------------+--------+-------+
(4 rows)

!ok

WITH example AS (
  SELECT 'a@cd-ef b@cd-ef' AS source_value, '@[^-]*' AS regexp, 1 AS position UNION ALL
  SELECT 'a@cd-ef b@cd-ef', '@[^-]*', 2 UNION ALL
  SELECT 'a@cd-ef b@cd-ef', '@[^-]*', 3 UNION ALL
  SELECT 'a@cd-ef b@cd-ef', '@[^-]*', 4)
SELECT
  source_value, regexp, position,
  REGEXP_INSTR(source_value, regexp, position) AS instr
FROM example;
+-----------------+--------+----------+-------+
| source_value    | regexp | position | instr |
+-----------------+--------+----------+-------+
| a@cd-ef b@cd-ef | @[^-]* |        1 |     2 |
| a@cd-ef b@cd-ef | @[^-]* |        2 |     2 |
| a@cd-ef b@cd-ef | @[^-]* |        3 |    10 |
| a@cd-ef b@cd-ef | @[^-]* |        4 |    10 |
+-----------------+--------+----------+-------+
(4 rows)

!ok

WITH example AS (
  SELECT 'a@cd-ef b@cd-ef c@cd-ef' AS source_value,
         '@[^-]*' AS regexp, 1 AS position, 1 AS occurrence UNION ALL
  SELECT 'a@cd-ef b@cd-ef c@cd-ef', '@[^-]*', 1, 2 UNION ALL
  SELECT 'a@cd-ef b@cd-ef c@cd-ef', '@[^-]*', 1, 3)
SELECT
  source_value, regexp, position, occurrence,
  REGEXP_INSTR(source_value, regexp, position, occurrence) AS instr
FROM example;
+-------------------------+--------+----------+------------+-------+
| source_value            | regexp | position | occurrence | instr |
+-------------------------+--------+----------+------------+-------+
| a@cd-ef b@cd-ef c@cd-ef | @[^-]* |        1 |          1 |     2 |
| a@cd-ef b@cd-ef c@cd-ef | @[^-]* |        1 |          2 |    10 |
| a@cd-ef b@cd-ef c@cd-ef | @[^-]* |        1 |          3 |    18 |
+-------------------------+--------+----------+------------+-------+
(3 rows)

!ok

WITH example AS (
  SELECT 'a@cd-ef' AS source_value, '@[^-]*' AS regexp,
         1 AS position, 1 AS occurrence, 0 AS o_position UNION ALL
  SELECT 'a@cd-ef', '@[^-]*', 1, 1, 1)
SELECT
  source_value, regexp, position, occurrence, o_position,
  REGEXP_INSTR(source_value, regexp, position, occurrence, o_position) AS instr
FROM example;
+--------------+--------+----------+------------+------------+-------+
| source_value | regexp | position | occurrence | o_position | instr |
+--------------+--------+----------+------------+------------+-------+
| a@cd-ef      | @[^-]* |        1 |          1 |          0 |     2 |
| a@cd-ef      | @[^-]* |        1 |          1 |          1 |     5 |
+--------------+--------+----------+------------+------------+-------+
(2 rows)

!ok

SELECT REGEXP_INSTR("abcadcabcaecghi", "a.+c");
+--------+
| EXPR$0 |
+--------+
|      1 |
+--------+
(1 row)

!ok

SELECT REGEXP_INSTR("abcadcabcaecghi", "abc(a.c)", 4);
+--------+
| EXPR$0 |
+--------+
|     10 |
+--------+
(1 row)

!ok

SELECT REGEXP_INSTR("abcadcabcaecghi", "a.c", 25);
+--------+
| EXPR$0 |
+--------+
|      0 |
+--------+
(1 row)

!ok

SELECT REGEXP_INSTR("abcadcabcaecghi", "a.c", 1, 5);
+--------+
| EXPR$0 |
+--------+
|      0 |
+--------+
(1 row)

!ok

SELECT REGEXP_INSTR("a9cadca5c4aecghi", "a[0-9]c", 1, 2, 1);
+--------+
| EXPR$0 |
+--------+
|     10 |
+--------+
(1 row)

!ok

SELECT REGEXP_INSTR("abc def ghi", "adz)");
Invalid regular expression for REGEXP_INSTR: 'Unmatched closing ')' near index 2 adz)   ^'
!error

SELECT REGEXP_INSTR("abc def ghi", "(^)a(.*)b($)");
Multiple capturing groups (count=3) not allowed in regex input for REGEXP_INSTR
!error

SELECT REGEXP_INSTR("abcadcabcaecghi", "a.c", 0);
Invalid integer input '0' for argument 'position' in REGEXP_INSTR
!error

SELECT REGEXP_INSTR("abcadcabcaecghi", "a.c", 3, -2);
Invalid integer input '-2' for argument 'occurrence' in REGEXP_INSTR
!error

SELECT REGEXP_INSTR("abcadcabcaecghi", "a.c", 3, 2, -2);
Invalid integer input '-2' for argument 'occurrence_position' in REGEXP_INSTR
!error

#####################################################################
# REGEXP_REPLACE(value, regexp, replacement)
#
# Returns a STRING where all substrings of value that match regexp are replaced with replacement.
# Supports backslashed-escaped digits in replacement argument for corresponding capturing groups
# in regexp. Returns an exception if regex is invalid.

SELECT REGEXP_REPLACE("qw1e1rt1y", "1", "X");
+-----------+
| EXPR$0    |
+-----------+
| qwXeXrtXy |
+-----------+
(1 row)

!ok

SELECT REGEXP_REPLACE("a0b1c2d3", "a|d", "X");
+----------+
| EXPR$0   |
+----------+
| X0b1c2X3 |
+----------+
(1 row)

!ok

SELECT REGEXP_REPLACE("1=00--20=0", "(-)", "#");
+------------+
| EXPR$0     |
+------------+
| 1=00##20=0 |
+------------+
(1 row)

!ok

#####################################################################
# REGEXP_SUBSTR(value, regexp[, position[, occurrence]])
#
# Synonym for REGEXP_EXTRACT. Returns the substring in value that matches the regexp.
# Returns NULL if there is no match, or if position or occurrence are beyond range.
# Returns an exception if regex, position or occurrence are invalid.

WITH email_addresses AS
  (SELECT 'foo@example.com' as email
  UNION ALL
  SELECT 'bar@example.org' as email
  UNION ALL
  SELECT 'baz@example.net' as email)
SELECT
  REGEXP_SUBSTR(email, '^[a-zA-Z0-9_.+-]+')
  AS user_name
FROM email_addresses;
+-----------+
| user_name |
+-----------+
| foo       |
| bar       |
| baz       |
+-----------+
(3 rows)

!ok

WITH
characters AS (
 SELECT 'ab' AS value, '.b' AS regex UNION ALL
 SELECT 'ab' AS value, '(.)b' AS regex UNION ALL
 SELECT 'xyztb' AS value, '(.)+b' AS regex UNION ALL
 SELECT 'ab' AS value, '(z)?b' AS regex
)
SELECT value, regex, REGEXP_SUBSTR(value, regex) AS result FROM characters;
+-------+-------+--------+
| value | regex | result |
+-------+-------+--------+
| ab    | (.)b  | a      |
| ab    | (z)?b |        |
| ab    | .b    | ab     |
| xyztb | (.)+b | t      |
+-------+-------+--------+
(4 rows)

!ok

WITH example AS
(SELECT 'Hello World Helloo' AS value, 'H?ello+' AS regex, 1 AS position, 1 AS
occurrence
)
SELECT value, regex, position, occurrence, REGEXP_SUBSTR(value, regex,
position, occurrence) AS regexp_value FROM example;
+--------------------+---------+----------+------------+--------------+
| value              | regex   | position | occurrence | regexp_value |
+--------------------+---------+----------+------------+--------------+
| Hello World Helloo | H?ello+ |        1 |          1 | Hello        |
+--------------------+---------+----------+------------+--------------+
(1 row)

!ok

SELECT REGEXP_SUBSTR("abcadcabcaecghi", "a.+c");
+--------------+
| EXPR$0       |
+--------------+
| abcadcabcaec |
+--------------+
(1 row)

!ok

SELECT REGEXP_SUBSTR("abcadcabcaecghi", "abc(a.c)", 4);
+--------+
| EXPR$0 |
+--------+
| aec    |
+--------+
(1 row)

!ok

SELECT REGEXP_SUBSTR("abcadcabcaecghi", "a.c", 25);
+--------+
| EXPR$0 |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT REGEXP_SUBSTR("abcadcabcaecghi", "a.c", 1, 5);
+--------+
| EXPR$0 |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT REGEXP_SUBSTR("abc def ghi", "{2,1}");
Invalid regular expression for REGEXP_EXTRACT: 'Illegal repetition range near index 4 {2,1}     ^'
!error

SELECT REGEXP_SUBSTR("abcadcabcaecghi", "(abc)ax(a.c)");
Multiple capturing groups (count=2) not allowed in regex input for REGEXP_EXTRACT
!error

SELECT REGEXP_SUBSTR("abcadcabcaecghi", "a.c", -4);
Invalid integer input '-4' for argument 'position' in REGEXP_EXTRACT
!error

SELECT REGEXP_SUBSTR("abcadcabcaecghi", "a.c", 3, 0);
Invalid integer input '0' for argument 'occurrence' in REGEXP_EXTRACT
!error

#####################################################################
# SPLIT
#
# SPLIT(string [, delimiter])
#
# Splits string using the delimiter argument. For STRING, the default
# delimiter is the comma.
#
# Returns a STRING array as result.
WITH letters AS
  (SELECT '' as letter_group
  UNION ALL
  SELECT 'a' as letter_group
  UNION ALL
  SELECT 'b c d' as letter_group)
SELECT SPLIT(letter_group, ' ') as example
FROM letters;
+-----------+
| example   |
+-----------+
| []        |
| [a]       |
| [b, c, d] |
+-----------+
(3 rows)

!ok

SELECT SPLIT("h,e,l,l,o") as result;
+-----------------+
| result          |
+-----------------+
| [h, e, l, l, o] |
+-----------------+
(1 row)

!ok

SELECT SPLIT("") as result;
+--------+
| result |
+--------+
| []     |
+--------+
(1 row)

!ok

# Careful to treat the delimiter as a string, not a regular expression
SELECT SPLIT("abc.de.", ".") as result;
+-------------+
| result      |
+-------------+
| [abc, de, ] |
+-------------+
(1 row)

!ok

WITH letters AS
  (SELECT x'' as letter_group
  UNION ALL
  SELECT x'41' as letter_group
  UNION ALL
  SELECT x'42ff43ff44' as letter_group)
SELECT SPLIT(letter_group, x'ff') as example
FROM letters;
+-----------+
| example   |
+-----------+
| []        |
| [A]       |
| [B, C, D] |
+-----------+
(3 rows)

!ok

SELECT SPLIT(x'abc2') as result;
Call to function 'SPLIT' with argument of type 'BINARY(2)' requires extra delimiter argument
!error

#####################################################################
# ARRAY SUBSCRIPT OPERATORS
#
# OFFSET, ORDINAL, SAFE_OFFSET, SAFE_ORDINAL
#
# Gets a value from an array at a specific position.
#
# OFFSET(index): The index starts at zero. Produces an error if the index is out of range.
# SAFE_OFFSET(index): The index starts at zero. Returns NULL if the index is out of range.
# ORDINAL(index): The index starts at one. Produces an error if the index is out of range.
# SAFE_ORDINAL(index): The index starts at one. Returns NULL if the index is out of range.

SELECT
    SPLIT('h,e,l,l,o')[OFFSET(2)] as offset_idx,
    SPLIT('h,e,l,l,o')[ORDINAL(2)] as ordinal_idx,
    SPLIT('h,e,l,l,o')[SAFE_OFFSET(2)] as safe_offset_idx,
    SPLIT('h,e,l,l,o')[SAFE_ORDINAL(2)] as safe_ordinal_idx;
+------------+-------------+-----------------+------------------+
| offset_idx | ordinal_idx | safe_offset_idx | safe_ordinal_idx |
+------------+-------------+-----------------+------------------+
| l          | e           | l               | e                |
+------------+-------------+-----------------+------------------+
(1 row)

!ok

SELECT SPLIT('h,e,l,l,o')[OFFSET(-1)] as offset_idx;
Array index -1 is out of bounds
!error

SELECT SPLIT('h,e,l,l,o')[ORDINAL(7)] as ordinal_idx;
Array index 7 is out of bounds
!error

SELECT SPLIT('h,e,l,l,o')[SAFE_OFFSET(-1)] as safe_offset_idx;
+-----------------+
| safe_offset_idx |
+-----------------+
|                 |
+-----------------+
(1 row)

!ok

SELECT SPLIT('h,e,l,l,o')[SAFE_ORDINAL(7)] as safe_ordinal_idx;
+------------------+
| safe_ordinal_idx |
+------------------+
|                  |
+------------------+
(1 row)

!ok

SELECT OFFSET(1);
java.sql.SQLException: Error while executing SQL "SELECT OFFSET(1)": parse failed: Incorrect syntax near the keyword 'OFFSET' at line 1, column 8.
!error

#####################################################################
# IS_INF
#
# IS_INF(x)
#
# Returns whether x is infinite.
SELECT IS_INF(3) AS non_inf_result;
+----------------+
| non_inf_result |
+----------------+
| false          |
+----------------+
(1 row)

!ok

SELECT IS_INF(CAST('Infinity' AS DOUBLE)) AS inf_result;
+------------+
| inf_result |
+------------+
| true       |
+------------+
(1 row)

!ok

SELECT IS_INF(CAST('NaN' AS DOUBLE)) AS nan_result;
+------------+
| nan_result |
+------------+
| false      |
+------------+
(1 row)

!ok

#####################################################################
# IS_NAN
#
# IS_NAN(x)
#
# Returns whether x is NaN.
SELECT IS_NAN(3) AS non_nan_result;
+----------------+
| non_nan_result |
+----------------+
| false          |
+----------------+
(1 row)

!ok

SELECT IS_NAN(CAST('Infinity' AS DOUBLE)) AS inf_result;
+------------+
| inf_result |
+------------+
| false      |
+------------+
(1 row)

!ok

SELECT IS_NAN(CAST('NaN' AS DOUBLE)) AS nan_result;
+------------+
| nan_result |
+------------+
| true       |
+------------+
(1 row)

!ok

#####################################################################
# LN
#
# LN(x)
#
# Computes the natural logarithm of x. Generates an error if x is less than or
# equal to zero.

SELECT LN(100) as result;
+-------------------+
| result            |
+-------------------+
| 4.605170185988092 |
+-------------------+
(1 row)

!ok

#####################################################################
# LOG
#
# LOG(x, y)
#
# If only x is present, LOG is a synonym of LN. If y is also
# present, LOG computes the logarithm of x to base y.
SELECT LOG(64, 8) as result;
+--------+
| result |
+--------+
|    2.0 |
+--------+
(1 row)

!ok

SELECT LOG(100) as result;
+-------------------+
| result            |
+-------------------+
| 4.605170185988092 |
+-------------------+
(1 row)

!ok

#####################################################################
# LOG10
#
# LOG10(x)
#
# Similar to LOG, but computes logarithm to base 10.

SELECT LOG10(100) as result;
+--------+
| result |
+--------+
|    2.0 |
+--------+
(1 row)

!ok

#####################################################################
# STRING
#
# STRING(timestamp_expression[, time_zone])
#
# Converts a timestamp_expression to a STRING data type.
# Supports an optional parameter to specify a time zone.

!if (false) {
SELECT STRING(TIMESTAMP "2008-12-25 15:30:00+00", "UTC") AS string;
+-------------------------------+
| string                        |
+-------------------------------+
| 2008-12-25 15:30:00+00        |
+-------------------------------+
!ok
!}

#####################################################################
# LENGTH(string)
#
# Returns the number of characters in the provided string.
SELECT LENGTH("hello") as length;
+--------+
| length |
+--------+
|      5 |
+--------+
(1 row)

!ok

#####################################################################
# SAFE_CAST(x AS type)
#
# Identical to CAST(), except it returns NULL instead of raising an error.

WITH Casted AS (
  SELECT SAFE_CAST("a" as int) as casted, "a" as input, "int" as as UNION ALL
  SELECT SAFE_CAST("a" as varchar(1)), "a", "varchar(1)" UNION ALL
  SELECT SAFE_CAST("2023-03-07" as DATE), DATE("2023-03-07"), "date" UNION ALL
  SELECT SAFE_CAST("2023-03-07a" as DATE), "2023-03-07a", "date" UNION ALL
  SELECT SAFE_CAST(0 as BOOLEAN), 0, "boolean"
)
SELECT
  *
FROM Casted;
+------------+-------------+------------+
| casted     | input       | as         |
+------------+-------------+------------+
|            | a           | int        |
| a          | a           | varchar(1) |
| 2023-03-07 | 2023-03-07  | date       |
|            | 2023-03-07a | date       |
| FALSE      | 0           | boolean    |
+------------+-------------+------------+
(5 rows)

!ok

WITH Casted AS (
  SELECT SAFE_CAST("12:12:11" as TIME) as casted,
   "12:12:11" as input, "time" as as UNION ALL
  SELECT SAFE_CAST("12:12:11a" as TIME), "12:12:11a", "time"
)
SELECT
  *
FROM Casted;
+----------+-----------+------+
| casted   | input     | as   |
+----------+-----------+------+
| 12:12:11 | 12:12:11  | time |
|          | 12:12:11a | time |
+----------+-----------+------+
(2 rows)

!ok

WITH Casted AS (
  SELECT SAFE_CAST(TRUE as BOOLEAN) as casted, "true" as input,
   "boolean" as as UNION ALL
  SELECT SAFE_CAST(FALSE as BOOLEAN) as casted, "false" as input,
   "boolean" as as
)
SELECT
  *
FROM Casted;
+--------+-------+---------+
| casted | input | as      |
+--------+-------+---------+
| true   | true  | boolean |
| false  | false | boolean |
+--------+-------+---------+
(2 rows)

!ok

WITH Casted AS (
  SELECT SAFE_CAST(interval '12' month as interval year) as casted,
   "interval 1 month" as input,
   "interval year" as as UNION ALL
   SELECT SAFE_CAST("a" as interval year), "a",
     "interval year" UNION ALL
   SELECT SAFE_CAST(null as interval year), "null", "interval year"
)
SELECT
  *
FROM Casted;
+--------+------------------+---------------+
| casted | input            | as            |
+--------+------------------+---------------+
| +1     | interval 1 month | interval year |
|        | a                | interval year |
|        | null             | interval year |
+--------+------------------+---------------+
(3 rows)

!ok

WITH Casted AS (
  SELECT SAFE_CAST(interval '1:1' hour to minute as interval minute to second)
   as casted, "interval 1:1 hour to minute" as input,
    "interval minute to second" as as UNION ALL
  SELECT SAFE_CAST("a" as interval minute to second),
   "a", "interval minute to second"
)
SELECT
  *
FROM Casted;
+---------------+-----------------------------+---------------------------+
| casted        | input                       | as                        |
+---------------+-----------------------------+---------------------------+
| +61:00.000000 | interval 1:1 hour to minute | interval minute to second |
|               | a                           | interval minute to second |
+---------------+-----------------------------+---------------------------+
(2 rows)

!ok

WITH Casted AS (
  SELECT SAFE_CAST('true' as BIGINT) as casted, "true" as input,
    "bigint" as as UNION ALL
  SELECT SAFE_CAST(1.0 as BIGINT), "1.0", "bigint" UNION ALL
  SELECT SAFE_CAST(1 as BIGINT), "1", "bigint" UNION ALL
  SELECT SAFE_CAST(SAFE_CAST(TRUE AS BOOLEAN) AS BIGINT),
       "TRUE", "bigint"
)
SELECT
  *
FROM Casted;
+--------+-------+--------+
| casted | input | as     |
+--------+-------+--------+
|        | true  | bigint |
|      1 | 1.0   | bigint |
|      1 | 1     | bigint |
|      1 | TRUE  | bigint |
+--------+-------+--------+
(4 rows)

!ok

#####################################################################
# STRPOS(string, substring)
#
# Returns the 1-based position of the first occurrence of substring
# within string. Returns 0 if not found.
SELECT STRPOS("abc", "a") as result;
+--------+
| result |
+--------+
|      1 |
+--------+
(1 row)

!ok

SELECT STRPOS("abc", "d") as result;
+--------+
| result |
+--------+
|      0 |
+--------+
(1 row)

!ok

SELECT STRPOS("abcabc", "bc") as result;
+--------+
| result |
+--------+
|      2 |
+--------+
(1 row)

!ok

#####################################################################
# CONTAINS_SUBSTR
#
# CONTAINS_SUBSTR(expression, search_value_literal[, json_scope=>json_scope_value])
#
# Performs a normalized, case-insensitive search to see if a value
# exists as a substring in an expression. Returns TRUE if the value
# exists, otherwise returns FALSE.
SELECT CONTAINS_SUBSTR('the blue house', 'Blue house') AS result;
+--------+
| result |
+--------+
| true   |
+--------+
(1 row)

!ok

SELECT CONTAINS_SUBSTR('the red house', 'blue') AS result;
+--------+
| result |
+--------+
| false  |
+--------+
(1 row)

!ok

SELECT '\u2168 day' AS a, 'IX' AS b, CONTAINS_SUBSTR('\u2168', 'IX') AS result;
+------------+----+--------+
| a          | b  | result |
+------------+----+--------+
| \u2168 day | IX | true   |
+------------+----+--------+
(1 row)

!ok

SELECT CONTAINS_SUBSTR((23, 35, 41), '35') AS result;
+--------+
| result |
+--------+
| true   |
+--------+
(1 row)

!ok

SELECT CONTAINS_SUBSTR(TIMESTAMP '2008-12-25 15:30:00', '15:30') AS result;
+--------+
| result |
+--------+
| true   |
+--------+
(1 row)

!ok

SELECT CONTAINS_SUBSTR((23, NULL, 41), '41') AS result;
+--------+
| result |
+--------+
| true   |
+--------+
(1 row)

!ok

SELECT CONTAINS_SUBSTR((23, NULL, 41), '35') AS result;
+--------+
| result |
+--------+
|        |
+--------+
(1 row)

!ok

# Search column references
WITH Recipes AS
 (SELECT 'Blueberry pancakes' as Breakfast, 'Egg salad sandwich' as Lunch, 'Potato dumplings' as Dinner UNION ALL
  SELECT 'Potato pancakes', 'Toasted cheese sandwich', 'Beef stroganoff' UNION ALL
  SELECT 'Ham scramble', 'Steak avocado salad', 'Tomato pasta' UNION ALL
  SELECT 'Avocado toast', 'Tomato soup', 'Blueberry salmon' UNION ALL
  SELECT 'Corned beef hash', 'Lentil potato soup', 'Glazed ham')
SELECT *, LENGTH(lunch) AS LEN FROM Recipes WHERE CONTAINS_SUBSTR((Lunch, Dinner), 'potato');
+--------------------+--------------------+------------------+-----+
| Breakfast          | Lunch              | Dinner           | LEN |
+--------------------+--------------------+------------------+-----+
| Blueberry pancakes | Egg salad sandwich | Potato dumplings |  18 |
| Corned beef hash   | Lentil potato soup | Glazed ham       |  18 |
+--------------------+--------------------+------------------+-----+
(2 rows)

!ok

# If no JSON_SCOPE is specified, "JSON_VALUES" is the default
SELECT CONTAINS_SUBSTR('{"lunch":"soup"}', "lunch") AS result;
+--------+
| result |
+--------+
| false  |
+--------+
(1 row)

!ok

SELECT CONTAINS_SUBSTR('{"lunch":"soup"}', "lunch", json_scope=>"JSON_KEYS") AS result;
+--------+
| result |
+--------+
| true   |
+--------+
(1 row)

!ok

SELECT CONTAINS_SUBSTR('{"lunch":"soup"}', "lunch", json_scope=>"JSON_VALUES") AS result;
+--------+
| result |
+--------+
| false  |
+--------+
(1 row)

!ok

SELECT CONTAINS_SUBSTR('{"lunch":"soup"}', "lunch", json_scope=>"JSON_KEYS_AND_VALUES") AS result;
+--------+
| result |
+--------+
| true   |
+--------+
(1 row)

!ok

#####################################################################
# CODE_POINTS_TO_BYTES(array<integer>)
#
# Takes an array of extended ASCII code points as ARRAY<INT64>
# and returns BYTES.
#
SELECT CODE_POINTS_TO_BYTES(array[65, 66, 67, 68]) as result;
+----------+
| result   |
+----------+
| 41424344 |
+----------+
(1 row)

!ok

SELECT CODE_POINTS_TO_BYTES(array[255, 254, 65, 64]) as result;
+----------+
| result   |
+----------+
| fffe4140 |
+----------+
(1 row)

!ok

SELECT CODE_POINTS_TO_BYTES(null) as result;
+--------+
| result |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT CODE_POINTS_TO_BYTES(array[65, null]) as result;
+--------+
| result |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT CODE_POINTS_TO_BYTES('abc') as result;
Cannot apply 'CODE_POINTS_TO_BYTES' to arguments of type 'CODE_POINTS_TO_BYTES(<CHAR(3)>)'. Supported form(s): CODE_POINTS_TO_BYTES(<INTEGER ARRAY>)
!error

SELECT CODE_POINTS_TO_BYTES(array[-1]) as result;
Input arguments of CODE_POINTS_TO_BYTES out of range: -1
!error

SELECT CODE_POINTS_TO_BYTES(array[2147483648, 1]);
Input arguments of CODE_POINTS_TO_BYTES out of range: 2147483648
!error

#####################################################################
# CODE_POINTS_TO_STRING(array<integer>)
#
# Takes an array of Unicode code points as ARRAY<INT64>
# and returns a STRING.
#
SELECT CODE_POINTS_TO_STRING(array[65, 66, 67, 68]) as result;
+--------+
| result |
+--------+
| ABCD   |
+--------+
(1 row)

!ok

SELECT CODE_POINTS_TO_STRING(array[255, 254, 1024, 70000]) as result;
+--------+
| result |
+--------+
| ÿþЀ𑅰  |
+--------+
(1 row)

!ok

SELECT CODE_POINTS_TO_STRING(array[1+2, 3]) as result;
+--------+
| result |
+--------+
|      |
+--------+
(1 row)

!ok

SELECT CODE_POINTS_TO_STRING(null) as result;
+--------+
| result |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT CODE_POINTS_TO_STRING(array[65, null]) as result;
+--------+
| result |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT CODE_POINTS_TO_STRING('abc') as result;
Cannot apply 'CODE_POINTS_TO_STRING' to arguments of type 'CODE_POINTS_TO_STRING(<CHAR(3)>)'. Supported form(s): CODE_POINTS_TO_STRING(<INTEGER ARRAY>)
!error

SELECT CODE_POINTS_TO_STRING(array[-1]) as result;
Input arguments of CODE_POINTS_TO_STRING out of range: -1
!error

SELECT CODE_POINTS_TO_STRING(array[2147483648, 1]);
Input arguments of CODE_POINTS_TO_STRING out of range: 2147483648
!error

#####################################################################
# TO_CODE_POINTS(value)
#
# Takes a STRING or BYTES value and returns an array of INT64 values
# that represent code points or extended ASCII character values.
# 1. If value is a STRING, each element in the returned array
# represents a code point. Each code point falls within the range of
# [0, 0xD7FF] and [0xE000, 0x10FFFF].
# 2. If value is BYTES, each element in the array is an extended
# ASCII character value in the range of [0, 255].
#
SELECT TO_CODE_POINTS('ABCD') as result;
+------------------+
| result           |
+------------------+
| [65, 66, 67, 68] |
+------------------+
(1 row)

!ok

SELECT TO_CODE_POINTS(x'11223344') as result;
+------------------+
| result           |
+------------------+
| [17, 34, 51, 68] |
+------------------+
(1 row)

!ok

SELECT TO_CODE_POINTS(CODE_POINTS_TO_STRING(array[255, 254, 1024, 70000, 65])) as result;
+-----------------------------+
| result                      |
+-----------------------------+
| [255, 254, 1024, 70000, 65] |
+-----------------------------+
(1 row)

!ok

SELECT TO_CODE_POINTS(CODE_POINTS_TO_BYTES(array[64, 65, 66, 67])) as result;
+------------------+
| result           |
+------------------+
| [64, 65, 66, 67] |
+------------------+
(1 row)

!ok

SELECT TO_CODE_POINTS(null) as result;
+--------+
| result |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT TO_CODE_POINTS('') as result;
+--------+
| result |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT TO_CODE_POINTS(x'') as result;
+--------+
| result |
+--------+
|        |
+--------+
(1 row)

!ok

SELECT to_code_points(array[1, 2, 3]) as result;
Error while executing SQL "SELECT to_code_points(array[1, 2, 3]) as result": From line 1, column 8 to line 1, column 37: Cannot apply 'TO_CODE_POINTS' to arguments of type 'TO_CODE_POINTS(<INTEGER ARRAY>)'. Supported form(s): 'TO_CODE_POINTS(<STRING>)'
'TO_CODE_POINTS(<BINARY>)'
!error

#####################################################################
# DATE
#
# 0. DATE(string)
#   Shorthand for 'CAST(string AS DATE)'
# 1. DATE(year, month, day)
#   Constructs a DATE from INT64 values representing the year, month,
#   and day.
# 2. DATE(timestamp_expression[, time_zone])
#   Extracts the DATE from a TIMESTAMP expression. It supports an
#   optional parameter to specify a time zone. If no time zone is
#   specified, the default time zone, UTC, is used.
# 3. DATE(datetime_expression)
#   Extracts the DATE from a DATETIME expression.
#
# Returns DATE

# 'date(x) is shorthand for 'cast(x as date)'
select date('1970-01-01') as d;
+------------+
| d          |
+------------+
| 1970-01-01 |
+------------+
(1 row)

!ok

select date(cast(null as varchar(10))) as d;
+---+
| d |
+---+
|   |
+---+
(1 row)

!ok

SELECT
  DATE(2016, 12, 25) AS date_ymd,
  DATE(DATETIME "2016-12-25 23:59:59") AS date_dt,
  DATE(TIMESTAMP "2016-12-24 22:30:00" /* TODO should be "2016-12-25 05:30:00+07" */ , "America/Los_Angeles") AS date_tstz;
+------------+------------+------------+
| date_ymd   | date_dt    | date_tstz  |
+------------+------------+------------+
| 2016-12-25 | 2016-12-25 | 2016-12-24 |
+------------+------------+------------+
(1 row)

!ok

select date(2022, 11, 15) as d1,
       date(datetime "2008-01-01 01:03:05") as d2,
       date(datetime(2008, 1, 1, 1, 3, 5)) as d3;
+------------+------------+------------+
| d1         | d2         | d3         |
+------------+------------+------------+
| 2022-11-15 | 2008-01-01 | 2008-01-01 |
+------------+------------+------------+
(1 row)

!ok

# Test timezone conversion when converting TIMESTAMP to DATE.
# Denver observes DST whereas Phoenix does not.
# Both cities have a -07:00 offset in winter, but Denver has -06:00 in summer.
select date(timestamp("2008-06-21 06:30:00")) as sum_utc,
       date(timestamp("2008-06-21 06:30:00"), "America/Denver") as sum_dst,
       date(timestamp("2008-06-21 06:30:00"), "America/Phoenix") as sum_std,
       date(timestamp("2008-12-21 06:30:00")) as win_utc,
       date(timestamp("2008-12-21 06:30:00"), "America/Denver") as win_dst,
       date(timestamp("2008-12-21 06:30:00"), "America/Phoenix") as win_std;
+------------+------------+------------+------------+------------+------------+
| sum_utc    | sum_dst    | sum_std    | win_utc    | win_dst    | win_std    |
+------------+------------+------------+------------+------------+------------+
| 2008-06-21 | 2008-06-21 | 2008-06-20 | 2008-12-21 | 2008-12-20 | 2008-12-20 |
+------------+------------+------------+------------+------------+------------+
(1 row)

!ok

# Date-time literals.
# As for other tests in this script, data type semantics match BigQuery:
# DATETIME is what Calcite calls TIMESTAMP;
# TIMESTAMP is what Calcite calls TIMESTAMP WITH LOCAL TIME ZONE;
# DATE and TIME are the same as Calcite.
SELECT
  DATETIME "1969-07-21 02:56:00" AS dt,
  TIMESTAMP "1969-07-21 02:56:00" AS ts,
  DATE "1969-07-21" AS d,
  TIME "02:56:00" AS t;
+---------------------+---------------------+------------+----------+
| dt                  | ts                  | d          | t        |
+---------------------+---------------------+------------+----------+
| 1969-07-21 02:56:00 | 1969-07-21 02:56:00 | 1969-07-21 | 02:56:00 |
+---------------------+---------------------+------------+----------+
(1 row)

!ok

#####################################################################
# DATETIME
#
# DATETIME(year, month, day, hour, minute, second)
#   Constructs a DATETIME object using INT64 values representing the
#   year, month, day, hour, minute, and second.
# DATETIME(date_expression[, time_expression])
#   Constructs a DATETIME object using a DATE object and an optional
#   TIME object.
# DATETIME(timestamp_expression [, time_zone])
#   Constructs a DATETIME object using a TIMESTAMP object. It supports
#   an optional parameter to specify a time zone. If no time zone is
#   specified, the default time zone, UTC, is used.
#
# Returns DATETIME

SELECT
  DATETIME(2008, 12, 25, 05, 30, 00) as datetime_ymdhms,
  DATETIME(TIMESTAMP "2008-12-25 05:30:00" /* TODO should be "2008-12-25 05:30:00+00" */, "America/Los_Angeles") as datetime_tstz;
+---------------------+---------------------+
| datetime_ymdhms     | datetime_tstz       |
+---------------------+---------------------+
| 2008-12-25 05:30:00 | 2008-12-24 21:30:00 |
+---------------------+---------------------+
(1 row)

!ok

select datetime(2003, 05, 25, 12, 30, 59) as dt1,
       datetime(date(2003, 05, 25)) as d2,
       datetime(date(2003, 05, 25), time(12, 30, 59)) as d3;
+---------------------+---------------------+---------------------+
| dt1                 | d2                  | d3                  |
+---------------------+---------------------+---------------------+
| 2003-05-25 12:30:59 | 2003-05-25 00:00:00 | 2003-05-25 12:30:59 |
+---------------------+---------------------+---------------------+
(1 row)

!ok

# This tests time zone conversion from a timestamp.
select datetime(timestamp "2008-01-01 01:03:05") as t_winter,
       datetime(timestamp "2008-01-01 01:03:05", "America/Los_Angeles") as t_winter_offs,
       datetime(timestamp "2008-07-01 01:03:05", "America/Los_Angeles") as t_summer_offs;
+---------------------+---------------------+---------------------+
| t_winter            | t_winter_offs       | t_summer_offs       |
+---------------------+---------------------+---------------------+
| 2008-01-01 01:03:05 | 2007-12-31 17:03:05 | 2008-06-30 18:03:05 |
+---------------------+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# TIME
#
# 1. TIME(hour, minute, second)
#   Constructs a TIME object using INT64 values representing the hour,
#   minute, and second.
# 2. TIME(timestamp, [time_zone])
#   Constructs a TIME object using a TIMESTAMP object. It supports an
#   optional parameter to specify a time zone. If no time zone is
#   specified, the default time zone, UTC, is used.
# 3. TIME(datetime)
#   Constructs a TIME object using a DATETIME object.
#
# Returns TIME

SELECT
  TIME(15, 30, 00) as time_hms,
  TIME(TIMESTAMP "2008-12-25 07:30:00" /* TODO should be "2008-12-25 15:30:00+08" */, "America/Los_Angeles") as time_tstz;
+----------+-----------+
| time_hms | time_tstz |
+----------+-----------+
| 15:30:00 | 23:30:00  |
+----------+-----------+
(1 row)

!ok

SELECT TIME(DATETIME "2008-12-25 15:30:00.000000") AS time_dt;
+----------+
| time_dt  |
+----------+
| 15:30:00 |
+----------+
(1 row)

!ok

select time(12, 30, 59) as t1,
       time(datetime(2008, 01, 01, 12, 30, 59)) as t2,
       time(datetime(2008, 07, 01, 12, 30, 59)) as t3;
+----------+----------+----------+
| t1       | t2       | t3       |
+----------+----------+----------+
| 12:30:59 | 12:30:59 | 12:30:59 |
+----------+----------+----------+
(1 row)

!ok

# Test timezone conversion when converting TIMESTAMP to TIME.
# Denver observes DST whereas Phoenix does not.
# Both cities have a -07:00 offset in winter, but Denver has -06:00 in summer.
select time(timestamp("2008-06-21 06:30:00")) as sum_utc,
       time(timestamp("2008-06-21 06:30:00"), "America/Denver") as sum_dst,
       time(timestamp("2008-06-21 06:30:00"), "America/Phoenix") as sum_std,
       time(timestamp("2008-12-21 06:30:00")) as win_utc,
       time(timestamp("2008-12-21 06:30:00"), "America/Denver") as win_dst,
       time(timestamp("2008-12-21 06:30:00"), "America/Phoenix") as win_std;
+----------+----------+----------+----------+----------+----------+
| sum_utc  | sum_dst  | sum_std  | win_utc  | win_dst  | win_std  |
+----------+----------+----------+----------+----------+----------+
| 06:30:00 | 00:30:00 | 23:30:00 | 06:30:00 | 23:30:00 | 23:30:00 |
+----------+----------+----------+----------+----------+----------+
(1 row)

!ok

# Test timezone conversion when converting DATE to TIMESTAMP.
# Denver observes DST whereas Phoenix does not.
# Both cities have a -07:00 offset in winter, but Denver has -06:00 in summer.
select timestamp(date(2008, 6, 21)) as sum_utc,
       timestamp(date(2008, 6, 21), "America/Denver") as sum_dst,
       timestamp(date(2008, 6, 21), "America/Phoenix") as sum_std,
       timestamp(date(2008, 12, 21)) as win_utc,
       timestamp(date(2008, 12, 21), "America/Denver") as win_dst,
       timestamp(date(2008, 12, 21), "America/Phoenix") as win_std;
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
| sum_utc             | sum_dst             | sum_std             | win_utc             | win_dst             | win_std             |
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
| 2008-06-21 00:00:00 | 2008-06-21 06:00:00 | 2008-06-21 07:00:00 | 2008-12-21 00:00:00 | 2008-12-21 07:00:00 | 2008-12-21 07:00:00 |
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# TIMESTAMP
#
# TIMESTAMP(string_expression[, time_zone])
#   Converts a STRING expression
#   to a TIMESTAMP data type. string_expression must include a
#   timestamp literal. If string_expression includes a
#   time_zone in the timestamp literal, do not include an
#   explicit time_zone argument.
# TIMESTAMP(date_expression[, time_zone])
#   Converts a DATE object to a TIMESTAMP data type.
# TIMESTAMP(datetime_expression[, time_zone])
#   Converts a DATETIME object to a TIMESTAMP data type.
#
# This function supports an optional parameter to specify a time zone.
# If no time zone is specified, the default time zone, UTC, is used.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT TIMESTAMP("2008-12-25 15:30:00+00") AS timestamp_str;
+-------------------------+
| timestamp_str           |
+-------------------------+
| 2008-12-25 15:30:00 UTC |
+-------------------------+
!ok
!}

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT TIMESTAMP("2008-12-25 15:30:00", "America/Los_Angeles") AS timestamp_str;
+-------------------------+
| timestamp_str           |
+-------------------------+
| 2008-12-25 23:30:00 UTC |
+-------------------------+
!ok
!}

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT TIMESTAMP("2008-12-25 15:30:00 UTC") AS timestamp_str;
+-------------------------+
| timestamp_str           |
+-------------------------+
| 2008-12-25 15:30:00 UTC |
+-------------------------+
!ok
!}

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
#
# After [CALCITE-5446] is fixed, this and other TIMESTAMP WITH LOCAL TIME
# values will end in UTC, like this: 2008-12-25 15:30:00 UTC.
#
SELECT TIMESTAMP(DATETIME "2008-12-25 15:30:00") AS timestamp_datetime;
+---------------------+
| timestamp_datetime  |
+---------------------+
| 2008-12-25 15:30:00 |
+---------------------+
(1 row)

!ok

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
SELECT TIMESTAMP(DATE "2008-12-25") AS timestamp_date;
+---------------------+
| timestamp_date      |
+---------------------+
| 2008-12-25 00:00:00 |
+---------------------+
(1 row)

!ok

# All these timestamps should be equal.
# This tests the BQ timestamp literal string formatter
# (optional 'T', optional leading zeros, optional offset with conversion).
select timestamp("2008-01-01 01:03:05+00") as t_space,
       timestamp("2008-01-01T01:03:05+00") as t_iso,
       timestamp("2008-01-01 01:03:05") as t_no_offset,
       timestamp("2008-1-1 3:5:7+02:02:02") as t_offset;
+---------------------+---------------------+---------------------+---------------------+
| t_space             | t_iso               | t_no_offset         | t_offset            |
+---------------------+---------------------+---------------------+---------------------+
| 2008-01-01 01:03:05 | 2008-01-01 01:03:05 | 2008-01-01 01:03:05 | 2008-01-01 01:03:05 |
+---------------------+---------------------+---------------------+---------------------+
(1 row)

!ok

# Negative and positive offsets.
select timestamp("2008-01-01 01:03:05+01") as space_01,
       timestamp("2008-01-01T01:03:05+01") as iso_1,
       timestamp("2008-01-01T01:03:05+01:00") as iso_1_00,
       timestamp("2008-01-01T01:03:05-11") as iso_neg_11;
+---------------------+---------------------+---------------------+---------------------+
| space_01            | iso_1               | iso_1_00            | iso_neg_11          |
+---------------------+---------------------+---------------------+---------------------+
| 2008-01-01 00:03:05 | 2008-01-01 00:03:05 | 2008-01-01 00:03:05 | 2008-01-01 12:03:05 |
+---------------------+---------------------+---------------------+---------------------+
(1 row)

!ok

# This tests time zone conversion from a datetime.
select timestamp(datetime "2008-01-01 01:03:05") as t_winter,
       timestamp(datetime "2008-01-01 01:03:05", "America/Los_Angeles") as t_winter_offs,
       timestamp(datetime "2008-07-01 01:03:05", "America/Los_Angeles") as t_summer_offs;
+---------------------+---------------------+---------------------+
| t_winter            | t_winter_offs       | t_summer_offs       |
+---------------------+---------------------+---------------------+
| 2008-01-01 01:03:05 | 2008-01-01 09:03:05 | 2008-07-01 08:03:05 |
+---------------------+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# TIMESTAMP_SECONDS
#
# TIMESTAMP_SECONDS(int64_expression)
#
# Interprets int64_expression as the number of seconds since
# 1970-01-01 00:00:00 UTC and returns a timestamp.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.

# Note that BigQuery prints "2008-12-25 15:30:00 UTC" as the result,
# whereas Calcite's result does not include "UTC". This is because
# BigQuery's TIMESTAMP type is an instant (the equivalent of Calcite's
# TIMESTAMP WITH LOCAL TIME ZONE type). It would have been too confusing
# for a function called 'TIMESTAMP_SECONDS' to return a TIMESTAMP WITH
# LOCAL TIME ZONE, so this function returns a Calcite TIMESTAMP which,
# as a local time does not include UTC or any time zone.

SELECT TIMESTAMP_SECONDS(1230219000) AS timestamp_value;
+---------------------+
| timestamp_value     |
+---------------------+
| 2008-12-25 15:30:00 |
+---------------------+
(1 row)

!ok


#####################################################################
# TIMESTAMP_MILLIS
#
# TIMESTAMP_MILLIS(int64_expression)
#
# Interprets int64_expression as the number of milliseconds since
# 1970-01-01 00:00:00 UTC and returns a timestamp.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.

# BigQuery's result ends in "UTC" but Calcite's does not, for the reasons
# explained in TIMESTAMP_SECONDS.

SELECT TIMESTAMP_MILLIS(1230219000000) AS timestamp_value;
+---------------------+
| timestamp_value     |
+---------------------+
| 2008-12-25 15:30:00 |
+---------------------+
(1 row)

!ok


#####################################################################
# TIMESTAMP_MICROS
#
# TIMESTAMP_MICROS(int64_expression)
#
# Interprets int64_expression as the number of microseconds since
# 1970-01-01 00:00:00 UTC and returns a timestamp.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT TIMESTAMP_MICROS(1230219000000000) AS timestamp_value;
+-------------------------+
| timestamp_value         |
+-------------------------+
| 2008-12-25 15:30:00 UTC |
+-------------------------+
!ok
!}

# TIMESTAMP_SECONDS, TIMESTAMP_MILLIS, TIMESTAMP_MICROS
select v,
  timestamp_seconds(v) as t0,
  timestamp_millis(v * 1000) as t1,
  timestamp_micros(v * 1000 * 1000) as t2
from (values cast(0 as bigint),
   cast(null as bigint),
   cast(1230219000 as bigint),
   cast(-1230219000 as bigint)) as t (v)
order by v;
+-------------+---------------------+---------------------+---------------------+
| v           | t0                  | t1                  | t2                  |
+-------------+---------------------+---------------------+---------------------+
| -1230219000 | 1931-01-07 08:30:00 | 1931-01-07 08:30:00 | 1931-01-07 08:30:00 |
|           0 | 1970-01-01 00:00:00 | 1970-01-01 00:00:00 | 1970-01-01 00:00:00 |
|  1230219000 | 2008-12-25 15:30:00 | 2008-12-25 15:30:00 | 2008-12-25 15:30:00 |
|             |                     |                     |                     |
+-------------+---------------------+---------------------+---------------------+
(4 rows)

!ok

select timestamp_seconds(1234567890) as t;
+---------------------+
| t                   |
+---------------------+
| 2009-02-13 23:31:30 |
+---------------------+
(1 row)

!ok

select timestamp_millis(1234567890) as t;
+---------------------+
| t                   |
+---------------------+
| 1970-01-15 06:56:07 |
+---------------------+
(1 row)

!ok

select timestamp_micros(1234567890) as t;
+---------------------+
| t                   |
+---------------------+
| 1970-01-01 00:20:34 |
+---------------------+
(1 row)

!ok

#####################################################################
# UNIX_SECONDS
#
# UNIX_SECONDS(timestamp_expression)
#
# Returns the number of seconds since 1970-01-01 00:00:00
# UTC. Truncates higher levels of precision.

!if (false) {
SELECT UNIX_SECONDS(TIMESTAMP "2008-12-25 15:30:00+00") AS seconds;
+------------+
| seconds    |
+------------+
| 1230219000 |
+------------+
!ok
!}

#####################################################################
# UNIX_MILLIS
#
# UNIX_MILLIS(timestamp_expression)
#
# Returns the number of milliseconds since 1970-01-01 00:00:00
# UTC. Truncates higher levels of precision.

!if (false) {
SELECT UNIX_MILLIS(TIMESTAMP "2008-12-25 15:30:00+00") AS millis;
+---------------+
| millis        |
+---------------+
| 1230219000000 |
+---------------+
!ok
!}

#####################################################################
# UNIX_MICROS
#
# UNIX_MICROS(timestamp_expression)
#
# Returns the number of microseconds since 1970-01-01 00:00:00
# UTC. Truncates higher levels of precision.

!if (false) {
SELECT UNIX_MICROS(TIMESTAMP "2008-12-25 15:30:00+00") AS micros;
+------------------+
| micros           |
+------------------+
| 1230219000000000 |
+------------------+
!ok
!}

# UNIX_SECONDS, UNIX_MILLIS, UNIX_MICROS
select v,
  unix_seconds(v) as t0,
  unix_millis(v) as t1,
  unix_micros(v) as t2
from (values TIMESTAMP '1970-01-01 00:00:00',
   cast(null as timestamp),
   TIMESTAMP '2008-12-25 15:30:00',
   TIMESTAMP '1931-01-07 08:30:00') as t (v)
order by v;
+---------------------+-------------+----------------+-------------------+
| v                   | t0          | t1             | t2                |
+---------------------+-------------+----------------+-------------------+
| 1931-01-07 08:30:00 | -1230219000 | -1230219000000 | -1230219000000000 |
| 1970-01-01 00:00:00 |           0 |              0 |                 0 |
| 2008-12-25 15:30:00 |  1230219000 |  1230219000000 |  1230219000000000 |
|                     |             |                |                   |
+---------------------+-------------+----------------+-------------------+
(4 rows)

!ok

select unix_seconds(timestamp '2008-12-25 15:30:00') as t;
+------------+
| t          |
+------------+
| 1230219000 |
+------------+
(1 row)

!ok

select unix_millis(timestamp '2008-12-25 15:30:00') as t;
+---------------+
| t             |
+---------------+
| 1230219000000 |
+---------------+
(1 row)

!ok

select unix_micros(timestamp '2008-12-25 15:30:00') as t;
+------------------+
| t                |
+------------------+
| 1230219000000000 |
+------------------+
(1 row)

!ok

#####################################################################
# DATE_FROM_UNIX_DATE
select v,
  date_from_unix_date(v) as d
from (values 0,
   cast(null as integer),
   1230219000 / 86400,
   -1230219000 / 86400) as t (v)
order by v;
+--------+------------+
| v      | d          |
+--------+------------+
| -14238 | 1931-01-08 |
|      0 | 1970-01-01 |
|  14238 | 2008-12-25 |
|        |            |
+--------+------------+
(4 rows)

!ok

select date_from_unix_date(14238);
+------------+
| EXPR$0     |
+------------+
| 2008-12-25 |
+------------+
(1 row)

!ok

#####################################################################
# UNIX_DATE
select v,
  unix_date(v) as d
from (values date '1970-01-01',
   cast(null as date),
   DATE '2008-12-25',
   DATE '1931-01-07') as t (v)
order by v;
+------------+--------+
| v          | d      |
+------------+--------+
| 1931-01-07 | -14239 |
| 1970-01-01 |      0 |
| 2008-12-25 |  14238 |
|            |        |
+------------+--------+
(4 rows)

!ok

select unix_date(datetime '2008-12-25') as d;
+-------+
| d     |
+-------+
| 14238 |
+-------+
(1 row)

!ok


#####################################################################
# DATE_ADD
#
# DATE_ADD(date_expression, INTERVAL int64_expression date_part)
#
# Adds a specified time interval to a DATE.
#
# DATE_ADD supports the following date_part values:
#   DAY
#   WEEK. Equivalent to 7 DAYs.
#   MONTH
#   QUARTER
#   YEAR
#
# Special handling is required for MONTH, QUARTER, and YEAR parts when
# the date is at (or near) the last day of the month. If the resulting
# month has fewer days than the original date's day, then the
# resulting date is the last date of that month.
#
# Returns DATE

SELECT DATE_ADD(DATE "2008-12-25", INTERVAL 5 DAY) AS five_days_later;
+-----------------+
| five_days_later |
+-----------------+
| 2008-12-30      |
+-----------------+
(1 row)

!ok

#####################################################################
# DATETIME_ADD
#
# DATETIME_ADD(datetime_expression, INTERVAL int64_expression part)
#
# Adds int64_expression units of part to the DATETIME object.
#
# DATETIME_ADD supports the following values for part:
#
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#   DAY
#   WEEK. Equivalent to 7 DAYs.
#   MONTH
#   QUARTER
#   YEAR
#
# Special handling is required for MONTH, QUARTER, and YEAR parts when
# the date is at (or near) the last day of the month. If the resulting
# month has fewer days than the original DATETIME's day, then the
# result day is the last day of the new month.
#
# Returns DATETIME

SELECT
  DATETIME "2008-12-25 15:30:00" as original_date,
  DATETIME_ADD(DATETIME "2008-12-25 15:30:00", INTERVAL 10 MINUTE) as later;
+---------------------+---------------------+
| original_date       | later               |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:40:00 |
+---------------------+---------------------+
(1 row)

!ok

SELECT
  DATETIME "2008-12-25 15:30:00" as original_date,
  DATETIME_ADD(TIMESTAMP "2008-12-25 15:30:00", INTERVAL 20 MINUTE) as later;
+---------------------+---------------------+
| original_date       | later               |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:50:00 |
+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# TIME_ADD
#
# TIME_ADD(time_expression, INTERVAL int64_expression part)
#
# Adds int64_expression units of part to the TIME object.
#
# TIME_ADD supports the following values for part:
#
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#
# This function automatically adjusts when values fall outside of the
# 00:00:00 to 24:00:00 boundary. For example, if you add an hour to
# 23:30:00, the returned value is 00:30:00.
#
# Returns TIME

SELECT
  TIME "15:30:00" as original_time,
  TIME_ADD(TIME "15:30:00", INTERVAL 10 MINUTE) as later;
+---------------+----------+
| original_time | later    |
+---------------+----------+
| 15:30:00      | 15:40:00 |
+---------------+----------+
(1 row)

!ok

#####################################################################
# TIMESTAMP_ADD
#
# TIMESTAMP_ADD(timestamp_expression, INTERVAL int64_expression date_part)
#
# Adds int64_expression units of date_part to the timestamp,
# independent of any time zone.
#
# TIMESTAMP_ADD supports the following values for date_part:
#  MICROSECOND
#  MILLISECOND
#  SECOND
#  MINUTE
#  HOUR. Equivalent to 60 MINUTEs.
#  DAY. Equivalent to 24 HOURs.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
# Enable when we have TIMESTAMP() function,
# and when we allow "+00" timezone offset in timestamp values.
SELECT
  TIMESTAMP("2008-12-25 15:30:00+00") AS original,
  TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL 10 MINUTE) AS later;
+-------------------------+-------------------------+
| original                | later                   |
+-------------------------+-------------------------+
| 2008-12-25 15:30:00 UTC | 2008-12-25 15:40:00 UTC |
+-------------------------+-------------------------+
(1 row)

!ok
!}

# As previous, but uses TIMESTAMP literal rather than function,
# and "+00" timezone offsets have been removed.
SELECT
  TIMESTAMP "2008-12-25 15:30:00" AS original,
  TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00", INTERVAL 10 MINUTE) AS later;
+---------------------+---------------------+
| original            | later               |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:40:00 |
+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# LPAD(original_value, return_length, pattern)
#
# Returns a STRING or BYTES value that consists of original_value prepended
# with pattern.
#
# This function supports specifying collation.
WITH Examples AS (
  SELECT LPAD('12345', 8, 'a') as result, "8" as pad_length, "a" as p UNION ALL
  SELECT LPAD('12345', 8), "8", " " UNION ALL
  SELECT LPAD('12345', 8, 'aba'), "8", "aba" UNION ALL
  SELECT LPAD('12345', 3), "3", " " UNION ALL
  SELECT LPAD(x'aa', 4, x'bb'), "4", "x'bb'" UNION ALL
  SELECT LPAD(x'aa', 4), "4", "20" UNION ALL
  SELECT LPAD(x'aaaaaa', 2), "2", "20" UNION ALL
  SELECT LPAD(x'aaaaaa', 2, x'bb'), "2", "x'bb'"
)
SELECT
  *
FROM Examples;
+----------+------------+-------+
| result   | pad_length | p     |
+----------+------------+-------+
| aaa12345 | 8          | a     |
|    12345 | 8          |       |
| aba12345 | 8          | aba   |
| 123      | 3          |       |
| bbbbbbaa | 4          | x'bb' |
| 202020aa | 4          | 20    |
| aaaa     | 2          | 20    |
| aaaa     | 2          | x'bb' |
+----------+------------+-------+
(8 rows)

!ok

#####################################################################
# RPAD(original_value, return_length, pattern)
#
# Returns a STRING or BYTES value that consists of original_value prepended
# with pattern.
#
# This function supports specifying collation.
WITH Examples AS (
  SELECT RPAD('12345', 8, 'a') as result, "8" as pad_length, "a" as p UNION ALL
  SELECT RPAD('12345', 8), "8", " " UNION ALL
  SELECT RPAD('12345', 8, 'aba'), "8", "aba" UNION ALL
  SELECT RPAD('12345', 3), "3", " " UNION ALL
  SELECT RPAD(x'aa', 4, x'bb'), "4", "x'bb'" UNION ALL
  SELECT RPAD(x'aa', 4), "4", "20" UNION ALL
  SELECT RPAD(x'aaaaaa', 2), "2", "20" UNION ALL
  SELECT RPAD(x'aaaaaa', 2, x'bb'), "2", "x'bb'"
)
SELECT
  *
FROM Examples;
+----------+------------+-------+
| result   | pad_length | p     |
+----------+------------+-------+
| 12345aaa | 8          | a     |
| 12345    | 8          |       |
| 12345aba | 8          | aba   |
| 123      | 3          |       |
| aabbbbbb | 4          | x'bb' |
| aa202020 | 4          | 20    |
| aaaa     | 2          | 20    |
| aaaa     | 2          | x'bb' |
+----------+------------+-------+
(8 rows)

!ok

#####################################################################
# DATE_SUB
#
# DATE_SUB(date_expression, INTERVAL int64_expression date_part)
#
# Subtracts a specified time interval from a DATE.
#
# DATE_SUB supports the following date_part values:
#
#   DAY
#   WEEK. Equivalent to 7 DAYs.
#   MONTH
#   QUARTER
#   YEAR
#
# Special handling is required for MONTH, QUARTER, and YEAR parts when
# the date is at (or near) the last day of the month. If the resulting
# month has fewer days than the original date's day, then the
# resulting date is the last date of that month.
#
# Returns DATE

SELECT DATE_SUB(DATE "2008-12-25", INTERVAL 5 DAY) AS five_days_ago;
+---------------+
| five_days_ago |
+---------------+
| 2008-12-20    |
+---------------+
(1 row)

!ok

#####################################################################
# DATETIME_SUB
#
# DATETIME_SUB(datetime_expression, INTERVAL int64_expression part)
#
# Subtracts int64_expression units of part from the DATETIME.
#
# DATETIME_SUB supports the following values for part:
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#   DAY
#   WEEK. Equivalent to 7 DAYs.
#   MONTH
#   QUARTER
#   YEAR
#
# Special handling is required for MONTH, QUARTER, and YEAR parts when
# the date is at (or near) the last day of the month. If the resulting
# month has fewer days than the original DATETIME's day, then the
# result day is the last day of the new month.
#
# Returns DATETIME

SELECT
  DATETIME "2008-12-25 15:30:00" as original_date,
  DATETIME_SUB(DATETIME "2008-12-25 15:30:00", INTERVAL 10 MINUTE) as earlier;
+---------------------+---------------------+
| original_date       | earlier             |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:20:00 |
+---------------------+---------------------+
(1 row)

!ok

SELECT
  TIMESTAMP "2008-12-25 15:30:00" as original_date,
  DATETIME_SUB(TIMESTAMP "2008-12-25 15:30:00", INTERVAL 10 MINUTE) as earlier;
+---------------------+---------------------+
| original_date       | earlier             |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:20:00 |
+---------------------+---------------------+
(1 row)

!ok


#####################################################################
# TIME_SUB
#
# TIME_SUB(time_expression, INTERVAL int64_expression part)
#
# Subtracts int64_expression units of part from the TIME object.
#
# TIME_SUB supports the following values for part:
#
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#
# This function automatically adjusts when values fall outside of the
# 00:00:00 to 24:00:00 boundary. For example, if you subtract an hour
# from 00:30:00, the returned value is 23:30:00.
#
# Returns TIME

SELECT
  TIME "15:30:00" as original_date,
  TIME_SUB(TIME "15:30:00", INTERVAL 10 MINUTE) as earlier;
+---------------+----------+
| original_date | earlier  |
+---------------+----------+
| 15:30:00      | 15:20:00 |
+---------------+----------+
(1 row)

!ok

#####################################################################
# TIMESTAMP_SUB
#
# TIMESTAMP_SUB(timestamp_expression, INTERVAL int64_expression date_part)
#
# Subtracts int64_expression units of date_part from the
# timestamp, independent of any time zone.
#
# TIMESTAMP_SUB supports the following values for date_part:
#  MICROSECOND
#  MILLISECOND
#  SECOND
#  MINUTE
#  HOUR. Equivalent to 60 MINUTEs.
# DAY. Equivalent to 24 HOURs.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.

SELECT
  TIMESTAMP "2008-12-25 15:30:00" AS original,
  TIMESTAMP_SUB(TIMESTAMP "2008-12-25 15:30:00", INTERVAL 10 MINUTE) AS earlier;
+---------------------+---------------------+
| original            | earlier             |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:20:00 |
+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# DATE_DIFF
#
# DATE_DIFF(date_expression_a, date_expression_b, date_part)
#
# Returns the whole number of specified date_part intervals between
# two DATE objects (date_expression_a - date_expression_b). If the
# first DATE is earlier than the second one, the output is negative.
#
# DATE_DIFF supports the following date_part values:
#   DAY
#   WEEK This date part begins on Sunday.
#   WEEK(<WEEKDAY>): This date part begins on WEEKDAY. Valid values
#     for WEEKDAY are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
#     FRIDAY, and SATURDAY.
#   ISOWEEK: Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
#   MONTH, except when the first two arguments are TIMESTAMP objects.
#   QUARTER
#   YEAR
#   ISOYEAR: Uses the ISO 8601 week-numbering year boundary. The ISO
#     year boundary is the Monday of the first week whose Thursday
#     belongs to the corresponding Gregorian calendar year.
#
# Returns INT64

SELECT DATE_DIFF(DATE '2010-07-07', DATE '2008-12-25', DAY) AS days_diff;
+-----------+
| days_diff |
+-----------+
|       559 |
+-----------+
(1 row)

!ok

SELECT
  DATE_DIFF(DATE '2017-10-15', DATE '2017-10-14', DAY) AS days_diff,
  DATE_DIFF(DATE '2017-10-15', DATE '2017-10-14', WEEK) AS weeks_diff;
+-----------+------------+
| days_diff | weeks_diff |
+-----------+------------+
|         1 |          1 |
+-----------+------------+
(1 row)

!ok

# The example above shows the result of DATE_DIFF for two days in
# succession. DATE_DIFF with the date part WEEK returns 1 because
# DATE_DIFF counts the number of date part boundaries in this range of
# dates. Each WEEK begins on Sunday, so there is one date part
# boundary between Saturday, 2017-10-14 and Sunday, 2017-10-15.

# The following example shows the result of DATE_DIFF for two dates in
# different years. DATE_DIFF with the date part YEAR returns 3 because
# it counts the number of Gregorian calendar year boundaries between
# the two dates. DATE_DIFF with the date part ISOYEAR returns 2
# because the second date belongs to the ISO year 2015. The first
# Thursday of the 2015 calendar year was 2015-01-01, so the ISO year
# 2015 begins on the preceding Monday, 2014-12-29.

SELECT
  DATE_DIFF('2017-12-30', '2014-12-30', YEAR) AS year_diff,
  DATE_DIFF('2017-12-30', '2014-12-30', ISOYEAR) AS isoyear_diff;
+-----------+--------------+
| year_diff | isoyear_diff |
+-----------+--------------+
|         3 |            2 |
+-----------+--------------+
(1 row)

!ok

# The following example shows the result of DATE_DIFF for two days in
# succession. The first date falls on a Monday and the second date
# falls on a Sunday. DATE_DIFF with the date part WEEK returns 0
# because this date part uses weeks that begin on Sunday. DATE_DIFF
# with the date part WEEK(MONDAY) returns 1. DATE_DIFF with the date
# part ISOWEEK also returns 1 because ISO weeks begin on Monday.

SELECT
  DATE_DIFF('2017-12-18', '2017-12-17', WEEK) AS week_diff,
  DATE_DIFF('2017-12-18', '2017-12-17', WEEK(MONDAY)) AS week_weekday_diff,
  DATE_DIFF('2017-12-18', '2017-12-17', ISOWEEK) AS isoweek_diff;
+-----------+-------------------+--------------+
| week_diff | week_weekday_diff | isoweek_diff |
+-----------+-------------------+--------------+
|         0 |                 1 |            1 |
+-----------+-------------------+--------------+
(1 row)

!ok

#####################################################################
# DATETIME_DIFF
#
# DATETIME_DIFF(datetime_expression_a, datetime_expression_b, part)
#
# Returns the whole number of specified part intervals between two
# DATETIME objects (datetime_expression_a - datetime_expression_b). If
# the first DATETIME is earlier than the second one, the output is
# negative. Throws an error if the computation overflows the result
# type, such as if the difference in microseconds between the two
# DATETIME objects would overflow an INT64 value.
#
# DATETIME_DIFF supports the following values for part:
#
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#   DAY
#   WEEK: This date part begins on Sunday.
#   WEEK(<WEEKDAY>): This date part begins on WEEKDAY. Valid values
#     for WEEKDAY are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
#     FRIDAY, and SATURDAY.
#   ISOWEEK: Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
#   MONTH, except when the first two arguments are TIMESTAMP objects.
#   QUARTER
#   YEAR
#   ISOYEAR: Uses the ISO 8601 week-numbering year boundary. The ISO
#     year boundary is the Monday of the first week whose Thursday
#     belongs to the corresponding Gregorian calendar year.
#
# Returns INT64

SELECT
  DATETIME "2010-07-07 10:20:00" as first_datetime,
  DATETIME "2008-12-25 15:30:00" as second_datetime,
  DATETIME_DIFF(DATETIME "2010-07-07 10:20:00",
    DATETIME "2008-12-25 15:30:00", DAY) as difference;
+---------------------+---------------------+------------+
| first_datetime      | second_datetime     | difference |
+---------------------+---------------------+------------+
| 2010-07-07 10:20:00 | 2008-12-25 15:30:00 |        559 |
+---------------------+---------------------+------------+
(1 row)

!ok

SELECT
  DATETIME_DIFF(DATETIME '2017-10-15 00:00:00',
    DATETIME '2017-10-14 00:00:00', DAY) as days_diff,
  DATETIME_DIFF(DATETIME '2017-10-15 00:00:00',
    DATETIME '2017-10-14 00:00:00', WEEK) as weeks_diff;
+-----------+------------+
| days_diff | weeks_diff |
+-----------+------------+
|         1 |          1 |
+-----------+------------+
(1 row)

!ok

# The example above shows the result of DATETIME_DIFF for two
# DATETIMEs that are 24 hours apart. DATETIME_DIFF with the part WEEK
# returns 1 because DATETIME_DIFF counts the number of part boundaries
# in this range of DATETIMEs. Each WEEK begins on Sunday, so there is
# one part boundary between Saturday, 2017-10-14 00:00:00 and Sunday,
# 2017-10-15 00:00:00.
#
# The following example shows the result of DATETIME_DIFF for two
# dates in different years. DATETIME_DIFF with the date part YEAR
# returns 3 because it counts the number of Gregorian calendar year
# boundaries between the two DATETIMEs. DATETIME_DIFF with the date
# part ISOYEAR returns 2 because the second DATETIME belongs to the
# ISO year 2015. The first Thursday of the 2015 calendar year was
# 2015-01-01, so the ISO year 2015 begins on the preceding Monday,
# 2014-12-29.

SELECT
  DATETIME_DIFF('2017-12-30 00:00:00',
    '2014-12-30 00:00:00', YEAR) AS year_diff,
  DATETIME_DIFF('2017-12-30 00:00:00',
    '2014-12-30 00:00:00', ISOYEAR) AS isoyear_diff;
+-----------+--------------+
| year_diff | isoyear_diff |
+-----------+--------------+
|         3 |            2 |
+-----------+--------------+
(1 row)

!ok

# The following example shows the result of DATETIME_DIFF for two days
# in succession. The first date falls on a Monday and the second date
# falls on a Sunday. DATETIME_DIFF with the date part WEEK returns 0
# because this time part uses weeks that begin on
# Sunday. DATETIME_DIFF with the date part WEEK(MONDAY) returns
# 1. DATETIME_DIFF with the date part ISOWEEK also returns 1 because
# ISO weeks begin on Monday.

SELECT
  DATETIME_DIFF('2017-12-18', '2017-12-17', WEEK) AS week_diff,
  DATETIME_DIFF('2017-12-18', '2017-12-17', WEEK(MONDAY)) AS week_weekday_diff,
  DATETIME_DIFF('2017-12-18', '2017-12-17', ISOWEEK) AS isoweek_diff;
+-----------+-------------------+--------------+
| week_diff | week_weekday_diff | isoweek_diff |
+-----------+-------------------+--------------+
|         0 |                 1 |            1 |
+-----------+-------------------+--------------+
(1 row)

!ok

#####################################################################
# TIME_DIFF
#
# TIME_DIFF(time_expression_a, time_expression_b, part)
#
# Returns the whole number of specified part intervals between two
# TIME objects (time_expression_a - time_expression_b). If the first
# TIME is earlier than the second one, the output is negative. Throws
# an error if the computation overflows the result type, such as if
# the difference in microseconds between the two TIME objects would
# overflow an INT64 value.
#
# TIME_DIFF supports the following values for part:
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#
# Returns INT64

SELECT
  TIME "15:30:00" as first_time,
  TIME "14:35:00" as second_time,
  TIME_DIFF(TIME "15:30:00", TIME "14:35:00", MINUTE) as difference;
+------------+-------------+------------+
| first_time | second_time | difference |
+------------+-------------+------------+
| 15:30:00   | 14:35:00    |         55 |
+------------+-------------+------------+
(1 row)

!ok

#####################################################################
# TIMESTAMP_DIFF
#
# TIMESTAMP_DIFF(timestamp_expression_a, timestamp_expression_b, date_part)
#
# Returns the whole number of specified date_part intervals
# between two TIMESTAMP objects (timestamp_expression_a -
# timestamp_expression_b). If the first TIMESTAMP is earlier
# than the second one, the output is negative. Throws an
# error if the computation overflows the result type, such
# as if the difference in microseconds between the two
# TIMESTAMP objects would overflow an INT64 value.
#
# TIMESTAMP_DIFF supports the following values for date_part:
#  MICROSECOND
#  MILLISECOND
#  SECOND
#  MINUTE
#  HOUR. Equivalent to 60 MINUTEs.
#  DAY. Equivalent to 24 HOURs.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
SELECT
  TIMESTAMP "2010-07-07 10:20:00" AS later_timestamp,
  TIMESTAMP "2008-12-25 15:30:00" AS earlier_timestamp,
  TIMESTAMP_DIFF(TIMESTAMP "2010-07-07 10:20:00", TIMESTAMP "2008-12-25 15:30:00", HOUR) AS hours;
+---------------------+---------------------+-------+
| later_timestamp     | earlier_timestamp   | hours |
+---------------------+---------------------+-------+
| 2010-07-07 10:20:00 | 2008-12-25 15:30:00 | 13410 |
+---------------------+---------------------+-------+
(1 row)

!ok

# In the following example, the first timestamp occurs
# before the second timestamp, resulting in a negative output.
SELECT TIMESTAMP_DIFF(TIMESTAMP "2018-08-14", TIMESTAMP "2018-10-14", DAY) AS negative_diff;
+---------------+
| negative_diff |
+---------------+
|           -61 |
+---------------+
(1 row)

!ok

# In this example, the result is 0 because only the number
# of whole specified HOUR intervals are included.
SELECT TIMESTAMP_DIFF("2001-02-01 01:00:00", "2001-02-01 00:00:01", HOUR) AS negative_diff;
+---------------+
| negative_diff |
+---------------+
|             0 |
+---------------+
(1 row)

!ok

# In this example, the time unit is a 'flag' literal.
SELECT TIMESTAMP_DIFF(TIMESTAMP '2008-12-25', TIMESTAMP '2008-09-25', `quarter`) as diff;
+------+
| diff |
+------+
|    1 |
+------+
(1 row)

!ok
#####################################################################
# DATE_TRUNC
#
# DATE_TRUNC(date_expression, date_part)
#
# Truncates a DATE value to the granularity of date_part. The DATE
# value is always rounded to the beginning of date_part, which can be
# one of the following:
#   DAY: The day in the Gregorian calendar year that contains the DATE
#     value.
#   WEEK: The first day of the week in the week that contains the DATE
#     value. Weeks begin on Sundays. WEEK is equivalent to
#     WEEK(SUNDAY).
#   WEEK(WEEKDAY): The first day of the week in the week that contains
#     the DATE value. Weeks begin on WEEKDAY. WEEKDAY must be one of
#     the following: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
#     FRIDAY, or SATURDAY.
#   ISOWEEK: The first day of the ISO 8601 week in the ISO week that
#     contains the DATE value. The ISO week begins on Monday. The
#     first ISO week of each ISO year contains the first Thursday of
#     the corresponding Gregorian calendar year.
#   MONTH: The first day of the month in the month that contains the
#     DATE value.
#   QUARTER: The first day of the quarter in the quarter that contains
#     the DATE value.
#   YEAR: The first day of the year in the year that contains the DATE
#     value.
#   ISOYEAR: The first day of the ISO 8601 week-numbering year in the
#     ISO year that contains the DATE value. The ISO year is the
#     Monday of the first week whose Thursday belongs to the
#     corresponding Gregorian calendar year.
#
# Returns DATE
WITH Dates AS (
  SELECT DATE_TRUNC(DATE '2008-12-25', YEAR) as d , "year" as frame UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', ISOYEAR), "isoyear" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', QUARTER), "quarter" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', MONTH), "month" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', WEEK), "week" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', WEEK(SUNDAY)), "week(sunday)" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', WEEK(MONDAY)), "week(monday)" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', WEEK(TUESDAY)), "week(tuesday)" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', ISOWEEK), "isoweek" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', DAY), "day"
)
SELECT
  *
FROM Dates;
+------------+---------------+
| d          | frame         |
+------------+---------------+
| 2008-01-01 | year          |
| 2007-12-31 | isoyear       |
| 2008-10-01 | quarter       |
| 2008-12-01 | month         |
| 2008-12-21 | week          |
| 2008-12-21 | week(sunday)  |
| 2008-12-22 | week(monday)  |
| 2008-12-23 | week(tuesday) |
| 2008-12-22 | isoweek       |
| 2008-12-25 | day           |
+------------+---------------+
(10 rows)

!ok

# Show that the return type matches the operand type
SELECT
    DATE_TRUNC(TIMESTAMP "2008-12-25 15:30:00", MONTH) AS timestamp_result,
    DATE_TRUNC(DATETIME "2008-12-25 15:30:00", MONTH) AS datetime_result;
timestamp_result TIMESTAMP_WITH_LOCAL_TIME_ZONE NOT NULL
datetime_result TIMESTAMP NOT NULL
!type

# In the following example, the original date falls on a
# Sunday. Because the date_part is WEEK(MONDAY), DATE_TRUNC returns
# the DATE for the preceding Monday.

!if (false) {
SELECT date AS original, DATE_TRUNC(date, WEEK(MONDAY)) AS truncated
FROM (SELECT DATE('2017-11-05') AS date);
+------------+------------+
| original   | truncated  |
+------------+------------+
| 2017-11-05 | 2017-10-30 |
+------------+------------+
!ok
!}

# In the following example, the original date_expression is in the
# Gregorian calendar year 2015. However, DATE_TRUNC with the ISOYEAR
# date part truncates the date_expression to the beginning of the ISO
# year, not the Gregorian calendar year. The first Thursday of the
# 2015 calendar year was 2015-01-01, so the ISO year 2015 begins on
# the preceding Monday, 2014-12-29. Therefore the ISO year boundary
# preceding the date_expression 2015-06-15 is 2014-12-29.

!if (false) {
SELECT
  DATE_TRUNC('2015-06-15', ISOYEAR) AS isoyear_boundary,
  EXTRACT(ISOYEAR FROM DATE '2015-06-15') AS isoyear_number;
+------------------+----------------+
| isoyear_boundary | isoyear_number |
+------------------+----------------+
| 2014-12-29       | 2015           |
+------------------+----------------+
!ok
!}

#####################################################################
# DATETIME_TRUNC
#
# DATETIME_TRUNC(datetime_expression, date_time_part)
#
# Truncates a DATETIME value to the granularity of date_time_part. The
# DATETIME value is always rounded to the beginning of date_time_part,
# which can be one of the following:
#
#   MICROSECOND: If used, nothing is truncated from the value.
#   MILLISECOND: The nearest lessor or equal millisecond.
#   SECOND: The nearest lessor or equal second.
#   MINUTE: The nearest lessor or equal minute.
#   HOUR: The nearest lessor or equal hour.
#   DAY: The day in the Gregorian calendar year that contains the
#     DATETIME value.
#   WEEK: The first day of the week in the week that contains the
#     DATETIME value. Weeks begin on Sundays. WEEK is equivalent to
#     WEEK(SUNDAY).
#   WEEK(WEEKDAY): The first day of the week in the week that contains
#     the DATETIME value. Weeks begin on WEEKDAY. WEEKDAY must be one
#     of the following: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
#     FRIDAY, or SATURDAY.
#   ISOWEEK: The first day of the ISO 8601 week in the ISO week that
#     contains the DATETIME value. The ISO week begins on Monday. The
#     first ISO week of each ISO year contains the first Thursday of
#     the corresponding Gregorian calendar year.
#   MONTH: The first day of the month in the month that contains the
#     DATETIME value.
#   QUARTER: The first day of the quarter in the quarter that contains
#     the DATETIME value.
#   YEAR: The first day of the year in the year that contains the
#     DATETIME value.
#   ISOYEAR: The first day of the ISO 8601 week-numbering year in the
#     ISO year that contains the DATETIME value. The ISO year is the
#     Monday of the first week whose Thursday belongs to the
#     corresponding Gregorian calendar year.
#
# Returns DATETIME


SELECT
  DATETIME "2008-12-25 15:30:00" as original,
  DATETIME_TRUNC(DATETIME "2008-12-25 15:30:00", DAY) as truncated;
+---------------------+---------------------+
| original            | truncated           |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 00:00:00 |
+---------------------+---------------------+
(1 row)

!ok

# Show that the return type matches the operand type, unless it is a date
# in which case a TIMESTAMP is returned.
SELECT
    DATETIME_TRUNC(TIMESTAMP "2008-12-25 15:30:00", MONTH) AS timestamp_result,
    DATETIME_TRUNC(DATETIME "2008-12-25 15:30:00", MONTH) AS datetime_result;
timestamp_result TIMESTAMP_WITH_LOCAL_TIME_ZONE NOT NULL
datetime_result TIMESTAMP NOT NULL
!type


# In the following example, the original DATETIME falls on a
# Sunday. Because the part is WEEK(MONDAY), DATE_TRUNC returns the
# DATETIME for the preceding Monday.

!if (false) {
SELECT
 datetime AS original,
 DATETIME_TRUNC(datetime, WEEK(MONDAY)) AS truncated
FROM (SELECT DATETIME(TIMESTAMP "2017-11-05 00:00:00+00", "UTC") AS datetime);
+---------------------+---------------------+
| original            | truncated           |
+---------------------+---------------------+
| 2017-11-05T00:00:00 | 2017-10-30T00:00:00 |
+---------------------+---------------------+
!ok
!}

# In the following example, the original datetime_expression is in the
# Gregorian calendar year 2015. However, DATETIME_TRUNC with the
# ISOYEAR date part truncates the datetime_expression to the beginning
# of the ISO year, not the Gregorian calendar year. The first Thursday
# of the 2015 calendar year was 2015-01-01, so the ISO year 2015
# begins on the preceding Monday, 2014-12-29. Therefore the ISO year
# boundary preceding the datetime_expression 2015-06-15 00:00:00 is
# 2014-12-29.

!if (false) {
SELECT
  DATETIME_TRUNC('2015-06-15 00:00:00', ISOYEAR) AS isoyear_boundary,
  EXTRACT(ISOYEAR FROM DATETIME '2015-06-15 00:00:00') AS isoyear_number;
+---------------------+----------------+
| isoyear_boundary    | isoyear_number |
+---------------------+----------------+
| 2014-12-29T00:00:00 | 2015           |
+---------------------+----------------+
!ok
!}

#####################################################################
# TIME_TRUNC
#
# TIME_TRUNC(time_expression, time_part)
#
# Truncates a TIME value to the granularity of time_part. The TIME
# value is always rounded to the beginning of time_part, which can be
# one of the following:
#
#   MICROSECOND: If used, nothing is truncated from the value.
#   MILLISECOND: The nearest lessor or equal millisecond.
#   SECOND: The nearest lessor or equal second.
#   MINUTE: The nearest lessor or equal minute.
#   HOUR: The nearest lessor or equal hour.
#
# Returns TIME

SELECT
  TIME "15:30:00" as original,
  TIME_TRUNC(TIME "15:30:00", HOUR) as truncated;
+----------+-----------+
| original | truncated |
+----------+-----------+
| 15:30:00 | 15:00:00  |
+----------+-----------+
(1 row)

!ok

#####################################################################
# TIMESTAMP_TRUNC
#
# TIMESTAMP_TRUNC(timestamp_expression, date_time_part[, time_zone])
#
# Truncates a TIMESTAMP value to the granularity of
# date_time_part. The TIMESTAMP value is always rounded to
# the beginning of date_time_part, which can be one of the following:
#  MICROSECOND: If used, nothing is truncated from the value.
#  MILLISECOND: The nearest lessor or equal millisecond.
#  SECOND: The nearest lessor or equal second.
#  MINUTE: The nearest lessor or equal minute.
#  HOUR: The nearest lessor or equal hour.
#  DAY: The day in the Gregorian calendar year that contains the
#    TIMESTAMP value.
#  WEEK: The first day of the week in the week that contains the
#    TIMESTAMP value. Weeks begin on Sundays. WEEK is equivalent to
#    WEEK(SUNDAY).
#  WEEK(WEEKDAY): The first day of the week in the week that contains
#    the TIMESTAMP value. Weeks begin on WEEKDAY. WEEKDAY must be one
#    of the following: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
#    FRIDAY, or SATURDAY.
#  ISOWEEK: The first day of the ISO 8601 week in the ISO week that
#    contains the TIMESTAMP value. The ISO week begins on Monday.
#    The first ISO week of each ISO year contains the first Thursday
#    of the corresponding Gregorian calendar year.
#  MONTH: The first day of the month in the month that contains the
#    TIMESTAMP value.
#  QUARTER: The first day of the quarter in the quarter that contains
#    the TIMESTAMP value.
#  YEAR: The first day of the year in the year that contains the
#    TIMESTAMP value.
#  ISOYEAR: The first day of the ISO 8601 week-numbering year in the
#    ISO year that contains the TIMESTAMP value. The ISO year is the
#    Monday of the first week whose Thursday belongs to the
#    corresponding Gregorian calendar year.
#
# TIMESTAMP_TRUNC function supports an optional time_zone parameter.
# This parameter applies to the following date_time_part:
#  MINUTE
#  HOUR
#  DAY
#  WEEK
#  WEEK(<WEEKDAY>)
#  ISOWEEK
#  MONTH
#  QUARTER
#  YEAR
#  ISOYEAR
#
# Use this parameter if you want to use a time zone other than the
# default time zone, UTC, as part of the truncate operation.
#
# When truncating a TIMESTAMP to MINUTE or HOUR, TIMESTAMP_TRUNC
# determines the civil time of the TIMESTAMP in the specified (or
# default) time zone and subtracts the minutes and seconds (when
# truncating to HOUR) or the seconds (when truncating to MINUTE) from
# that TIMESTAMP. While this provides intuitive results in most cases,
# the result is non-intuitive near daylight savings transitions that
# are not hour aligned.

# Show that the return type matches the operand type, unless it is a date
# in which case a TIMESTAMP is returned.
SELECT
    TIMESTAMP_TRUNC(TIMESTAMP "2008-12-25 15:30:00", MONTH) AS timestamp_result,
    TIMESTAMP_TRUNC(DATETIME "2008-12-25 15:30:00", MONTH) AS datetime_result;
timestamp_result TIMESTAMP_WITH_LOCAL_TIME_ZONE NOT NULL
datetime_result TIMESTAMP NOT NULL
!type

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT
  TIMESTAMP_TRUNC(TIMESTAMP "2008-12-25 15:30:00+00", DAY, "UTC") AS utc,
  TIMESTAMP_TRUNC(TIMESTAMP "2008-12-25 15:30:00+00", DAY, "America/Los_Angeles") AS la;
+-------------------------+-----------------=-------+
| utc                     | la                      |
+-------------------------+-------------------------+
| 2008-12-25 00:00:00 UTC | 2008-12-25 08:00:00 UTC |
+-------------------------+-------------------------+
!ok
!}

# In the following example, timestamp_expression has a time zone
# offset of +12. The first column shows the timestamp_expression in
# UTC time. The second column shows the output of TIMESTAMP_TRUNC
# using weeks that start on Monday. Because the timestamp_expression
# falls on a Sunday in UTC, TIMESTAMP_TRUNC truncates it to the
# preceding Monday. The third column shows the same function with the
# optional Time zone definition argument 'Pacific/Auckland'. Here the
# function truncates the timestamp_expression using New Zealand
# Daylight Time, where it falls on a Monday.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT
  timestamp_value AS timestamp_value,
  TIMESTAMP_TRUNC(timestamp_value, WEEK(MONDAY), "UTC") AS utc_truncated,
  TIMESTAMP_TRUNC(timestamp_value, WEEK(MONDAY), "Pacific/Auckland") AS nzdt_truncated
FROM (SELECT TIMESTAMP("2017-11-06 00:00:00+12") AS timestamp_value);
+-------------------------+-------------------------+-------------------------+
| timestamp_value         | utc_truncated           | nzdt_truncated          |
+-------------------------+-------------------------+-------------------------+
| 2017-11-05 12:00:00 UTC | 2017-10-30 00:00:00 UTC | 2017-11-05 11:00:00 UTC |
+-------------------------+-------------------------+-------------------------+
!ok
!}

# In the following example, the original timestamp_expression is in
# the Gregorian calendar year 2015. However, TIMESTAMP_TRUNC with the
# ISOYEAR date part truncates the timestamp_expression to the
# beginning of the ISO year, not the Gregorian calendar year. The
# first Thursday of the 2015 calendar year was 2015-01-01, so the ISO
# year 2015 begins on the preceding Monday, 2014-12-29. Therefore the
# ISO year boundary preceding the timestamp_expression 2015-06-15
# 00:00:00+00 is 2014-12-29.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT
  TIMESTAMP_TRUNC("2015-06-15 00:00:00+00", ISOYEAR) AS isoyear_boundary,
  EXTRACT(ISOYEAR FROM TIMESTAMP "2015-06-15 00:00:00+00") AS isoyear_number;
+-------------------------+----------------+
| isoyear_boundary        | isoyear_number |
+-------------------------+----------------+
| 2014-12-29 00:00:00 UTC | 2015           |
+-------------------------+----------------+
!ok
!}

#####################################################################
# LAST_DAY
#
# LAST_DAY(datetime_expression[, date_part])
#
# Returns the last day from a datetime expression that contains the
# date. This is commonly used to return the last day of the month.
#
# You can optionally specify the date part for which the last day is
# returned. If this parameter is not used, the default value is
# MONTH. LAST_DAY supports the following values for date_part:
#
#   YEAR
#   QUARTER
#   MONTH
#   WEEK. Equivalent to 7 DAYs.
#   WEEK(<WEEKDAY>). <WEEKDAY> represents the starting day of the
#     week. Valid values are SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
#     THURSDAY, FRIDAY, and SATURDAY.
#   ISOWEEK. Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
#   ISOYEAR. Uses the ISO 8601 week-numbering year boundary. The ISO
#     year boundary is the Monday of the first week whose Thursday
#     belongs to the corresponding Gregorian calendar year.
#
# Returns DATE
#
# These both return the last day of the month:

!if (false) {
SELECT LAST_DAY(DATETIME '2008-11-25', MONTH) AS last_day;
+------------+
| last_day   |
+------------+
| 2008-11-30 |
+------------+
!ok
!}

!if (false) {
SELECT LAST_DAY(DATETIME '2008-11-25') AS last_day;
+------------+
| last_day   |
+------------+
| 2008-11-30 |
+------------+
!ok
!}

# This returns the last day of the year:
!if (false) {
SELECT LAST_DAY(DATETIME '2008-11-25 15:30:00', YEAR) AS last_day;
+------------+
| last_day   |
+------------+
| 2008-12-31 |
+------------+
!ok
!}

# This returns the last day of the week for a week that starts on a
# Sunday:
!if (false) {
SELECT LAST_DAY(DATETIME '2008-11-10 15:30:00', WEEK(SUNDAY)) AS last_day;
+------------+
| last_day   |
+------------+
| 2008-11-15 |
+------------+
!ok
!}

# This returns the last day of the week for a week that starts on a
# Monday:
!if (false) {
SELECT LAST_DAY(DATETIME '2008-11-10 15:30:00', WEEK(MONDAY)) AS last_day;
+------------+
| last_day   |
+------------+
| 2008-11-16 |
+------------+
!ok
!}

#####################################################################
#
# IFNULL(value1, value2)
#
# Returns value1 if not NULL, else value2
#
WITH items AS (
  SELECT 'IFNULL(null, 5)' question, IFNULL(null, 5) AS answer UNION ALL
  SELECT 'IFNULL(2, 1)', IFNULL(2, 1) UNION ALL
  SELECT "IFNULL('b', null)", IFNULL('b', null) UNION ALL
  SELECT 'IFNULL(null, null)', IFNULL(null, null)
)
SELECT * FROM items;
+--------------------+--------+
| question           | answer |
+--------------------+--------+
| IFNULL(null, 5)    | 5      |
| IFNULL(2, 1)       | 2      |
| IFNULL('b', null)  | b      |
| IFNULL(null, null) |        |
+--------------------+--------+
(4 rows)

!ok

#####################################################################
# FORMAT_DATE
#
# FORMAT_DATE(format_string, date_expr)
#
# Formats the date_expr according to the specified format_string.
#
# See Supported Format Elements For DATE for a list of format elements
# that this function supports.
#
# Returns STRING

SELECT FORMAT_DATE("%x", DATE "2008-12-25") AS US_format;
+-----------+
| US_format |
+-----------+
| 12/25/08  |
+-----------+
(1 row)

!ok

SELECT FORMAT_DATE("%b-%d-%Y", DATE "2008-12-25") AS formatted;
+-------------+
| formatted   |
+-------------+
| Dec-25-2008 |
+-------------+
(1 row)

!ok

SELECT FORMAT_DATE("%b %Y", DATE "2008-12-25") AS formatted;
+-----------+
| formatted |
+-----------+
| Dec 2008  |
+-----------+
(1 row)

!ok

#####################################################################
# FORMAT_DATETIME
#
# FORMAT_DATETIME(format_string, datetime_expression)
# Formats a DATETIME object according to the specified
# format_string. See Supported Format Elements For DATETIME for a list
# of format elements that this function supports.
#
# Returns STRING

SELECT
  FORMAT_DATETIME("%c", DATETIME "2008-12-25 15:30:00")
  AS formatted;
+--------------------------+
| formatted                |
+--------------------------+
| Thu Dec 25 15:30:00 2008 |
+--------------------------+
(1 row)

!ok

SELECT
  FORMAT_DATETIME("%b-%d-%Y", DATETIME "2008-12-25 15:30:00")
  AS formatted;
+-------------+
| formatted   |
+-------------+
| Dec-25-2008 |
+-------------+
(1 row)

!ok

SELECT
  FORMAT_DATETIME("%b %Y", DATETIME "2008-12-25 15:30:00")
  AS formatted;
+-----------+
| formatted |
+-----------+
| Dec 2008  |
+-----------+
(1 row)

!ok

#####################################################################
# FORMAT_TIME
#
# FORMAT_TIME(format_string, time_object)
#
# Formats a TIME object according to the specified format_string. See
# Supported Format Elements For TIME for a list of format elements
# that this function supports.
#
# Returns STRING

SELECT FORMAT_TIME("%R", TIME "15:30:00") as formatted_time;
+----------------+
| formatted_time |
+----------------+
| 15:30          |
+----------------+
(1 row)

!ok

#####################################################################
# FORMAT_TIMESTAMP
#
# FORMAT_TIMESTAMP(format_string, timestamp[, time_zone])
#
#
# Formats a timestamp according to the specified format_string.
#
# See Supported Format Elements For TIMESTAMP for a list of format
# elements that this function supports.

SELECT FORMAT_TIMESTAMP("%c", TIMESTAMP "2008-12-25 15:30:00" /* TODO should be "2008-12-25 15:30:00+00" */, "UTC") AS formatted;
+--------------------------+
| formatted                |
+--------------------------+
| Thu Dec 25 15:30:00 2008 |
+--------------------------+
(1 row)

!ok

SELECT FORMAT_TIMESTAMP("%b-%d-%Y", TIMESTAMP "2008-12-25 15:30:00" /* TODO should be "2008-12-25 15:30:00+00" */) AS formatted;
+-------------+
| formatted   |
+-------------+
| Dec-25-2008 |
+-------------+
(1 row)

!ok

SELECT FORMAT_TIMESTAMP("%b %Y", TIMESTAMP "2008-12-25 15:30:00" /* TODO should be "2008-12-25 15:30:00+00" */)
  AS formatted;
+-----------+
| formatted |
+-----------+
| Dec 2008  |
+-----------+
(1 row)

!ok

#####################################################################
# PARSE_DATE
#
# PARSE_DATE(format_string, date_string)
#
# Converts a string representation of date to a DATE object.
#
# format_string contains the format elements that define how
# date_string is formatted. Each element in date_string must have a
# corresponding element in format_string. The location of each element
# in format_string must match the location of each element in
# date_string.

# This works because elements on both sides match.
SELECT PARSE_DATE("%A %b %e %Y", "Thursday Dec 25 2008");
+------------+
| EXPR$0     |
+------------+
| 2008-12-25 |
+------------+
(1 row)

!ok

# This doesn't work because the year element is in different locations.
SELECT PARSE_DATE("%Y %A %b %e", "Thursday Dec 25 2008");
Invalid format: '%Y %A %b %e' for datetime string: 'Thursday Dec 25 2008'
!error

# This doesn't work because one of the year elements is missing.
SELECT PARSE_DATE("%A %b %e", "Thursday Dec 25 2008");
Invalid format: '%A %b %e' for datetime string: 'Thursday Dec 25 2008'
!error

# This works because %F can find all matching elements in date_string.
SELECT PARSE_DATE("%F", "2000-12-30");
+------------+
| EXPR$0     |
+------------+
| 2000-12-30 |
+------------+
(1 row)

!ok

# When using PARSE_DATE, keep the following in mind:
#
# Unspecified fields. Any unspecified field is initialized from
#   1970-01-01.
# Case insensitivity. Names, such as Monday, February, and so on, are
#   case insensitive.
# Whitespace. One or more consecutive white spaces in the format
#   string matches zero or more consecutive white spaces in the date
#   string. In addition, leading and trailing white spaces in the date
#   string are always allowed -- even if they are not in the format
#   string.
# Format precedence. When two (or more) format elements have
#   overlapping information (for example both %F and %Y affect the
#   year), the last one generally overrides any earlier ones.
#
# Returns DATE

# This example converts a MM/DD/YY formatted string to a DATE object:

SELECT PARSE_DATE("%x", "12/25/08") AS parsed;
+------------+
| parsed     |
+------------+
| 2008-12-25 |
+------------+
(1 row)

!ok

# This example converts a YYYYMMDD formatted string to a DATE object:

SELECT PARSE_DATE("%Y%m%d", "20081225") AS parsed;
+------------+
| parsed     |
+------------+
| 2008-12-25 |
+------------+
(1 row)

!ok

#####################################################################
# PARSE_DATETIME
#
# PARSE_DATETIME(format_string, datetime_string)
#
# Converts a string representation of a datetime to a DATETIME object.
#
# format_string contains the format elements that define how
# datetime_string is formatted. Each element in datetime_string must
# have a corresponding element in format_string. The location of each
# element in format_string must match the location of each element in
# datetime_string.

# This works because elements on both sides match.
SELECT PARSE_DATETIME("%a %b %e %I:%M:%S %Y", "Thu Dec 25 07:30:00 2008");
+---------------------+
| EXPR$0              |
+---------------------+
| 2008-12-25 07:30:00 |
+---------------------+
(1 row)

!ok


# This doesn't work because the year element is in different locations.
SELECT PARSE_DATETIME("%a %b %e %Y %I:%M:%S", "Thu Dec 25 07:30:00 2008");
Invalid format: '%a %b %e %Y %I:%M:%S' for datetime string: 'Thu Dec 25 07:30:00 2008'
!error

# This doesn't work because one of the year elements is missing.
SELECT PARSE_DATETIME("%a %b %e %I:%M:%S", "Thu Dec 25 07:30:00 2008");
Invalid format: '%a %b %e %I:%M:%S' for datetime string: 'Thu Dec 25 07:30:00 2008'
!error


# This works because %c can find all matching elements in datetime_string.
SELECT PARSE_DATETIME("%c", "Thu Dec 25 07:30:00 2008");
+---------------------+
| EXPR$0              |
+---------------------+
| 2008-12-25 07:30:00 |
+---------------------+
(1 row)

!ok

# The format string fully supports most format elements, except for %P.
#
# PARSE_DATETIME parses string according to the following rules:
#   Unspecified fields. Any unspecified field is initialized from
#     1970-01-01 00:00:00.0. For example, if the year is unspecified
#     then it defaults to 1970.
#   Case insensitivity. Names, such as Monday and February, are case
#     insensitive.
#   Whitespace. One or more consecutive white spaces in the format
#     string matches zero or more consecutive white spaces in the
#     DATETIME string. Leading and trailing white spaces in the
#     DATETIME string are always allowed, even if they are not in the
#     format string.
#   Format precedence. When two or more format elements have
#     overlapping information, the last one generally overrides any
#     earlier ones, with some exceptions. For example, both %F and %Y
#     affect the year, so the earlier element overrides the later. See
#     the descriptions of %s, %C, and %y in Supported Format Elements
#     For DATETIME.
#   Format divergence. %p can be used with am, AM, pm, and PM.
#
# Returns DATETIME

# The following examples parse a STRING literal as a DATETIME.

SELECT PARSE_DATETIME('%Y-%m-%d %H:%M:%S', '1998-10-18 13:45:55') AS dt;
+---------------------+
| dt                  |
+---------------------+
| 1998-10-18 13:45:55 |
+---------------------+
(1 row)

!ok

SELECT PARSE_DATETIME('%m/%d/%Y %I:%M:%S %p', '8/30/2018 2:23:38 pm') AS dt;
+---------------------+
| dt                  |
+---------------------+
| 2018-08-30 14:23:38 |
+---------------------+
(1 row)

!ok

# The following example parses a STRING literal containing a date in a
# natural language format as a DATETIME.

SELECT PARSE_DATETIME('%A, %B %e, %Y','Wednesday, December 19, 2018')
  AS dt;
+---------------------+
| dt                  |
+---------------------+
| 2018-12-19 00:00:00 |
+---------------------+
(1 row)

!ok

#####################################################################
# PARSE_TIME
#
# PARSE_TIME(format_string, time_string)
#
# Converts a string representation of time to a TIME object.
#
# format_string contains the format elements that define how
# time_string is formatted. Each element in time_string must have a
# corresponding element in format_string. The location of each element
# in format_string must match the location of each element in
# time_string.
#

# This works because elements on both sides match.
SELECT PARSE_TIME("%I:%M:%S", "07:30:00");
+----------+
| EXPR$0   |
+----------+
| 07:30:00 |
+----------+
(1 row)

!ok

# TODO: validate for format element ordering
!if (false) {
# This doesn't work because the seconds element is in different locations.
SELECT PARSE_TIME("%S:%I:%M", "07:30:00");
!error
!}

# This doesn't work because one of the seconds elements is missing.
SELECT PARSE_TIME("%I:%M", "07:30:00");
Invalid format: '%I:%M' for datetime string: '07:30:00'
!error


# This works because %T can find all matching elements in time_string.
SELECT PARSE_TIME("%T", "07:30:00");
+----------+
| EXPR$0   |
+----------+
| 07:30:00 |
+----------+
(1 row)

!ok


# The format string fully supports most format elements except for %P.
#
# When using PARSE_TIME, keep the following in mind:
#   Unspecified fields. Any unspecified field is initialized from
#     00:00:00.0. For instance, if seconds is unspecified then it
#     defaults to 00, and so on.
#   Whitespace. One or more consecutive white spaces in the format
#     string matches zero or more consecutive white spaces in the TIME
#     string. In addition, leading and trailing white spaces in the
#     TIME string are always allowed, even if they are not in the
#     format string.
#   Format precedence. When two (or more) format elements have
#     overlapping information, the last one generally overrides any
#     earlier ones.
#   Format divergence. %p can be used with am, AM, pm, and PM.
#
# Returns TIME

SELECT PARSE_TIME("%H", "15") as parsed_time;
+-------------+
| parsed_time |
+-------------+
| 15:00:00    |
+-------------+
(1 row)

!ok

SELECT PARSE_TIME('%I:%M:%S %p', '2:23:38 pm') AS parsed_time;
+-------------+
| parsed_time |
+-------------+
| 14:23:38    |
+-------------+
(1 row)

!ok


#####################################################################
# PARSE_TIMESTAMP
#
# PARSE_TIMESTAMP(format_string, timestamp_string[, time_zone])
#
# Converts a string representation of a timestamp to a TIMESTAMP
# object.
#
# format_string contains the format elements that define how
# timestamp_string is formatted. Each element in timestamp_string must
# have a corresponding element in format_string. The location of each
# element in format_string must match the location of each element in
# timestamp_string.

# This works because elements on both sides match.
SELECT PARSE_TIMESTAMP("%a %b %e %I:%M:%S %Y", "Thu Dec 25 07:30:00 2008");
+---------------------+
| EXPR$0              |
+---------------------+
| 2008-12-25 07:30:00 |
+---------------------+
(1 row)

!ok

# This doesn't work because the year element is in different locations.
SELECT PARSE_TIMESTAMP("%a %b %e %Y %I:%M:%S", "Thu Dec 25 07:30:00 2008");
Invalid format: '%a %b %e %Y %I:%M:%S' for datetime string: 'Thu Dec 25 07:30:00 2008'
!error

# This doesn't work because one of the year elements is missing.
SELECT PARSE_TIMESTAMP("%a %b %e %I:%M:%S", "Thu Dec 25 07:30:00 2008");
Invalid format: '%a %b %e %I:%M:%S' for datetime string: 'Thu Dec 25 07:30:00 2008'
!error

# This works because %c can find all matching elements in timestamp_string.
SELECT PARSE_TIMESTAMP("%c", "Thu Dec 25 07:30:00 2008");
+---------------------+
| EXPR$0              |
+---------------------+
| 2008-12-25 07:30:00 |
+---------------------+
(1 row)

!ok

# The format string fully supports most format elements, except for %P.
#
# When using PARSE_TIMESTAMP, keep the following in mind:
#   Unspecified fields. Any unspecified field is initialized from
#     1970-01-01 00:00:00.0. This initialization value uses the time
#     zone specified by the function's time zone argument, if
#     present. If not, the initialization value uses the default time
#     zone, UTC. For instance, if the year is unspecified then it
#     defaults to 1970, and so on.
#   Case insensitivity. Names, such as Monday, February, and so on,
#     are case insensitive.
#   Whitespace. One or more consecutive white spaces in the format
#     string matches zero or more consecutive white spaces in the
#     timestamp string. In addition, leading and trailing white spaces
#     in the timestamp string are always allowed, even if they are not
#     in the format string.
#   Format precedence. When two (or more) format elements have
#     overlapping information (for example both %F and %Y affect the
#     year), the last one generally overrides any earlier ones, with
#     some exceptions (see the descriptions of %s, %C, and %y).
#   Format divergence. %p can be used with am, AM, pm, and PM.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
#
# After [CALCITE-5446] is fixed, this and other TIMESTAMP WITH LOCAL TIME
# values will end in UTC, like this: 2008-12-25 15:30:00 UTC.
#
SELECT PARSE_TIMESTAMP("%c", "Thu Dec 25 07:30:00 2008") AS parsed;
+---------------------+
| parsed              |
+---------------------+
| 2008-12-25 07:30:00 |
+---------------------+
(1 row)

!ok

#####################################################################
# STRING and BYTES functions ########################################

#####################################################################
# ENDS_WITH(value1, value2)
#
# Takes two STRING or BYTES values. Returns TRUE if the second
# value is a suffix of the first.
#
# This function supports specifying collation.
WITH items AS (
  SELECT '1234' as item UNION ALL
  SELECT '123' UNION ALL
  SELECT '' UNION ALL
  SELECT NULL
)
SELECT
  item, ENDS_WITH(item, '34') as example
FROM items;
+------+---------+
| item | example |
+------+---------+
|      | false   |
| 123  | false   |
| 1234 | true    |
|      |         |
+------+---------+
(4 rows)

!ok

#####################################################################
# STARTS_WITH(value1, value2)
#
# Takes two STRING or BYTES values. Returns TRUE if the second
# value is a prefix of the first.
#
# This function supports specifying collation.
WITH items AS (
  SELECT 'foo' as item UNION ALL
  SELECT 'bar' UNION ALL
  SELECT 'baz' UNION ALL
  SELECT NULL
)
SELECT
  item, STARTS_WITH(item, 'b') as example
FROM items;
+------+---------+
| item | example |
+------+---------+
| bar  | true    |
| baz  | true    |
| foo  | false   |
|      |         |
+------+---------+
(4 rows)

!ok

# End big-query.iq
