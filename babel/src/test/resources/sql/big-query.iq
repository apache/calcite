# big-query.iq - Babel test for BigQuery dialect of SQL
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# In this file (due to the use of 'scott-big-query' below, and unlike typical
# Quidem tests), types are aliased to be consistent with BigQuery's type names,
# not Calcite's usual type names. # In particular:
#  * DATETIME is what Calcite calls TIMESTAMP;
#  * TIMESTAMP is what Calcite calls TIMESTAMP WITH LOCAL TIME ZONE;
#  * DATE and TIME are the same as Calcite;
#  * BYTES means VARBINARY(*);
#  * STRING means VARCHAR(*).
#
# The DATETIME() and TIMESTAMP() functions are also substituted so that they
# produce values that BigQuery would call DATETIME and TIMESTAMP.
#
!use scott-big-query
!set outputformat mysql

# TODO: create a means to set the current date/time/timestamp for the
#   current session CURRENT_TIMESTAMP etc. will return those values.
#   Then enable the CURRENT_x tests.
!if (false) {
!set timestamp '2022-06-03 12:15:48.678'
!}

# TODO: create a means to set the session timezone.
# They will affect all queries that are tagged as follows:
#   Display of results may differ, depending upon the environment and
#   time zone where this query was executed.
!if (false) {
!set timezone 'America/Pacific'
!}

# BigQuery allows CTEs called 'table' and 'date'
!if (false) {
with table as (select 1 as x)
select *
from table;
!ok

with date as (select 1 as x)
select *
from date;
!ok
!}


#####################################################################
# DATE, DATETIME, TIME and TIMESTAMP functions ######################

#####################################################################
# CURRENT_DATE
#
# CURRENT_DATE([time_zone])
#
# Returns the current date as of the specified or default time
# zone. Parentheses are optional when called with no arguments.
#
# This function supports an optional time_zone parameter. This
# parameter is a string representing the time zone to use. If no time
# zone is specified, the default time zone, UTC, is used. See Time
# zone definitions for information on how to specify a time zone.
#
# If the time_zone parameter evaluates to NULL, this function returns NULL.
#
# Returns DATE

!if (false) {
SELECT CURRENT_DATE() AS the_date;
+--------------+
| the_date     |
+--------------+
| 2016-12-25   |
+--------------+
!ok
!}

!if (false) {
SELECT CURRENT_DATE AS the_date;
+--------------+
| the_date     |
+--------------+
| 2016-12-25   |
+--------------+
!ok
!}

!if (false) {
SELECT CURRENT_DATE("Europe/Moscow") AS the_date;
+--------------+
| the_date     |
+--------------+
| 2016-12-26   |
+--------------+
!ok

SELECT CURRENT_DATE(null) AS the_date;
+----------+
| the_date |
+----------+
|          |
+----------+
!ok
!}

# When a column named current_date is present, the column name and the
# function call without parentheses are ambiguous. To ensure the
# function call, add parentheses; to ensure the column name, qualify
# it with its range variable. For example, the following query will
# select the function in the the_date column and the table column in
# the current_date column.

!if (false) {
WITH t AS (SELECT 'column value' AS `current_date`)
SELECT current_date() AS the_date, t.current_date FROM t;
+------------+--------------+
| the_date   | current_date |
+------------+--------------+
| 2016-12-25 | column value |
+------------+--------------+
!ok
!}

#####################################################################
# CURRENT_DATETIME
#
# CURRENT_DATETIME([time_zone])
#
# Returns the current time as a DATETIME object. Parentheses are
# optional when called with no arguments.
#
# This function supports an optional time_zone parameter. See Time
# zone definitions for information on how to specify a time zone.
#
# Returns DATETIME

!if (false) {
SELECT CURRENT_DATETIME() as now;
+----------------------------+
| now                        |
+----------------------------+
| 2016-05-19T10:38:47.046465 |
+----------------------------+
!ok

SELECT CURRENT_DATETIME as now;
+----------------------------+
| now                        |
+----------------------------+
| 2016-05-19T10:38:47.046465 |
+----------------------------+
!ok
!}

# When a column named current_datetime is present, the column name and
# the function call without parentheses are ambiguous. To ensure the
# function call, add parentheses; to ensure the column name, qualify
# it with its range variable. For example, the following query will
# select the function in the now column and the table column in the
# current_datetime column.

!if (false) {
WITH t AS (SELECT 'column value' AS `current_datetime`)
SELECT current_datetime() as now, t.current_datetime FROM t;
+----------------------------+------------------+
| now                        | current_datetime |
+----------------------------+------------------+
| 2016-05-19T10:38:47.046465 | column value     |
+----------------------------+------------------+
!ok
!}

#####################################################################
# CURRENT_TIME
#
# CURRENT_TIME([time_zone])
#
#
# Returns the current time as a TIME object. Parentheses are optional
# when called with no arguments.
#
# This function supports an optional time_zone parameter. See Time
# zone definitions for information on how to specify a time zone.
#
# Returns TIME

!if (false) {
SELECT CURRENT_TIME() as now;

+----------------------------+
| now                        |
+----------------------------+
| 15:31:38.776361            |
+----------------------------+
!ok
!}

# When a column named current_time is present, the column name and the
# function call without parentheses are ambiguous. To ensure the
# function call, add parentheses; to ensure the column name, qualify
# it with its range variable. For example, the following query will
# select the function in the now column and the table column in the
# current_time column.

!if (false) {
WITH t AS (SELECT 'column value' AS `current_time`)
SELECT current_time() as now, t.current_time FROM t;

+-----------------+--------------+
| now             | current_time |
+-----------------+--------------+
| 15:31:38.776361 | column value |
+-----------------+--------------+
!ok
!}

#####################################################################
# CURRENT_TIMESTAMP
# Parentheses are optional
!if (false) {
select current_timestamp() as now;
+---------------------+
| now                 |
+---------------------+
| 2022-06-02 17:58:58 |
+---------------------+
(1 row)

!ok
!}

!if (false) {
select current_timestamp as now;
+---------------------+
| now                 |
+---------------------+
| 2022-06-02 17:58:58 |
+---------------------+
(1 row)

!ok
!}

# When a column named current_timestamp is present, the column name
# and the function call without parentheses are ambiguous. To ensure
# the function call, add parentheses; to ensure the column name,
# qualify it with its range variable. For example, the following query
# will select the function in the now column and the table column in
# the current_timestamp column.
!if (false) {
WITH t AS (SELECT 'column value' AS `current_timestamp`)
SELECT current_timestamp() AS now, t.current_timestamp FROM t;
+--------------------------------+-------------------+
| now                            | current_timestamp |
+--------------------------------+-------------------+
| 2020-06-02 23:57:12.120174 UTC | column value      |
+--------------------------------+-------------------+
!ok
!}

#####################################################################
# EXTRACT
#
# EXTRACT(part FROM date_expression)
#   Returns the value corresponding to the specified date part
# EXTRACT(part FROM datetime_expression)
#   Returns a value that corresponds to the specified part from a
#   supplied datetime_expression.
# EXTRACT(part FROM time_expression)
#   Returns a value that corresponds to the specified part from a
#   supplied time_expression.
# EXTRACT(part FROM timestamp_expression [AT TIME ZONE time_zone])
#
# For date, the part must be one of:
#
#   DAYOFWEEK: Returns values in the range [1,7] with Sunday as the
#     first day of the week.
#   DAY
#   DAYOFYEAR
#   WEEK: Returns the week number of the date in the range [0,
#     53]. Weeks begin with Sunday, and dates prior to the first
#     Sunday of the year are in week 0.
#   WEEK(<WEEKDAY>): Returns the week number of the date in the range
#     [0, 53]. Weeks begin on WEEKDAY. Dates prior to the first
#     WEEKDAY of the year are in week 0. Valid values for WEEKDAY are
#     SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and
#     SATURDAY.
#   ISOWEEK: Returns the ISO 8601 week number of the
#     date_expression. ISOWEEKs begin on Monday. Return values are in
#     the range [1, 53]. The first ISOWEEK of each ISO year begins on
#     the Monday before the first Thursday of the Gregorian calendar
#     year.
#   MONTH
#   QUARTER: Returns values in the range [1,4].
#   YEAR
#   ISOYEAR: Returns the ISO 8601 week-numbering year, which is the
#     Gregorian calendar year containing the Thursday of the week to
#     which date_expression belongs.
#
# For time, allowed part values are:
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#
# For timestamp and datetime, allowed part values are:
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#   DAYOFWEEK: Returns values in the range [1,7] with Sunday as the
#     first day of of the week.
#   DAY
#   DAYOFYEAR
#   WEEK: Returns the week number of the date in the range [0,
#     53]. Weeks begin with Sunday, and dates prior to the first Sunday of
#     the year are in week 0.
#   WEEK(<WEEKDAY>): Returns the week number of datetime_expression in
#     the range [0, 53]. Weeks begin on WEEKDAY. datetimes prior to the
#     first WEEKDAY of the year are in week 0. Valid values for WEEKDAY
#     are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and
#     SATURDAY.
#   ISOWEEK: Returns the ISO 8601 week number of the
#     datetime_expression. ISOWEEKs begin on Monday. Return values are
#     in the range [1, 53]. The first ISOWEEK of each ISO year begins
#     on the Monday before the first Thursday of the Gregorian
#     calendar year.
#   MONTH
#   QUARTER
#   YEAR
#   ISOYEAR: Returns the ISO 8601 week-numbering year, which is the
#     Gregorian calendar year containing the Thursday of the week to
#     which date_expression belongs.
#   DATE
#   TIME
#
# Returned values truncate lower order time periods. For example, when
# extracting seconds, EXTRACT truncates the millisecond and
# microsecond values.
#
# Returns INT64, except in the following cases:
#   If part is DATE, returns a DATE object.
#   If part is TIME, returns a TIME object.

# In the following example, EXTRACT returns a value corresponding to
# the DAY date part.

SELECT EXTRACT(DAY FROM DATE '2013-12-25') AS the_day;
+---------+
| the_day |
+---------+
|      25 |
+---------+
(1 row)

!ok

SELECT
  EXTRACT(DAYOFWEEK FROM DATE '2008-12-25') as day_of_week,
  EXTRACT(DOW FROM DATE '2008-12-25') as dow;
+-------------+-----+
| day_of_week | dow |
+-------------+-----+
|           5 |   5 |
+-------------+-----+
(1 row)

!ok

SELECT
  EXTRACT(DAYOFYEAR FROM DATE '2008-12-25') as day_of_year,
  EXTRACT(DOY FROM DATE '2008-12-25') as doy;
+-------------+-----+
| day_of_year | doy |
+-------------+-----+
|         360 | 360 |
+-------------+-----+
(1 row)

!ok

# In the following example, EXTRACT returns values corresponding to
# different date parts from a column of dates near the end of the
# year.

!if (false) {
SELECT
  d,
  EXTRACT(ISOYEAR FROM d) AS isoyear,
  EXTRACT(ISOWEEK FROM d) AS isoweek,
  EXTRACT(YEAR FROM d) AS year,
  EXTRACT(WEEK FROM d) AS week
FROM UNNEST(
  ARRAY [DATE '2015-12-23',
         DATE '2015-12-24',
         DATE '2015-12-25',
         DATE '2015-12-26',
         DATE '2015-12-27',
         DATE '2015-12-28',
         DATE '2015-12-29',
         DATE '2015-12-30',
         DATE '2015-12-31',
         DATE '2016-01-01',
         DATE '2016-01-02',
         DATE '2016-01-03',
         DATE '2016-01-04',
         DATE '2016-01-05',
         DATE '2016-01-06',
         DATE '2016-01-07',
         DATE '2016-01-08',
         DATE '2016-01-09']) AS d
ORDER BY d;
+------------+---------+---------+------+------+
| date       | isoyear | isoweek | year | week |
+------------+---------+---------+------+------+
| 2015-12-23 | 2015    | 52      | 2015 | 51   |
| 2015-12-24 | 2015    | 52      | 2015 | 51   |
| 2015-12-25 | 2015    | 52      | 2015 | 51   |
| 2015-12-26 | 2015    | 52      | 2015 | 51   |
| 2015-12-27 | 2015    | 52      | 2015 | 52   |
| 2015-12-28 | 2015    | 53      | 2015 | 52   |
| 2015-12-29 | 2015    | 53      | 2015 | 52   |
| 2015-12-30 | 2015    | 53      | 2015 | 52   |
| 2015-12-31 | 2015    | 53      | 2015 | 52   |
| 2016-01-01 | 2015    | 53      | 2016 | 0    |
| 2016-01-02 | 2015    | 53      | 2016 | 0    |
| 2016-01-03 | 2015    | 53      | 2016 | 1    |
| 2016-01-04 | 2016    | 1       | 2016 | 1    |
| 2016-01-05 | 2016    | 1       | 2016 | 1    |
| 2016-01-06 | 2016    | 1       | 2016 | 1    |
| 2016-01-07 | 2016    | 1       | 2016 | 1    |
| 2016-01-08 | 2016    | 1       | 2016 | 1    |
| 2016-01-09 | 2016    | 1       | 2016 | 1    |
+------------+---------+---------+------+------+
!ok
!}

# In the following example, date_expression falls on a Sunday. EXTRACT
# calculates the first column using weeks that begin on Sunday, and it
# calculates the second column using weeks that begin on Monday.

!if (false) {
WITH t AS (SELECT DATE('2017-11-05') AS d)
SELECT
  d,
  EXTRACT(WEEK(SUNDAY) FROM d) AS week_sunday,
  EXTRACT(WEEK(MONDAY) FROM d) AS week_monday FROM t;
+------------+-------------+-------------+
| date       | week_sunday | week_monday |
+------------+-------------+-------------+
| 2017-11-05 | 45          | 44          |
+------------+-------------+-------------+
!ok
!}

# In the following example, EXTRACT returns a value corresponding to
# the HOUR time part.
!if (false) {
SELECT EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00)) as hour;
+------------------+
| hour             |
+------------------+
| 15               |
+------------------+
!ok
!}

# In the following example, EXTRACT returns values corresponding to
# different time parts from a column of datetimes.
!if (false) {
WITH Datetimes AS (
  SELECT DATETIME '2005-01-03 12:34:56' AS dt UNION ALL
  SELECT DATETIME '2007-12-31' UNION ALL
  SELECT DATETIME '2009-01-01' UNION ALL
  SELECT DATETIME '2009-12-31' UNION ALL
  SELECT DATETIME '2017-01-02' UNION ALL
  SELECT DATETIME '2017-05-26'
)
SELECT
  datetime,
  EXTRACT(ISOYEAR FROM dt) AS isoyear,
  EXTRACT(ISOWEEK FROM dt) AS isoweek,
  EXTRACT(YEAR FROM dt) AS year,
  EXTRACT(WEEK FROM dt) AS week
FROM Datetimes
ORDER BY dt;
+---------------------+---------+---------+------+------+
| dt                  | isoyear | isoweek | year | week |
+---------------------+---------+---------+------+------+
| 2005-01-03T12:34:56 | 2005    | 1       | 2005 | 1    |
| 2007-12-31T00:00:00 | 2008    | 1       | 2007 | 52   |
| 2009-01-01T00:00:00 | 2009    | 1       | 2009 | 0    |
| 2009-12-31T00:00:00 | 2009    | 53      | 2009 | 52   |
| 2017-01-02T00:00:00 | 2017    | 1       | 2017 | 1    |
| 2017-05-26T00:00:00 | 2017    | 21      | 2017 | 21   |
+---------------------+---------+---------+------+------+
!ok
!}

# In the following example, datetime_expression falls on a
# Sunday. EXTRACT calculates the first column using weeks that begin
# on Sunday, and it calculates the second column using weeks that
# begin on Monday.
!if (false) {
WITH t AS (SELECT DATETIME(TIMESTAMP "2017-11-05 00:00:00+00", "UTC") AS dt)
SELECT
  dt,
  EXTRACT(WEEK(SUNDAY) FROM dt) AS week_sunday,
  EXTRACT(WEEK(MONDAY) FROM dt) AS week_monday
FROM t;
+---------------------+-------------+---------------+
| dt                  | week_sunday | week_monday   |
+---------------------+-------------+---------------+
| 2017-11-05T00:00:00 | 45          | 44            |
+---------------------+-------------+---------------+
!ok
!}

!if (false) {
WITH Input AS (SELECT TIMESTAMP("2008-12-25 05:30:00+00") AS timestamp_value)
SELECT
  EXTRACT(DAY FROM timestamp_value AT TIME ZONE "UTC") AS the_day_utc,
  EXTRACT(DAY FROM timestamp_value AT TIME ZONE "America/Los_Angeles") AS the_day_california
FROM Input;
+-------------+--------------------+
| the_day_utc | the_day_california |
+-------------+--------------------+
| 25          | 24                 |
+-------------+--------------------+
!ok
!}

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
WITH Timestamps AS (
  SELECT TIMESTAMP("2005-01-03 12:34:56+00") AS timestamp_value UNION ALL
  SELECT TIMESTAMP("2007-12-31 12:00:00+00") UNION ALL
  SELECT TIMESTAMP("2009-01-01 12:00:00+00") UNION ALL
  SELECT TIMESTAMP("2009-12-31 12:00:00+00") UNION ALL
  SELECT TIMESTAMP("2017-01-02 12:00:00+00") UNION ALL
  SELECT TIMESTAMP("2017-05-26 12:00:00+00")
)
SELECT
  timestamp_value,
  EXTRACT(ISOYEAR FROM timestamp_value) AS isoyear,
  EXTRACT(ISOWEEK FROM timestamp_value) AS isoweek,
  EXTRACT(YEAR FROM timestamp_value) AS year,
  EXTRACT(WEEK FROM timestamp_value) AS week
FROM Timestamps
ORDER BY timestamp_value;
+-------------------------+---------+---------+------+------+
| timestamp_value         | isoyear | isoweek | year | week |
+-------------------------+---------+---------+------+------+
| 2005-01-03 12:34:56 UTC | 2005    | 1       | 2005 | 1    |
| 2007-12-31 12:00:00 UTC | 2008    | 1       | 2007 | 52   |
| 2009-01-01 12:00:00 UTC | 2009    | 1       | 2009 | 0    |
| 2009-12-31 12:00:00 UTC | 2009    | 53      | 2009 | 52   |
| 2017-01-02 12:00:00 UTC | 2017    | 1       | 2017 | 1    |
| 2017-05-26 12:00:00 UTC | 2017    | 21      | 2017 | 21   |
+-------------------------+---------+---------+------+------+
!ok
!}

# In the following example, timestamp_expression falls on a Monday.
# EXTRACT calculates the first column using weeks that begin on
# Sunday, and it calculates the second column using weeks that begin
# on Monday.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
WITH t AS (SELECT TIMESTAMP("2017-11-05 00:00:00+00") AS timestamp_value)
SELECT
  timestamp_value,
  EXTRACT(WEEK(SUNDAY) FROM timestamp_value) AS week_sunday,
  EXTRACT(WEEK(MONDAY) FROM timestamp_value) AS week_monday
FROM t;
+-------------------------+-------------+---------------+
| timestamp_value         | week_sunday | week_monday   |
+-------------------------+-------------+---------------+
| 2017-11-05 00:00:00 UTC | 45          | 44            |
+-------------------------+-------------+---------------+
!ok
!}

#####################################################################
# NOT EQUAL Operator (value1 != value2)
#
# Compares value1 and value2 and returns TRUE if not equal.
SELECT (5 != 3) as result;
+--------+
| result |
+--------+
| true   |
+--------+
(1 row)

!ok

SELECT (5 != 5) as result;
+--------+
| result |
+--------+
| false  |
+--------+
(1 row)

!ok

#####################################################################
# MODULO % OPERATOR (value1 % value2)
#
# Returns the remainder of dividing value1 by value2.
SELECT (5 % 3) as result;
+--------+
| result |
+--------+
|      2 |
+--------+
(1 row)

!ok

SELECT (19 % 19) as result;
+--------+
| result |
+--------+
|      0 |
+--------+
(1 row)

!ok

#####################################################################
# SPLIT
#
# SPLIT(string [, delimiter])
#
# Splits string using the delimiter argument. For STRING, the default
# delimiter is the comma.
#
# Returns a STRING array as result.
WITH letters AS
  (SELECT '' as letter_group
  UNION ALL
  SELECT 'a' as letter_group
  UNION ALL
  SELECT 'b c d' as letter_group)
SELECT SPLIT(letter_group, ' ') as example
FROM letters;
+-----------+
| example   |
+-----------+
| []        |
| [a]       |
| [b, c, d] |
+-----------+
(3 rows)

!ok

SELECT SPLIT("h,e,l,l,o") as result;
+-----------------+
| result          |
+-----------------+
| [h, e, l, l, o] |
+-----------------+
(1 row)

!ok

SELECT SPLIT("") as result;
+--------+
| result |
+--------+
| []     |
+--------+
(1 row)

!ok

# Careful to treat the delimiter as a string, not a regular expression
SELECT SPLIT("abc.de.", ".") as result;
+-------------+
| result      |
+-------------+
| [abc, de, ] |
+-------------+
(1 row)

!ok

WITH letters AS
  (SELECT x'' as letter_group
  UNION ALL
  SELECT x'41' as letter_group
  UNION ALL
  SELECT x'42ff43ff44' as letter_group)
SELECT SPLIT(letter_group, x'ff') as example
FROM letters;
+-----------+
| example   |
+-----------+
| []        |
| [A]       |
| [B, C, D] |
+-----------+
(3 rows)

!ok

SELECT SPLIT(x'abc2') as result;
Call to function 'SPLIT' with argument of type 'BINARY(2)' requires extra delimiter argument
!error

#####################################################################
# ARRAY SUBSCRIPT OPERATORS
#
# OFFSET, ORDINAL, SAFE_OFFSET, SAFE_ORDINAL
#
# Gets a value from an array at a specific position.
#
# OFFSET(index): The index starts at zero. Produces an error if the index is out of range.
# SAFE_OFFSET(index): The index starts at zero. Returns NULL if the index is out of range.
# ORDINAL(index): The index starts at one. Produces an error if the index is out of range.
# SAFE_ORDINAL(index): The index starts at one. Returns NULL if the index is out of range.

SELECT
    SPLIT('h,e,l,l,o')[OFFSET(2)] as offset_idx,
    SPLIT('h,e,l,l,o')[ORDINAL(2)] as ordinal_idx,
    SPLIT('h,e,l,l,o')[SAFE_OFFSET(2)] as safe_offset_idx,
    SPLIT('h,e,l,l,o')[SAFE_ORDINAL(2)] as safe_ordinal_idx;
+------------+-------------+-----------------+------------------+
| offset_idx | ordinal_idx | safe_offset_idx | safe_ordinal_idx |
+------------+-------------+-----------------+------------------+
| l          | e           | l               | e                |
+------------+-------------+-----------------+------------------+
(1 row)

!ok

SELECT SPLIT('h,e,l,l,o')[OFFSET(-1)] as offset_idx;
Array index -1 is out of bounds
!error

SELECT SPLIT('h,e,l,l,o')[ORDINAL(7)] as ordinal_idx;
Array index 7 is out of bounds
!error

SELECT SPLIT('h,e,l,l,o')[SAFE_OFFSET(-1)] as safe_offset_idx;
+-----------------+
| safe_offset_idx |
+-----------------+
|                 |
+-----------------+
(1 row)

!ok

SELECT SPLIT('h,e,l,l,o')[SAFE_ORDINAL(7)] as safe_ordinal_idx;
+------------------+
| safe_ordinal_idx |
+------------------+
|                  |
+------------------+
(1 row)

!ok

SELECT OFFSET(1);
java.sql.SQLException: Error while executing SQL "SELECT OFFSET(1)": parse failed: Incorrect syntax near the keyword 'OFFSET' at line 1, column 8.
!error
#####################################################################
# LN
#
# LN(x)
#
# Computes the natural logarithm of x. Generates an error if x is less than or
# equal to zero.

SELECT LN(100) as result;
+-------------------+
| result            |
+-------------------+
| 4.605170185988092 |
+-------------------+
(1 row)

!ok

#####################################################################
# LOG
#
# LOG(x, y)
#
# If only x is present, LOG is a synonym of LN. If y is also
# present, LOG computes the logarithm of x to base y.
SELECT LOG(64, 8) as result;
+--------+
| result |
+--------+
|    2.0 |
+--------+
(1 row)

!ok

SELECT LOG(100) as result;
+-------------------+
| result            |
+-------------------+
| 4.605170185988092 |
+-------------------+
(1 row)

!ok

#####################################################################
# LOG10
#
# LOG10(x)
#
# Similar to LOG, but computes logarithm to base 10.

SELECT LOG10(100) as result;
+--------+
| result |
+--------+
|    2.0 |
+--------+
(1 row)

!ok

#####################################################################
# STRING
#
# STRING(timestamp_expression[, time_zone])
#
# Converts a timestamp_expression to a STRING data type.
# Supports an optional parameter to specify a time zone.

!if (false) {
SELECT STRING(TIMESTAMP "2008-12-25 15:30:00+00", "UTC") AS string;
+-------------------------------+
| string                        |
+-------------------------------+
| 2008-12-25 15:30:00+00        |
+-------------------------------+
!ok
!}

#####################################################################
# LENGTH(string)
#
# Returns the number of characters in the provided string.
SELECT LENGTH("hello") as length;
+--------+
| length |
+--------+
|      5 |
+--------+
(1 row)

!ok

#####################################################################
# SAFE_CAST(x AS type)
#
# Identical to CAST(), except it returns NULL instead of raising an error.

WITH Casted AS (
  SELECT SAFE_CAST("a" as int) as casted, "a" as input, "int" as as UNION ALL
  SELECT SAFE_CAST("a" as varchar(1)), "a", "varchar(1)" UNION ALL
  SELECT SAFE_CAST("2023-03-07" as DATE), DATE("2023-03-07"), "date" UNION ALL
  SELECT SAFE_CAST("2023-03-07a" as DATE), "2023-03-07a", "date" UNION ALL
  SELECT SAFE_CAST(0 as BOOLEAN), 0, "boolean"
)
SELECT
  *
FROM Casted;
+------------+-------------+------------+
| casted     | input       | as         |
+------------+-------------+------------+
|            | a           | int        |
| a          | a           | varchar(1) |
| 2023-03-07 | 2023-03-07  | date       |
|            | 2023-03-07a | date       |
| FALSE      | 0           | boolean    |
+------------+-------------+------------+
(5 rows)

!ok

WITH Casted AS (
  SELECT SAFE_CAST("12:12:11" as TIME) as casted,
   "12:12:11" as input, "time" as as UNION ALL
  SELECT SAFE_CAST("12:12:11a" as TIME), "12:12:11a", "time"
)
SELECT
  *
FROM Casted;
+----------+-----------+------+
| casted   | input     | as   |
+----------+-----------+------+
| 12:12:11 | 12:12:11  | time |
|          | 12:12:11a | time |
+----------+-----------+------+
(2 rows)

!ok

WITH Casted AS (
  SELECT SAFE_CAST(TRUE as BOOLEAN) as casted, "true" as input,
   "boolean" as as UNION ALL
  SELECT SAFE_CAST(FALSE as BOOLEAN) as casted, "false" as input,
   "boolean" as as
)
SELECT
  *
FROM Casted;
+--------+-------+---------+
| casted | input | as      |
+--------+-------+---------+
| true   | true  | boolean |
| false  | false | boolean |
+--------+-------+---------+
(2 rows)

!ok

WITH Casted AS (
  SELECT SAFE_CAST(interval '12' month as interval year) as casted,
   "interval 1 month" as input,
   "interval year" as as UNION ALL
   SELECT SAFE_CAST("a" as interval year), "a",
     "interval year" UNION ALL
   SELECT SAFE_CAST(null as interval year), "null", "interval year"
)
SELECT
  *
FROM Casted;
+--------+------------------+---------------+
| casted | input            | as            |
+--------+------------------+---------------+
| +1     | interval 1 month | interval year |
|        | a                | interval year |
|        | null             | interval year |
+--------+------------------+---------------+
(3 rows)

!ok

WITH Casted AS (
  SELECT SAFE_CAST(interval '1:1' hour to minute as interval minute to second)
   as casted, "interval 1:1 hour to minute" as input,
    "interval minute to second" as as UNION ALL
  SELECT SAFE_CAST("a" as interval minute to second),
   "a", "interval minute to second"
)
SELECT
  *
FROM Casted;
+---------------+-----------------------------+---------------------------+
| casted        | input                       | as                        |
+---------------+-----------------------------+---------------------------+
| +61:00.000000 | interval 1:1 hour to minute | interval minute to second |
|               | a                           | interval minute to second |
+---------------+-----------------------------+---------------------------+
(2 rows)

!ok

WITH Casted AS (
  SELECT SAFE_CAST('true' as BIGINT) as casted, "true" as input,
    "bigint" as as UNION ALL
  SELECT SAFE_CAST(1.0 as BIGINT), "1.0", "bigint" UNION ALL
  SELECT SAFE_CAST(1 as BIGINT), "1", "bigint" UNION ALL
  SELECT SAFE_CAST(SAFE_CAST(TRUE AS BOOLEAN) AS BIGINT),
       "TRUE", "bigint"
)
SELECT
  *
FROM Casted;
+--------+-------+--------+
| casted | input | as     |
+--------+-------+--------+
|        | true  | bigint |
|      1 | 1.0   | bigint |
|      1 | 1     | bigint |
|      1 | TRUE  | bigint |
+--------+-------+--------+
(4 rows)

!ok

#####################################################################
# STRPOS(string, substring)
#
# Returns the 1-based position of the first occurrence of substring
# within string. Returns 0 if not found.
SELECT STRPOS("abc", "a") as result;
+--------+
| result |
+--------+
|      1 |
+--------+
(1 row)

!ok

SELECT STRPOS("abc", "d") as result;
+--------+
| result |
+--------+
|      0 |
+--------+
(1 row)

!ok

SELECT STRPOS("abcabc", "bc") as result;
+--------+
| result |
+--------+
|      2 |
+--------+
(1 row)

!ok

#####################################################################
# DATE
#
# 0. DATE(string)
#   Shorthand for 'CAST(string AS DATE)'
# 1. DATE(year, month, day)
#   Constructs a DATE from INT64 values representing the year, month,
#   and day.
# 2. DATE(timestamp_expression[, time_zone])
#   Extracts the DATE from a TIMESTAMP expression. It supports an
#   optional parameter to specify a time zone. If no time zone is
#   specified, the default time zone, UTC, is used.
# 3. DATE(datetime_expression)
#   Extracts the DATE from a DATETIME expression.
#
# Returns DATE

# 'date(x) is shorthand for 'cast(x as date)'
select date('1970-01-01') as d;
+------------+
| d          |
+------------+
| 1970-01-01 |
+------------+
(1 row)

!ok

select date(cast(null as varchar(10))) as d;
+---+
| d |
+---+
|   |
+---+
(1 row)

!ok

SELECT
  DATE(2016, 12, 25) AS date_ymd,
  DATE(DATETIME "2016-12-25 23:59:59") AS date_dt,
  DATE(TIMESTAMP "2016-12-24 22:30:00" /* TODO should be "2016-12-25 05:30:00+07" */ , "America/Los_Angeles") AS date_tstz;
+------------+------------+------------+
| date_ymd   | date_dt    | date_tstz  |
+------------+------------+------------+
| 2016-12-25 | 2016-12-25 | 2016-12-24 |
+------------+------------+------------+
(1 row)

!ok

select date(2022, 11, 15) as d1,
       date(datetime "2008-01-01 01:03:05") as d2,
       date(datetime(2008, 1, 1, 1, 3, 5)) as d3;
+------------+------------+------------+
| d1         | d2         | d3         |
+------------+------------+------------+
| 2022-11-15 | 2008-01-01 | 2008-01-01 |
+------------+------------+------------+
(1 row)

!ok

# Test timezone conversion when converting TIMESTAMP to DATE.
# Denver observes DST whereas Phoenix does not.
# Both cities have a -07:00 offset in winter, but Denver has -06:00 in summer.
select date(timestamp("2008-06-21 06:30:00")) as sum_utc,
       date(timestamp("2008-06-21 06:30:00"), "America/Denver") as sum_dst,
       date(timestamp("2008-06-21 06:30:00"), "America/Phoenix") as sum_std,
       date(timestamp("2008-12-21 06:30:00")) as win_utc,
       date(timestamp("2008-12-21 06:30:00"), "America/Denver") as win_dst,
       date(timestamp("2008-12-21 06:30:00"), "America/Phoenix") as win_std;
+------------+------------+------------+------------+------------+------------+
| sum_utc    | sum_dst    | sum_std    | win_utc    | win_dst    | win_std    |
+------------+------------+------------+------------+------------+------------+
| 2008-06-21 | 2008-06-21 | 2008-06-20 | 2008-12-21 | 2008-12-20 | 2008-12-20 |
+------------+------------+------------+------------+------------+------------+
(1 row)

!ok

# Date-time literals.
# As for other tests in this script, data type semantics match BigQuery:
# DATETIME is what Calcite calls TIMESTAMP;
# TIMESTAMP is what Calcite calls TIMESTAMP WITH LOCAL TIME ZONE;
# DATE and TIME are the same as Calcite.
SELECT
  DATETIME "1969-07-21 02:56:00" AS dt,
  TIMESTAMP "1969-07-21 02:56:00" AS ts,
  DATE "1969-07-21" AS d,
  TIME "02:56:00" AS t;
+---------------------+---------------------+------------+----------+
| dt                  | ts                  | d          | t        |
+---------------------+---------------------+------------+----------+
| 1969-07-21 02:56:00 | 1969-07-21 02:56:00 | 1969-07-21 | 02:56:00 |
+---------------------+---------------------+------------+----------+
(1 row)

!ok

#####################################################################
# DATETIME
#
# DATETIME(year, month, day, hour, minute, second)
#   Constructs a DATETIME object using INT64 values representing the
#   year, month, day, hour, minute, and second.
# DATETIME(date_expression[, time_expression])
#   Constructs a DATETIME object using a DATE object and an optional
#   TIME object.
# DATETIME(timestamp_expression [, time_zone])
#   Constructs a DATETIME object using a TIMESTAMP object. It supports
#   an optional parameter to specify a time zone. If no time zone is
#   specified, the default time zone, UTC, is used.
#
# Returns DATETIME

SELECT
  DATETIME(2008, 12, 25, 05, 30, 00) as datetime_ymdhms,
  DATETIME(TIMESTAMP "2008-12-25 05:30:00" /* TODO should be "2008-12-25 05:30:00+00" */, "America/Los_Angeles") as datetime_tstz;
+---------------------+---------------------+
| datetime_ymdhms     | datetime_tstz       |
+---------------------+---------------------+
| 2008-12-25 05:30:00 | 2008-12-24 21:30:00 |
+---------------------+---------------------+
(1 row)

!ok

select datetime(2003, 05, 25, 12, 30, 59) as dt1,
       datetime(date(2003, 05, 25)) as d2,
       datetime(date(2003, 05, 25), time(12, 30, 59)) as d3;
+---------------------+---------------------+---------------------+
| dt1                 | d2                  | d3                  |
+---------------------+---------------------+---------------------+
| 2003-05-25 12:30:59 | 2003-05-25 00:00:00 | 2003-05-25 12:30:59 |
+---------------------+---------------------+---------------------+
(1 row)

!ok

# This tests time zone conversion from a timestamp.
select datetime(timestamp "2008-01-01 01:03:05") as t_winter,
       datetime(timestamp "2008-01-01 01:03:05", "America/Los_Angeles") as t_winter_offs,
       datetime(timestamp "2008-07-01 01:03:05", "America/Los_Angeles") as t_summer_offs;
+---------------------+---------------------+---------------------+
| t_winter            | t_winter_offs       | t_summer_offs       |
+---------------------+---------------------+---------------------+
| 2008-01-01 01:03:05 | 2007-12-31 17:03:05 | 2008-06-30 18:03:05 |
+---------------------+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# TIME
#
# 1. TIME(hour, minute, second)
#   Constructs a TIME object using INT64 values representing the hour,
#   minute, and second.
# 2. TIME(timestamp, [time_zone])
#   Constructs a TIME object using a TIMESTAMP object. It supports an
#   optional parameter to specify a time zone. If no time zone is
#   specified, the default time zone, UTC, is used.
# 3. TIME(datetime)
#   Constructs a TIME object using a DATETIME object.
#
# Returns TIME

SELECT
  TIME(15, 30, 00) as time_hms,
  TIME(TIMESTAMP "2008-12-25 07:30:00" /* TODO should be "2008-12-25 15:30:00+08" */, "America/Los_Angeles") as time_tstz;
+----------+-----------+
| time_hms | time_tstz |
+----------+-----------+
| 15:30:00 | 23:30:00  |
+----------+-----------+
(1 row)

!ok

SELECT TIME(DATETIME "2008-12-25 15:30:00.000000") AS time_dt;
+----------+
| time_dt  |
+----------+
| 15:30:00 |
+----------+
(1 row)

!ok

select time(12, 30, 59) as t1,
       time(datetime(2008, 01, 01, 12, 30, 59)) as t2,
       time(datetime(2008, 07, 01, 12, 30, 59)) as t3;
+----------+----------+----------+
| t1       | t2       | t3       |
+----------+----------+----------+
| 12:30:59 | 12:30:59 | 12:30:59 |
+----------+----------+----------+
(1 row)

!ok

# Test timezone conversion when converting TIMESTAMP to TIME.
# Denver observes DST whereas Phoenix does not.
# Both cities have a -07:00 offset in winter, but Denver has -06:00 in summer.
select time(timestamp("2008-06-21 06:30:00")) as sum_utc,
       time(timestamp("2008-06-21 06:30:00"), "America/Denver") as sum_dst,
       time(timestamp("2008-06-21 06:30:00"), "America/Phoenix") as sum_std,
       time(timestamp("2008-12-21 06:30:00")) as win_utc,
       time(timestamp("2008-12-21 06:30:00"), "America/Denver") as win_dst,
       time(timestamp("2008-12-21 06:30:00"), "America/Phoenix") as win_std;
+----------+----------+----------+----------+----------+----------+
| sum_utc  | sum_dst  | sum_std  | win_utc  | win_dst  | win_std  |
+----------+----------+----------+----------+----------+----------+
| 06:30:00 | 00:30:00 | 23:30:00 | 06:30:00 | 23:30:00 | 23:30:00 |
+----------+----------+----------+----------+----------+----------+
(1 row)

!ok

# Test timezone conversion when converting DATE to TIMESTAMP.
# Denver observes DST whereas Phoenix does not.
# Both cities have a -07:00 offset in winter, but Denver has -06:00 in summer.
select timestamp(date(2008, 6, 21)) as sum_utc,
       timestamp(date(2008, 6, 21), "America/Denver") as sum_dst,
       timestamp(date(2008, 6, 21), "America/Phoenix") as sum_std,
       timestamp(date(2008, 12, 21)) as win_utc,
       timestamp(date(2008, 12, 21), "America/Denver") as win_dst,
       timestamp(date(2008, 12, 21), "America/Phoenix") as win_std;
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
| sum_utc             | sum_dst             | sum_std             | win_utc             | win_dst             | win_std             |
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
| 2008-06-21 00:00:00 | 2008-06-21 06:00:00 | 2008-06-21 07:00:00 | 2008-12-21 00:00:00 | 2008-12-21 07:00:00 | 2008-12-21 07:00:00 |
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# TIMESTAMP
#
# TIMESTAMP(string_expression[, time_zone])
#   Converts a STRING expression
#   to a TIMESTAMP data type. string_expression must include a
#   timestamp literal. If string_expression includes a
#   time_zone in the timestamp literal, do not include an
#   explicit time_zone argument.
# TIMESTAMP(date_expression[, time_zone])
#   Converts a DATE object to a TIMESTAMP data type.
# TIMESTAMP(datetime_expression[, time_zone])
#   Converts a DATETIME object to a TIMESTAMP data type.
#
# This function supports an optional parameter to specify a time zone.
# If no time zone is specified, the default time zone, UTC, is used.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT TIMESTAMP("2008-12-25 15:30:00+00") AS timestamp_str;
+-------------------------+
| timestamp_str           |
+-------------------------+
| 2008-12-25 15:30:00 UTC |
+-------------------------+
!ok
!}

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT TIMESTAMP("2008-12-25 15:30:00", "America/Los_Angeles") AS timestamp_str;
+-------------------------+
| timestamp_str           |
+-------------------------+
| 2008-12-25 23:30:00 UTC |
+-------------------------+
!ok
!}

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT TIMESTAMP("2008-12-25 15:30:00 UTC") AS timestamp_str;
+-------------------------+
| timestamp_str           |
+-------------------------+
| 2008-12-25 15:30:00 UTC |
+-------------------------+
!ok
!}

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
#
# After [CALCITE-5446] is fixed, this and other TIMESTAMP WITH LOCAL TIME
# values will end in UTC, like this: 2008-12-25 15:30:00 UTC.
#
SELECT TIMESTAMP(DATETIME "2008-12-25 15:30:00") AS timestamp_datetime;
+---------------------+
| timestamp_datetime  |
+---------------------+
| 2008-12-25 15:30:00 |
+---------------------+
(1 row)

!ok

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
SELECT TIMESTAMP(DATE "2008-12-25") AS timestamp_date;
+---------------------+
| timestamp_date      |
+---------------------+
| 2008-12-25 00:00:00 |
+---------------------+
(1 row)

!ok

# All these timestamps should be equal.
# This tests the BQ timestamp literal string formatter
# (optional 'T', optional leading zeros, optional offset with conversion).
select timestamp("2008-01-01 01:03:05+00") as t_space,
       timestamp("2008-01-01T01:03:05+00") as t_iso,
       timestamp("2008-01-01 01:03:05") as t_no_offset,
       timestamp("2008-1-1 3:5:7+02:02:02") as t_offset;
+---------------------+---------------------+---------------------+---------------------+
| t_space             | t_iso               | t_no_offset         | t_offset            |
+---------------------+---------------------+---------------------+---------------------+
| 2008-01-01 01:03:05 | 2008-01-01 01:03:05 | 2008-01-01 01:03:05 | 2008-01-01 01:03:05 |
+---------------------+---------------------+---------------------+---------------------+
(1 row)

!ok

# Negative and positive offsets.
select timestamp("2008-01-01 01:03:05+01") as space_01,
       timestamp("2008-01-01T01:03:05+01") as iso_1,
       timestamp("2008-01-01T01:03:05+01:00") as iso_1_00,
       timestamp("2008-01-01T01:03:05-11") as iso_neg_11;
+---------------------+---------------------+---------------------+---------------------+
| space_01            | iso_1               | iso_1_00            | iso_neg_11          |
+---------------------+---------------------+---------------------+---------------------+
| 2008-01-01 00:03:05 | 2008-01-01 00:03:05 | 2008-01-01 00:03:05 | 2008-01-01 12:03:05 |
+---------------------+---------------------+---------------------+---------------------+
(1 row)

!ok

# This tests time zone conversion from a datetime.
select timestamp(datetime "2008-01-01 01:03:05") as t_winter,
       timestamp(datetime "2008-01-01 01:03:05", "America/Los_Angeles") as t_winter_offs,
       timestamp(datetime "2008-07-01 01:03:05", "America/Los_Angeles") as t_summer_offs;
+---------------------+---------------------+---------------------+
| t_winter            | t_winter_offs       | t_summer_offs       |
+---------------------+---------------------+---------------------+
| 2008-01-01 01:03:05 | 2008-01-01 09:03:05 | 2008-07-01 08:03:05 |
+---------------------+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# TIMESTAMP_SECONDS
#
# TIMESTAMP_SECONDS(int64_expression)
#
# Interprets int64_expression as the number of seconds since
# 1970-01-01 00:00:00 UTC and returns a timestamp.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.

# Note that BigQuery prints "2008-12-25 15:30:00 UTC" as the result,
# whereas Calcite's result does not include "UTC". This is because
# BigQuery's TIMESTAMP type is an instant (the equivalent of Calcite's
# TIMESTAMP WITH LOCAL TIME ZONE type). It would have been too confusing
# for a function called 'TIMESTAMP_SECONDS' to return a TIMESTAMP WITH
# LOCAL TIME ZONE, so this function returns a Calcite TIMESTAMP which,
# as a local time does not include UTC or any time zone.

SELECT TIMESTAMP_SECONDS(1230219000) AS timestamp_value;
+---------------------+
| timestamp_value     |
+---------------------+
| 2008-12-25 15:30:00 |
+---------------------+
(1 row)

!ok


#####################################################################
# TIMESTAMP_MILLIS
#
# TIMESTAMP_MILLIS(int64_expression)
#
# Interprets int64_expression as the number of milliseconds since
# 1970-01-01 00:00:00 UTC and returns a timestamp.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.

# BigQuery's result ends in "UTC" but Calcite's does not, for the reasons
# explained in TIMESTAMP_SECONDS.

SELECT TIMESTAMP_MILLIS(1230219000000) AS timestamp_value;
+---------------------+
| timestamp_value     |
+---------------------+
| 2008-12-25 15:30:00 |
+---------------------+
(1 row)

!ok


#####################################################################
# TIMESTAMP_MICROS
#
# TIMESTAMP_MICROS(int64_expression)
#
# Interprets int64_expression as the number of microseconds since
# 1970-01-01 00:00:00 UTC and returns a timestamp.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT TIMESTAMP_MICROS(1230219000000000) AS timestamp_value;
+-------------------------+
| timestamp_value         |
+-------------------------+
| 2008-12-25 15:30:00 UTC |
+-------------------------+
!ok
!}

# TIMESTAMP_SECONDS, TIMESTAMP_MILLIS, TIMESTAMP_MICROS
select v,
  timestamp_seconds(v) as t0,
  timestamp_millis(v * 1000) as t1,
  timestamp_micros(v * 1000 * 1000) as t2
from (values cast(0 as bigint),
   cast(null as bigint),
   cast(1230219000 as bigint),
   cast(-1230219000 as bigint)) as t (v)
order by v;
+-------------+---------------------+---------------------+---------------------+
| v           | t0                  | t1                  | t2                  |
+-------------+---------------------+---------------------+---------------------+
| -1230219000 | 1931-01-07 08:30:00 | 1931-01-07 08:30:00 | 1931-01-07 08:30:00 |
|           0 | 1970-01-01 00:00:00 | 1970-01-01 00:00:00 | 1970-01-01 00:00:00 |
|  1230219000 | 2008-12-25 15:30:00 | 2008-12-25 15:30:00 | 2008-12-25 15:30:00 |
|             |                     |                     |                     |
+-------------+---------------------+---------------------+---------------------+
(4 rows)

!ok

select timestamp_seconds(1234567890) as t;
+---------------------+
| t                   |
+---------------------+
| 2009-02-13 23:31:30 |
+---------------------+
(1 row)

!ok

select timestamp_millis(1234567890) as t;
+---------------------+
| t                   |
+---------------------+
| 1970-01-15 06:56:07 |
+---------------------+
(1 row)

!ok

select timestamp_micros(1234567890) as t;
+---------------------+
| t                   |
+---------------------+
| 1970-01-01 00:20:34 |
+---------------------+
(1 row)

!ok

#####################################################################
# UNIX_SECONDS
#
# UNIX_SECONDS(timestamp_expression)
#
# Returns the number of seconds since 1970-01-01 00:00:00
# UTC. Truncates higher levels of precision.

!if (false) {
SELECT UNIX_SECONDS(TIMESTAMP "2008-12-25 15:30:00+00") AS seconds;
+------------+
| seconds    |
+------------+
| 1230219000 |
+------------+
!ok
!}

#####################################################################
# UNIX_MILLIS
#
# UNIX_MILLIS(timestamp_expression)
#
# Returns the number of milliseconds since 1970-01-01 00:00:00
# UTC. Truncates higher levels of precision.

!if (false) {
SELECT UNIX_MILLIS(TIMESTAMP "2008-12-25 15:30:00+00") AS millis;
+---------------+
| millis        |
+---------------+
| 1230219000000 |
+---------------+
!ok
!}

#####################################################################
# UNIX_MICROS
#
# UNIX_MICROS(timestamp_expression)
#
# Returns the number of microseconds since 1970-01-01 00:00:00
# UTC. Truncates higher levels of precision.

!if (false) {
SELECT UNIX_MICROS(TIMESTAMP "2008-12-25 15:30:00+00") AS micros;
+------------------+
| micros           |
+------------------+
| 1230219000000000 |
+------------------+
!ok
!}

# UNIX_SECONDS, UNIX_MILLIS, UNIX_MICROS
select v,
  unix_seconds(v) as t0,
  unix_millis(v) as t1,
  unix_micros(v) as t2
from (values TIMESTAMP '1970-01-01 00:00:00',
   cast(null as timestamp),
   TIMESTAMP '2008-12-25 15:30:00',
   TIMESTAMP '1931-01-07 08:30:00') as t (v)
order by v;
+---------------------+-------------+----------------+-------------------+
| v                   | t0          | t1             | t2                |
+---------------------+-------------+----------------+-------------------+
| 1931-01-07 08:30:00 | -1230219000 | -1230219000000 | -1230219000000000 |
| 1970-01-01 00:00:00 |           0 |              0 |                 0 |
| 2008-12-25 15:30:00 |  1230219000 |  1230219000000 |  1230219000000000 |
|                     |             |                |                   |
+---------------------+-------------+----------------+-------------------+
(4 rows)

!ok

select unix_seconds(timestamp '2008-12-25 15:30:00') as t;
+------------+
| t          |
+------------+
| 1230219000 |
+------------+
(1 row)

!ok

select unix_millis(timestamp '2008-12-25 15:30:00') as t;
+---------------+
| t             |
+---------------+
| 1230219000000 |
+---------------+
(1 row)

!ok

select unix_micros(timestamp '2008-12-25 15:30:00') as t;
+------------------+
| t                |
+------------------+
| 1230219000000000 |
+------------------+
(1 row)

!ok

#####################################################################
# DATE_FROM_UNIX_DATE
select v,
  date_from_unix_date(v) as d
from (values 0,
   cast(null as integer),
   1230219000 / 86400,
   -1230219000 / 86400) as t (v)
order by v;
+--------+------------+
| v      | d          |
+--------+------------+
| -14238 | 1931-01-08 |
|      0 | 1970-01-01 |
|  14238 | 2008-12-25 |
|        |            |
+--------+------------+
(4 rows)

!ok

select date_from_unix_date(14238);
+------------+
| EXPR$0     |
+------------+
| 2008-12-25 |
+------------+
(1 row)

!ok

#####################################################################
# UNIX_DATE
select v,
  unix_date(v) as d
from (values date '1970-01-01',
   cast(null as date),
   DATE '2008-12-25',
   DATE '1931-01-07') as t (v)
order by v;
+------------+--------+
| v          | d      |
+------------+--------+
| 1931-01-07 | -14239 |
| 1970-01-01 |      0 |
| 2008-12-25 |  14238 |
|            |        |
+------------+--------+
(4 rows)

!ok

select unix_date(datetime '2008-12-25') as d;
+-------+
| d     |
+-------+
| 14238 |
+-------+
(1 row)

!ok


#####################################################################
# DATE_ADD
#
# DATE_ADD(date_expression, INTERVAL int64_expression date_part)
#
# Adds a specified time interval to a DATE.
#
# DATE_ADD supports the following date_part values:
#   DAY
#   WEEK. Equivalent to 7 DAYs.
#   MONTH
#   QUARTER
#   YEAR
#
# Special handling is required for MONTH, QUARTER, and YEAR parts when
# the date is at (or near) the last day of the month. If the resulting
# month has fewer days than the original date's day, then the
# resulting date is the last date of that month.
#
# Returns DATE

SELECT DATE_ADD(DATE "2008-12-25", INTERVAL 5 DAY) AS five_days_later;
+-----------------+
| five_days_later |
+-----------------+
| 2008-12-30      |
+-----------------+
(1 row)

!ok

#####################################################################
# DATETIME_ADD
#
# DATETIME_ADD(datetime_expression, INTERVAL int64_expression part)
#
# Adds int64_expression units of part to the DATETIME object.
#
# DATETIME_ADD supports the following values for part:
#
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#   DAY
#   WEEK. Equivalent to 7 DAYs.
#   MONTH
#   QUARTER
#   YEAR
#
# Special handling is required for MONTH, QUARTER, and YEAR parts when
# the date is at (or near) the last day of the month. If the resulting
# month has fewer days than the original DATETIME's day, then the
# result day is the last day of the new month.
#
# Returns DATETIME

SELECT
  DATETIME "2008-12-25 15:30:00" as original_date,
  DATETIME_ADD(DATETIME "2008-12-25 15:30:00", INTERVAL 10 MINUTE) as later;
+---------------------+---------------------+
| original_date       | later               |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:40:00 |
+---------------------+---------------------+
(1 row)

!ok

SELECT
  DATETIME "2008-12-25 15:30:00" as original_date,
  DATETIME_ADD(TIMESTAMP "2008-12-25 15:30:00", INTERVAL 20 MINUTE) as later;
+---------------------+---------------------+
| original_date       | later               |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:50:00 |
+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# TIME_ADD
#
# TIME_ADD(time_expression, INTERVAL int64_expression part)
#
# Adds int64_expression units of part to the TIME object.
#
# TIME_ADD supports the following values for part:
#
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#
# This function automatically adjusts when values fall outside of the
# 00:00:00 to 24:00:00 boundary. For example, if you add an hour to
# 23:30:00, the returned value is 00:30:00.
#
# Returns TIME

SELECT
  TIME "15:30:00" as original_time,
  TIME_ADD(TIME "15:30:00", INTERVAL 10 MINUTE) as later;
+---------------+----------+
| original_time | later    |
+---------------+----------+
| 15:30:00      | 15:40:00 |
+---------------+----------+
(1 row)

!ok

#####################################################################
# TIMESTAMP_ADD
#
# TIMESTAMP_ADD(timestamp_expression, INTERVAL int64_expression date_part)
#
# Adds int64_expression units of date_part to the timestamp,
# independent of any time zone.
#
# TIMESTAMP_ADD supports the following values for date_part:
#  MICROSECOND
#  MILLISECOND
#  SECOND
#  MINUTE
#  HOUR. Equivalent to 60 MINUTEs.
#  DAY. Equivalent to 24 HOURs.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
# Enable when we have TIMESTAMP() function,
# and when we allow "+00" timezone offset in timestamp values.
SELECT
  TIMESTAMP("2008-12-25 15:30:00+00") AS original,
  TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL 10 MINUTE) AS later;
+-------------------------+-------------------------+
| original                | later                   |
+-------------------------+-------------------------+
| 2008-12-25 15:30:00 UTC | 2008-12-25 15:40:00 UTC |
+-------------------------+-------------------------+
(1 row)

!ok
!}

# As previous, but uses TIMESTAMP literal rather than function,
# and "+00" timezone offsets have been removed.
SELECT
  TIMESTAMP "2008-12-25 15:30:00" AS original,
  TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00", INTERVAL 10 MINUTE) AS later;
+---------------------+---------------------+
| original            | later               |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:40:00 |
+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# LPAD(original_value, return_length, pattern)
#
# Returns a STRING or BYTES value that consists of original_value prepended
# with pattern.
#
# This function supports specifying collation.
WITH Examples AS (
  SELECT LPAD('12345', 8, 'a') as result, "8" as pad_length, "a" as p UNION ALL
  SELECT LPAD('12345', 8), "8", " " UNION ALL
  SELECT LPAD('12345', 8, 'aba'), "8", "aba" UNION ALL
  SELECT LPAD('12345', 3), "3", " " UNION ALL
  SELECT LPAD(x'aa', 4, x'bb'), "4", "x'bb'" UNION ALL
  SELECT LPAD(x'aa', 4), "4", "20" UNION ALL
  SELECT LPAD(x'aaaaaa', 2), "2", "20" UNION ALL
  SELECT LPAD(x'aaaaaa', 2, x'bb'), "2", "x'bb'"
)
SELECT
  *
FROM Examples;
+----------+------------+-------+
| result   | pad_length | p     |
+----------+------------+-------+
| aaa12345 | 8          | a     |
|    12345 | 8          |       |
| aba12345 | 8          | aba   |
| 123      | 3          |       |
| bbbbbbaa | 4          | x'bb' |
| 202020aa | 4          | 20    |
| aaaa     | 2          | 20    |
| aaaa     | 2          | x'bb' |
+----------+------------+-------+
(8 rows)

!ok

#####################################################################
# RPAD(original_value, return_length, pattern)
#
# Returns a STRING or BYTES value that consists of original_value prepended
# with pattern.
#
# This function supports specifying collation.
WITH Examples AS (
  SELECT RPAD('12345', 8, 'a') as result, "8" as pad_length, "a" as p UNION ALL
  SELECT RPAD('12345', 8), "8", " " UNION ALL
  SELECT RPAD('12345', 8, 'aba'), "8", "aba" UNION ALL
  SELECT RPAD('12345', 3), "3", " " UNION ALL
  SELECT RPAD(x'aa', 4, x'bb'), "4", "x'bb'" UNION ALL
  SELECT RPAD(x'aa', 4), "4", "20" UNION ALL
  SELECT RPAD(x'aaaaaa', 2), "2", "20" UNION ALL
  SELECT RPAD(x'aaaaaa', 2, x'bb'), "2", "x'bb'"
)
SELECT
  *
FROM Examples;
+----------+------------+-------+
| result   | pad_length | p     |
+----------+------------+-------+
| 12345aaa | 8          | a     |
| 12345    | 8          |       |
| 12345aba | 8          | aba   |
| 123      | 3          |       |
| aabbbbbb | 4          | x'bb' |
| aa202020 | 4          | 20    |
| aaaa     | 2          | 20    |
| aaaa     | 2          | x'bb' |
+----------+------------+-------+
(8 rows)

!ok

#####################################################################
# DATE_SUB
#
# DATE_SUB(date_expression, INTERVAL int64_expression date_part)
#
# Subtracts a specified time interval from a DATE.
#
# DATE_SUB supports the following date_part values:
#
#   DAY
#   WEEK. Equivalent to 7 DAYs.
#   MONTH
#   QUARTER
#   YEAR
#
# Special handling is required for MONTH, QUARTER, and YEAR parts when
# the date is at (or near) the last day of the month. If the resulting
# month has fewer days than the original date's day, then the
# resulting date is the last date of that month.
#
# Returns DATE

SELECT DATE_SUB(DATE "2008-12-25", INTERVAL 5 DAY) AS five_days_ago;
+---------------+
| five_days_ago |
+---------------+
| 2008-12-20    |
+---------------+
(1 row)

!ok

#####################################################################
# DATETIME_SUB
#
# DATETIME_SUB(datetime_expression, INTERVAL int64_expression part)
#
# Subtracts int64_expression units of part from the DATETIME.
#
# DATETIME_SUB supports the following values for part:
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#   DAY
#   WEEK. Equivalent to 7 DAYs.
#   MONTH
#   QUARTER
#   YEAR
#
# Special handling is required for MONTH, QUARTER, and YEAR parts when
# the date is at (or near) the last day of the month. If the resulting
# month has fewer days than the original DATETIME's day, then the
# result day is the last day of the new month.
#
# Returns DATETIME

SELECT
  DATETIME "2008-12-25 15:30:00" as original_date,
  DATETIME_SUB(DATETIME "2008-12-25 15:30:00", INTERVAL 10 MINUTE) as earlier;
+---------------------+---------------------+
| original_date       | earlier             |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:20:00 |
+---------------------+---------------------+
(1 row)

!ok

SELECT
  TIMESTAMP "2008-12-25 15:30:00" as original_date,
  DATETIME_SUB(TIMESTAMP "2008-12-25 15:30:00", INTERVAL 10 MINUTE) as earlier;
+---------------------+---------------------+
| original_date       | earlier             |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:20:00 |
+---------------------+---------------------+
(1 row)

!ok


#####################################################################
# TIME_SUB
#
# TIME_SUB(time_expression, INTERVAL int64_expression part)
#
# Subtracts int64_expression units of part from the TIME object.
#
# TIME_SUB supports the following values for part:
#
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#
# This function automatically adjusts when values fall outside of the
# 00:00:00 to 24:00:00 boundary. For example, if you subtract an hour
# from 00:30:00, the returned value is 23:30:00.
#
# Returns TIME

SELECT
  TIME "15:30:00" as original_date,
  TIME_SUB(TIME "15:30:00", INTERVAL 10 MINUTE) as earlier;
+---------------+----------+
| original_date | earlier  |
+---------------+----------+
| 15:30:00      | 15:20:00 |
+---------------+----------+
(1 row)

!ok

#####################################################################
# TIMESTAMP_SUB
#
# TIMESTAMP_SUB(timestamp_expression, INTERVAL int64_expression date_part)
#
# Subtracts int64_expression units of date_part from the
# timestamp, independent of any time zone.
#
# TIMESTAMP_SUB supports the following values for date_part:
#  MICROSECOND
#  MILLISECOND
#  SECOND
#  MINUTE
#  HOUR. Equivalent to 60 MINUTEs.
# DAY. Equivalent to 24 HOURs.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.

SELECT
  TIMESTAMP "2008-12-25 15:30:00" AS original,
  TIMESTAMP_SUB(TIMESTAMP "2008-12-25 15:30:00", INTERVAL 10 MINUTE) AS earlier;
+---------------------+---------------------+
| original            | earlier             |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 15:20:00 |
+---------------------+---------------------+
(1 row)

!ok

#####################################################################
# DATE_DIFF
#
# DATE_DIFF(date_expression_a, date_expression_b, date_part)
#
# Returns the whole number of specified date_part intervals between
# two DATE objects (date_expression_a - date_expression_b). If the
# first DATE is earlier than the second one, the output is negative.
#
# DATE_DIFF supports the following date_part values:
#   DAY
#   WEEK This date part begins on Sunday.
#   WEEK(<WEEKDAY>): This date part begins on WEEKDAY. Valid values
#     for WEEKDAY are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
#     FRIDAY, and SATURDAY.
#   ISOWEEK: Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
#   MONTH, except when the first two arguments are TIMESTAMP objects.
#   QUARTER
#   YEAR
#   ISOYEAR: Uses the ISO 8601 week-numbering year boundary. The ISO
#     year boundary is the Monday of the first week whose Thursday
#     belongs to the corresponding Gregorian calendar year.
#
# Returns INT64

SELECT DATE_DIFF(DATE '2010-07-07', DATE '2008-12-25', DAY) AS days_diff;
+-----------+
| days_diff |
+-----------+
|       559 |
+-----------+
(1 row)

!ok

SELECT
  DATE_DIFF(DATE '2017-10-15', DATE '2017-10-14', DAY) AS days_diff,
  DATE_DIFF(DATE '2017-10-15', DATE '2017-10-14', WEEK) AS weeks_diff;
+-----------+------------+
| days_diff | weeks_diff |
+-----------+------------+
|         1 |          1 |
+-----------+------------+
(1 row)

!ok

# The example above shows the result of DATE_DIFF for two days in
# succession. DATE_DIFF with the date part WEEK returns 1 because
# DATE_DIFF counts the number of date part boundaries in this range of
# dates. Each WEEK begins on Sunday, so there is one date part
# boundary between Saturday, 2017-10-14 and Sunday, 2017-10-15.

# The following example shows the result of DATE_DIFF for two dates in
# different years. DATE_DIFF with the date part YEAR returns 3 because
# it counts the number of Gregorian calendar year boundaries between
# the two dates. DATE_DIFF with the date part ISOYEAR returns 2
# because the second date belongs to the ISO year 2015. The first
# Thursday of the 2015 calendar year was 2015-01-01, so the ISO year
# 2015 begins on the preceding Monday, 2014-12-29.

SELECT
  DATE_DIFF('2017-12-30', '2014-12-30', YEAR) AS year_diff,
  DATE_DIFF('2017-12-30', '2014-12-30', ISOYEAR) AS isoyear_diff;
+-----------+--------------+
| year_diff | isoyear_diff |
+-----------+--------------+
|         3 |            2 |
+-----------+--------------+
(1 row)

!ok

# The following example shows the result of DATE_DIFF for two days in
# succession. The first date falls on a Monday and the second date
# falls on a Sunday. DATE_DIFF with the date part WEEK returns 0
# because this date part uses weeks that begin on Sunday. DATE_DIFF
# with the date part WEEK(MONDAY) returns 1. DATE_DIFF with the date
# part ISOWEEK also returns 1 because ISO weeks begin on Monday.

SELECT
  DATE_DIFF('2017-12-18', '2017-12-17', WEEK) AS week_diff,
  DATE_DIFF('2017-12-18', '2017-12-17', WEEK(MONDAY)) AS week_weekday_diff,
  DATE_DIFF('2017-12-18', '2017-12-17', ISOWEEK) AS isoweek_diff;
+-----------+-------------------+--------------+
| week_diff | week_weekday_diff | isoweek_diff |
+-----------+-------------------+--------------+
|         0 |                 1 |            1 |
+-----------+-------------------+--------------+
(1 row)

!ok

#####################################################################
# DATETIME_DIFF
#
# DATETIME_DIFF(datetime_expression_a, datetime_expression_b, part)
#
# Returns the whole number of specified part intervals between two
# DATETIME objects (datetime_expression_a - datetime_expression_b). If
# the first DATETIME is earlier than the second one, the output is
# negative. Throws an error if the computation overflows the result
# type, such as if the difference in microseconds between the two
# DATETIME objects would overflow an INT64 value.
#
# DATETIME_DIFF supports the following values for part:
#
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#   DAY
#   WEEK: This date part begins on Sunday.
#   WEEK(<WEEKDAY>): This date part begins on WEEKDAY. Valid values
#     for WEEKDAY are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
#     FRIDAY, and SATURDAY.
#   ISOWEEK: Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
#   MONTH, except when the first two arguments are TIMESTAMP objects.
#   QUARTER
#   YEAR
#   ISOYEAR: Uses the ISO 8601 week-numbering year boundary. The ISO
#     year boundary is the Monday of the first week whose Thursday
#     belongs to the corresponding Gregorian calendar year.
#
# Returns INT64

SELECT
  DATETIME "2010-07-07 10:20:00" as first_datetime,
  DATETIME "2008-12-25 15:30:00" as second_datetime,
  DATETIME_DIFF(DATETIME "2010-07-07 10:20:00",
    DATETIME "2008-12-25 15:30:00", DAY) as difference;
+---------------------+---------------------+------------+
| first_datetime      | second_datetime     | difference |
+---------------------+---------------------+------------+
| 2010-07-07 10:20:00 | 2008-12-25 15:30:00 |        559 |
+---------------------+---------------------+------------+
(1 row)

!ok

SELECT
  DATETIME_DIFF(DATETIME '2017-10-15 00:00:00',
    DATETIME '2017-10-14 00:00:00', DAY) as days_diff,
  DATETIME_DIFF(DATETIME '2017-10-15 00:00:00',
    DATETIME '2017-10-14 00:00:00', WEEK) as weeks_diff;
+-----------+------------+
| days_diff | weeks_diff |
+-----------+------------+
|         1 |          1 |
+-----------+------------+
(1 row)

!ok

# The example above shows the result of DATETIME_DIFF for two
# DATETIMEs that are 24 hours apart. DATETIME_DIFF with the part WEEK
# returns 1 because DATETIME_DIFF counts the number of part boundaries
# in this range of DATETIMEs. Each WEEK begins on Sunday, so there is
# one part boundary between Saturday, 2017-10-14 00:00:00 and Sunday,
# 2017-10-15 00:00:00.
#
# The following example shows the result of DATETIME_DIFF for two
# dates in different years. DATETIME_DIFF with the date part YEAR
# returns 3 because it counts the number of Gregorian calendar year
# boundaries between the two DATETIMEs. DATETIME_DIFF with the date
# part ISOYEAR returns 2 because the second DATETIME belongs to the
# ISO year 2015. The first Thursday of the 2015 calendar year was
# 2015-01-01, so the ISO year 2015 begins on the preceding Monday,
# 2014-12-29.

SELECT
  DATETIME_DIFF('2017-12-30 00:00:00',
    '2014-12-30 00:00:00', YEAR) AS year_diff,
  DATETIME_DIFF('2017-12-30 00:00:00',
    '2014-12-30 00:00:00', ISOYEAR) AS isoyear_diff;
+-----------+--------------+
| year_diff | isoyear_diff |
+-----------+--------------+
|         3 |            2 |
+-----------+--------------+
(1 row)

!ok

# The following example shows the result of DATETIME_DIFF for two days
# in succession. The first date falls on a Monday and the second date
# falls on a Sunday. DATETIME_DIFF with the date part WEEK returns 0
# because this time part uses weeks that begin on
# Sunday. DATETIME_DIFF with the date part WEEK(MONDAY) returns
# 1. DATETIME_DIFF with the date part ISOWEEK also returns 1 because
# ISO weeks begin on Monday.

SELECT
  DATETIME_DIFF('2017-12-18', '2017-12-17', WEEK) AS week_diff,
  DATETIME_DIFF('2017-12-18', '2017-12-17', WEEK(MONDAY)) AS week_weekday_diff,
  DATETIME_DIFF('2017-12-18', '2017-12-17', ISOWEEK) AS isoweek_diff;
+-----------+-------------------+--------------+
| week_diff | week_weekday_diff | isoweek_diff |
+-----------+-------------------+--------------+
|         0 |                 1 |            1 |
+-----------+-------------------+--------------+
(1 row)

!ok

#####################################################################
# TIME_DIFF
#
# TIME_DIFF(time_expression_a, time_expression_b, part)
#
# Returns the whole number of specified part intervals between two
# TIME objects (time_expression_a - time_expression_b). If the first
# TIME is earlier than the second one, the output is negative. Throws
# an error if the computation overflows the result type, such as if
# the difference in microseconds between the two TIME objects would
# overflow an INT64 value.
#
# TIME_DIFF supports the following values for part:
#   MICROSECOND
#   MILLISECOND
#   SECOND
#   MINUTE
#   HOUR
#
# Returns INT64

SELECT
  TIME "15:30:00" as first_time,
  TIME "14:35:00" as second_time,
  TIME_DIFF(TIME "15:30:00", TIME "14:35:00", MINUTE) as difference;
+------------+-------------+------------+
| first_time | second_time | difference |
+------------+-------------+------------+
| 15:30:00   | 14:35:00    |         55 |
+------------+-------------+------------+
(1 row)

!ok

#####################################################################
# TIMESTAMP_DIFF
#
# TIMESTAMP_DIFF(timestamp_expression_a, timestamp_expression_b, date_part)
#
# Returns the whole number of specified date_part intervals
# between two TIMESTAMP objects (timestamp_expression_a -
# timestamp_expression_b). If the first TIMESTAMP is earlier
# than the second one, the output is negative. Throws an
# error if the computation overflows the result type, such
# as if the difference in microseconds between the two
# TIMESTAMP objects would overflow an INT64 value.
#
# TIMESTAMP_DIFF supports the following values for date_part:
#  MICROSECOND
#  MILLISECOND
#  SECOND
#  MINUTE
#  HOUR. Equivalent to 60 MINUTEs.
#  DAY. Equivalent to 24 HOURs.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
SELECT
  TIMESTAMP "2010-07-07 10:20:00" AS later_timestamp,
  TIMESTAMP "2008-12-25 15:30:00" AS earlier_timestamp,
  TIMESTAMP_DIFF(TIMESTAMP "2010-07-07 10:20:00", TIMESTAMP "2008-12-25 15:30:00", HOUR) AS hours;
+---------------------+---------------------+-------+
| later_timestamp     | earlier_timestamp   | hours |
+---------------------+---------------------+-------+
| 2010-07-07 10:20:00 | 2008-12-25 15:30:00 | 13410 |
+---------------------+---------------------+-------+
(1 row)

!ok

# In the following example, the first timestamp occurs
# before the second timestamp, resulting in a negative output.
SELECT TIMESTAMP_DIFF(TIMESTAMP "2018-08-14", TIMESTAMP "2018-10-14", DAY) AS negative_diff;
+---------------+
| negative_diff |
+---------------+
|           -61 |
+---------------+
(1 row)

!ok

# In this example, the result is 0 because only the number
# of whole specified HOUR intervals are included.
SELECT TIMESTAMP_DIFF("2001-02-01 01:00:00", "2001-02-01 00:00:01", HOUR) AS negative_diff;
+---------------+
| negative_diff |
+---------------+
|             0 |
+---------------+
(1 row)

!ok

# In this example, the time unit is a 'flag' literal.
SELECT TIMESTAMP_DIFF(TIMESTAMP '2008-12-25', TIMESTAMP '2008-09-25', `quarter`) as diff;
+------+
| diff |
+------+
|    1 |
+------+
(1 row)

!ok
#####################################################################
# DATE_TRUNC
#
# DATE_TRUNC(date_expression, date_part)
#
# Truncates a DATE value to the granularity of date_part. The DATE
# value is always rounded to the beginning of date_part, which can be
# one of the following:
#   DAY: The day in the Gregorian calendar year that contains the DATE
#     value.
#   WEEK: The first day of the week in the week that contains the DATE
#     value. Weeks begin on Sundays. WEEK is equivalent to
#     WEEK(SUNDAY).
#   WEEK(WEEKDAY): The first day of the week in the week that contains
#     the DATE value. Weeks begin on WEEKDAY. WEEKDAY must be one of
#     the following: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
#     FRIDAY, or SATURDAY.
#   ISOWEEK: The first day of the ISO 8601 week in the ISO week that
#     contains the DATE value. The ISO week begins on Monday. The
#     first ISO week of each ISO year contains the first Thursday of
#     the corresponding Gregorian calendar year.
#   MONTH: The first day of the month in the month that contains the
#     DATE value.
#   QUARTER: The first day of the quarter in the quarter that contains
#     the DATE value.
#   YEAR: The first day of the year in the year that contains the DATE
#     value.
#   ISOYEAR: The first day of the ISO 8601 week-numbering year in the
#     ISO year that contains the DATE value. The ISO year is the
#     Monday of the first week whose Thursday belongs to the
#     corresponding Gregorian calendar year.
#
# Returns DATE
WITH Dates AS (
  SELECT DATE_TRUNC(DATE '2008-12-25', YEAR) as d , "year" as frame UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', ISOYEAR), "isoyear" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', QUARTER), "quarter" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', MONTH), "month" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', WEEK), "week" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', WEEK(SUNDAY)), "week(sunday)" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', WEEK(MONDAY)), "week(monday)" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', WEEK(TUESDAY)), "week(tuesday)" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', ISOWEEK), "isoweek" UNION ALL
  SELECT DATE_TRUNC(DATE '2008-12-25', DAY), "day"
)
SELECT
  *
FROM Dates;
+------------+---------------+
| d          | frame         |
+------------+---------------+
| 2008-01-01 | year          |
| 2007-12-31 | isoyear       |
| 2008-10-01 | quarter       |
| 2008-12-01 | month         |
| 2008-12-21 | week          |
| 2008-12-21 | week(sunday)  |
| 2008-12-22 | week(monday)  |
| 2008-12-23 | week(tuesday) |
| 2008-12-22 | isoweek       |
| 2008-12-25 | day           |
+------------+---------------+
(10 rows)

!ok

# Show that the return type matches the operand type
SELECT
    DATE_TRUNC(TIMESTAMP "2008-12-25 15:30:00", MONTH) AS timestamp_result,
    DATE_TRUNC(DATETIME "2008-12-25 15:30:00", MONTH) AS datetime_result;
timestamp_result TIMESTAMP_WITH_LOCAL_TIME_ZONE NOT NULL
datetime_result TIMESTAMP NOT NULL
!type

# In the following example, the original date falls on a
# Sunday. Because the date_part is WEEK(MONDAY), DATE_TRUNC returns
# the DATE for the preceding Monday.

!if (false) {
SELECT date AS original, DATE_TRUNC(date, WEEK(MONDAY)) AS truncated
FROM (SELECT DATE('2017-11-05') AS date);
+------------+------------+
| original   | truncated  |
+------------+------------+
| 2017-11-05 | 2017-10-30 |
+------------+------------+
!ok
!}

# In the following example, the original date_expression is in the
# Gregorian calendar year 2015. However, DATE_TRUNC with the ISOYEAR
# date part truncates the date_expression to the beginning of the ISO
# year, not the Gregorian calendar year. The first Thursday of the
# 2015 calendar year was 2015-01-01, so the ISO year 2015 begins on
# the preceding Monday, 2014-12-29. Therefore the ISO year boundary
# preceding the date_expression 2015-06-15 is 2014-12-29.

!if (false) {
SELECT
  DATE_TRUNC('2015-06-15', ISOYEAR) AS isoyear_boundary,
  EXTRACT(ISOYEAR FROM DATE '2015-06-15') AS isoyear_number;
+------------------+----------------+
| isoyear_boundary | isoyear_number |
+------------------+----------------+
| 2014-12-29       | 2015           |
+------------------+----------------+
!ok
!}

#####################################################################
# DATETIME_TRUNC
#
# DATETIME_TRUNC(datetime_expression, date_time_part)
#
# Truncates a DATETIME value to the granularity of date_time_part. The
# DATETIME value is always rounded to the beginning of date_time_part,
# which can be one of the following:
#
#   MICROSECOND: If used, nothing is truncated from the value.
#   MILLISECOND: The nearest lessor or equal millisecond.
#   SECOND: The nearest lessor or equal second.
#   MINUTE: The nearest lessor or equal minute.
#   HOUR: The nearest lessor or equal hour.
#   DAY: The day in the Gregorian calendar year that contains the
#     DATETIME value.
#   WEEK: The first day of the week in the week that contains the
#     DATETIME value. Weeks begin on Sundays. WEEK is equivalent to
#     WEEK(SUNDAY).
#   WEEK(WEEKDAY): The first day of the week in the week that contains
#     the DATETIME value. Weeks begin on WEEKDAY. WEEKDAY must be one
#     of the following: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
#     FRIDAY, or SATURDAY.
#   ISOWEEK: The first day of the ISO 8601 week in the ISO week that
#     contains the DATETIME value. The ISO week begins on Monday. The
#     first ISO week of each ISO year contains the first Thursday of
#     the corresponding Gregorian calendar year.
#   MONTH: The first day of the month in the month that contains the
#     DATETIME value.
#   QUARTER: The first day of the quarter in the quarter that contains
#     the DATETIME value.
#   YEAR: The first day of the year in the year that contains the
#     DATETIME value.
#   ISOYEAR: The first day of the ISO 8601 week-numbering year in the
#     ISO year that contains the DATETIME value. The ISO year is the
#     Monday of the first week whose Thursday belongs to the
#     corresponding Gregorian calendar year.
#
# Returns DATETIME


SELECT
  DATETIME "2008-12-25 15:30:00" as original,
  DATETIME_TRUNC(DATETIME "2008-12-25 15:30:00", DAY) as truncated;
+---------------------+---------------------+
| original            | truncated           |
+---------------------+---------------------+
| 2008-12-25 15:30:00 | 2008-12-25 00:00:00 |
+---------------------+---------------------+
(1 row)

!ok

# Show that the return type matches the operand type, unless it is a date
# in which case a TIMESTAMP is returned.
SELECT
    DATETIME_TRUNC(TIMESTAMP "2008-12-25 15:30:00", MONTH) AS timestamp_result,
    DATETIME_TRUNC(DATETIME "2008-12-25 15:30:00", MONTH) AS datetime_result;
timestamp_result TIMESTAMP_WITH_LOCAL_TIME_ZONE NOT NULL
datetime_result TIMESTAMP NOT NULL
!type


# In the following example, the original DATETIME falls on a
# Sunday. Because the part is WEEK(MONDAY), DATE_TRUNC returns the
# DATETIME for the preceding Monday.

!if (false) {
SELECT
 datetime AS original,
 DATETIME_TRUNC(datetime, WEEK(MONDAY)) AS truncated
FROM (SELECT DATETIME(TIMESTAMP "2017-11-05 00:00:00+00", "UTC") AS datetime);
+---------------------+---------------------+
| original            | truncated           |
+---------------------+---------------------+
| 2017-11-05T00:00:00 | 2017-10-30T00:00:00 |
+---------------------+---------------------+
!ok
!}

# In the following example, the original datetime_expression is in the
# Gregorian calendar year 2015. However, DATETIME_TRUNC with the
# ISOYEAR date part truncates the datetime_expression to the beginning
# of the ISO year, not the Gregorian calendar year. The first Thursday
# of the 2015 calendar year was 2015-01-01, so the ISO year 2015
# begins on the preceding Monday, 2014-12-29. Therefore the ISO year
# boundary preceding the datetime_expression 2015-06-15 00:00:00 is
# 2014-12-29.

!if (false) {
SELECT
  DATETIME_TRUNC('2015-06-15 00:00:00', ISOYEAR) AS isoyear_boundary,
  EXTRACT(ISOYEAR FROM DATETIME '2015-06-15 00:00:00') AS isoyear_number;
+---------------------+----------------+
| isoyear_boundary    | isoyear_number |
+---------------------+----------------+
| 2014-12-29T00:00:00 | 2015           |
+---------------------+----------------+
!ok
!}

#####################################################################
# TIME_TRUNC
#
# TIME_TRUNC(time_expression, time_part)
#
# Truncates a TIME value to the granularity of time_part. The TIME
# value is always rounded to the beginning of time_part, which can be
# one of the following:
#
#   MICROSECOND: If used, nothing is truncated from the value.
#   MILLISECOND: The nearest lessor or equal millisecond.
#   SECOND: The nearest lessor or equal second.
#   MINUTE: The nearest lessor or equal minute.
#   HOUR: The nearest lessor or equal hour.
#
# Returns TIME

SELECT
  TIME "15:30:00" as original,
  TIME_TRUNC(TIME "15:30:00", HOUR) as truncated;
+----------+-----------+
| original | truncated |
+----------+-----------+
| 15:30:00 | 15:00:00  |
+----------+-----------+
(1 row)

!ok

#####################################################################
# TIMESTAMP_TRUNC
#
# TIMESTAMP_TRUNC(timestamp_expression, date_time_part[, time_zone])
#
# Truncates a TIMESTAMP value to the granularity of
# date_time_part. The TIMESTAMP value is always rounded to
# the beginning of date_time_part, which can be one of the following:
#  MICROSECOND: If used, nothing is truncated from the value.
#  MILLISECOND: The nearest lessor or equal millisecond.
#  SECOND: The nearest lessor or equal second.
#  MINUTE: The nearest lessor or equal minute.
#  HOUR: The nearest lessor or equal hour.
#  DAY: The day in the Gregorian calendar year that contains the
#    TIMESTAMP value.
#  WEEK: The first day of the week in the week that contains the
#    TIMESTAMP value. Weeks begin on Sundays. WEEK is equivalent to
#    WEEK(SUNDAY).
#  WEEK(WEEKDAY): The first day of the week in the week that contains
#    the TIMESTAMP value. Weeks begin on WEEKDAY. WEEKDAY must be one
#    of the following: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
#    FRIDAY, or SATURDAY.
#  ISOWEEK: The first day of the ISO 8601 week in the ISO week that
#    contains the TIMESTAMP value. The ISO week begins on Monday.
#    The first ISO week of each ISO year contains the first Thursday
#    of the corresponding Gregorian calendar year.
#  MONTH: The first day of the month in the month that contains the
#    TIMESTAMP value.
#  QUARTER: The first day of the quarter in the quarter that contains
#    the TIMESTAMP value.
#  YEAR: The first day of the year in the year that contains the
#    TIMESTAMP value.
#  ISOYEAR: The first day of the ISO 8601 week-numbering year in the
#    ISO year that contains the TIMESTAMP value. The ISO year is the
#    Monday of the first week whose Thursday belongs to the
#    corresponding Gregorian calendar year.
#
# TIMESTAMP_TRUNC function supports an optional time_zone parameter.
# This parameter applies to the following date_time_part:
#  MINUTE
#  HOUR
#  DAY
#  WEEK
#  WEEK(<WEEKDAY>)
#  ISOWEEK
#  MONTH
#  QUARTER
#  YEAR
#  ISOYEAR
#
# Use this parameter if you want to use a time zone other than the
# default time zone, UTC, as part of the truncate operation.
#
# When truncating a TIMESTAMP to MINUTE or HOUR, TIMESTAMP_TRUNC
# determines the civil time of the TIMESTAMP in the specified (or
# default) time zone and subtracts the minutes and seconds (when
# truncating to HOUR) or the seconds (when truncating to MINUTE) from
# that TIMESTAMP. While this provides intuitive results in most cases,
# the result is non-intuitive near daylight savings transitions that
# are not hour aligned.

# Show that the return type matches the operand type, unless it is a date
# in which case a TIMESTAMP is returned.
SELECT
    TIMESTAMP_TRUNC(TIMESTAMP "2008-12-25 15:30:00", MONTH) AS timestamp_result,
    TIMESTAMP_TRUNC(DATETIME "2008-12-25 15:30:00", MONTH) AS datetime_result;
timestamp_result TIMESTAMP_WITH_LOCAL_TIME_ZONE NOT NULL
datetime_result TIMESTAMP NOT NULL
!type

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT
  TIMESTAMP_TRUNC(TIMESTAMP "2008-12-25 15:30:00+00", DAY, "UTC") AS utc,
  TIMESTAMP_TRUNC(TIMESTAMP "2008-12-25 15:30:00+00", DAY, "America/Los_Angeles") AS la;
+-------------------------+-----------------=-------+
| utc                     | la                      |
+-------------------------+-------------------------+
| 2008-12-25 00:00:00 UTC | 2008-12-25 08:00:00 UTC |
+-------------------------+-------------------------+
!ok
!}

# In the following example, timestamp_expression has a time zone
# offset of +12. The first column shows the timestamp_expression in
# UTC time. The second column shows the output of TIMESTAMP_TRUNC
# using weeks that start on Monday. Because the timestamp_expression
# falls on a Sunday in UTC, TIMESTAMP_TRUNC truncates it to the
# preceding Monday. The third column shows the same function with the
# optional Time zone definition argument 'Pacific/Auckland'. Here the
# function truncates the timestamp_expression using New Zealand
# Daylight Time, where it falls on a Monday.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT
  timestamp_value AS timestamp_value,
  TIMESTAMP_TRUNC(timestamp_value, WEEK(MONDAY), "UTC") AS utc_truncated,
  TIMESTAMP_TRUNC(timestamp_value, WEEK(MONDAY), "Pacific/Auckland") AS nzdt_truncated
FROM (SELECT TIMESTAMP("2017-11-06 00:00:00+12") AS timestamp_value);
+-------------------------+-------------------------+-------------------------+
| timestamp_value         | utc_truncated           | nzdt_truncated          |
+-------------------------+-------------------------+-------------------------+
| 2017-11-05 12:00:00 UTC | 2017-10-30 00:00:00 UTC | 2017-11-05 11:00:00 UTC |
+-------------------------+-------------------------+-------------------------+
!ok
!}

# In the following example, the original timestamp_expression is in
# the Gregorian calendar year 2015. However, TIMESTAMP_TRUNC with the
# ISOYEAR date part truncates the timestamp_expression to the
# beginning of the ISO year, not the Gregorian calendar year. The
# first Thursday of the 2015 calendar year was 2015-01-01, so the ISO
# year 2015 begins on the preceding Monday, 2014-12-29. Therefore the
# ISO year boundary preceding the timestamp_expression 2015-06-15
# 00:00:00+00 is 2014-12-29.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
!if (false) {
SELECT
  TIMESTAMP_TRUNC("2015-06-15 00:00:00+00", ISOYEAR) AS isoyear_boundary,
  EXTRACT(ISOYEAR FROM TIMESTAMP "2015-06-15 00:00:00+00") AS isoyear_number;
+-------------------------+----------------+
| isoyear_boundary        | isoyear_number |
+-------------------------+----------------+
| 2014-12-29 00:00:00 UTC | 2015           |
+-------------------------+----------------+
!ok
!}

#####################################################################
# LAST_DAY
#
# LAST_DAY(datetime_expression[, date_part])
#
# Returns the last day from a datetime expression that contains the
# date. This is commonly used to return the last day of the month.
#
# You can optionally specify the date part for which the last day is
# returned. If this parameter is not used, the default value is
# MONTH. LAST_DAY supports the following values for date_part:
#
#   YEAR
#   QUARTER
#   MONTH
#   WEEK. Equivalent to 7 DAYs.
#   WEEK(<WEEKDAY>). <WEEKDAY> represents the starting day of the
#     week. Valid values are SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
#     THURSDAY, FRIDAY, and SATURDAY.
#   ISOWEEK. Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
#   ISOYEAR. Uses the ISO 8601 week-numbering year boundary. The ISO
#     year boundary is the Monday of the first week whose Thursday
#     belongs to the corresponding Gregorian calendar year.
#
# Returns DATE
#
# These both return the last day of the month:

!if (false) {
SELECT LAST_DAY(DATETIME '2008-11-25', MONTH) AS last_day;
+------------+
| last_day   |
+------------+
| 2008-11-30 |
+------------+
!ok
!}

!if (false) {
SELECT LAST_DAY(DATETIME '2008-11-25') AS last_day;
+------------+
| last_day   |
+------------+
| 2008-11-30 |
+------------+
!ok
!}

# This returns the last day of the year:
!if (false) {
SELECT LAST_DAY(DATETIME '2008-11-25 15:30:00', YEAR) AS last_day;
+------------+
| last_day   |
+------------+
| 2008-12-31 |
+------------+
!ok
!}

# This returns the last day of the week for a week that starts on a
# Sunday:
!if (false) {
SELECT LAST_DAY(DATETIME '2008-11-10 15:30:00', WEEK(SUNDAY)) AS last_day;
+------------+
| last_day   |
+------------+
| 2008-11-15 |
+------------+
!ok
!}

# This returns the last day of the week for a week that starts on a
# Monday:
!if (false) {
SELECT LAST_DAY(DATETIME '2008-11-10 15:30:00', WEEK(MONDAY)) AS last_day;
+------------+
| last_day   |
+------------+
| 2008-11-16 |
+------------+
!ok
!}

#####################################################################
#
# IFNULL(value1, value2)
#
# Returns value1 if not NULL, else value2
#
WITH items AS (
  SELECT 'IFNULL(null, 5)' question, IFNULL(null, 5) AS answer UNION ALL
  SELECT 'IFNULL(2, 1)', IFNULL(2, 1) UNION ALL
  SELECT "IFNULL('b', null)", IFNULL('b', null) UNION ALL
  SELECT 'IFNULL(null, null)', IFNULL(null, null)
)
SELECT * FROM items;
+--------------------+--------+
| question           | answer |
+--------------------+--------+
| IFNULL(null, 5)    | 5      |
| IFNULL(2, 1)       | 2      |
| IFNULL('b', null)  | b      |
| IFNULL(null, null) |        |
+--------------------+--------+
(4 rows)

!ok

#####################################################################
# FORMAT_DATE
#
# FORMAT_DATE(format_string, date_expr)
#
# Formats the date_expr according to the specified format_string.
#
# See Supported Format Elements For DATE for a list of format elements
# that this function supports.
#
# Returns STRING

SELECT FORMAT_DATE("%x", DATE "2008-12-25") AS US_format;
+-----------+
| US_format |
+-----------+
| 12/25/08  |
+-----------+
(1 row)

!ok

SELECT FORMAT_DATE("%b-%d-%Y", DATE "2008-12-25") AS formatted;
+-------------+
| formatted   |
+-------------+
| Dec-25-2008 |
+-------------+
(1 row)

!ok

SELECT FORMAT_DATE("%b %Y", DATE "2008-12-25") AS formatted;
+-----------+
| formatted |
+-----------+
| Dec 2008  |
+-----------+
(1 row)

!ok

#####################################################################
# FORMAT_DATETIME
#
# FORMAT_DATETIME(format_string, datetime_expression)
# Formats a DATETIME object according to the specified
# format_string. See Supported Format Elements For DATETIME for a list
# of format elements that this function supports.
#
# Returns STRING

SELECT
  FORMAT_DATETIME("%c", DATETIME "2008-12-25 15:30:00")
  AS formatted;
+--------------------------+
| formatted                |
+--------------------------+
| Thu Dec 25 15:30:00 2008 |
+--------------------------+
(1 row)

!ok

SELECT
  FORMAT_DATETIME("%b-%d-%Y", DATETIME "2008-12-25 15:30:00")
  AS formatted;
+-------------+
| formatted   |
+-------------+
| Dec-25-2008 |
+-------------+
(1 row)

!ok

SELECT
  FORMAT_DATETIME("%b %Y", DATETIME "2008-12-25 15:30:00")
  AS formatted;
+-----------+
| formatted |
+-----------+
| Dec 2008  |
+-----------+
(1 row)

!ok

#####################################################################
# FORMAT_TIME
#
# FORMAT_TIME(format_string, time_object)
#
# Formats a TIME object according to the specified format_string. See
# Supported Format Elements For TIME for a list of format elements
# that this function supports.
#
# Returns STRING

SELECT FORMAT_TIME("%R", TIME "15:30:00") as formatted_time;
+----------------+
| formatted_time |
+----------------+
| 15:30          |
+----------------+
(1 row)

!ok

#####################################################################
# FORMAT_TIMESTAMP
#
# FORMAT_TIMESTAMP(format_string, timestamp[, time_zone])
#
#
# Formats a timestamp according to the specified format_string.
#
# See Supported Format Elements For TIMESTAMP for a list of format
# elements that this function supports.

SELECT FORMAT_TIMESTAMP("%c", TIMESTAMP "2008-12-25 15:30:00" /* TODO should be "2008-12-25 15:30:00+00" */, "UTC") AS formatted;
+--------------------------+
| formatted                |
+--------------------------+
| Thu Dec 25 15:30:00 2008 |
+--------------------------+
(1 row)

!ok

SELECT FORMAT_TIMESTAMP("%b-%d-%Y", TIMESTAMP "2008-12-25 15:30:00" /* TODO should be "2008-12-25 15:30:00+00" */) AS formatted;
+-------------+
| formatted   |
+-------------+
| Dec-25-2008 |
+-------------+
(1 row)

!ok

SELECT FORMAT_TIMESTAMP("%b %Y", TIMESTAMP "2008-12-25 15:30:00" /* TODO should be "2008-12-25 15:30:00+00" */)
  AS formatted;
+-----------+
| formatted |
+-----------+
| Dec 2008  |
+-----------+
(1 row)

!ok

#####################################################################
# PARSE_DATE
#
# PARSE_DATE(format_string, date_string)
#
# Converts a string representation of date to a DATE object.
#
# format_string contains the format elements that define how
# date_string is formatted. Each element in date_string must have a
# corresponding element in format_string. The location of each element
# in format_string must match the location of each element in
# date_string.

# This works because elements on both sides match.
SELECT PARSE_DATE("%A %b %e %Y", "Thursday Dec 25 2008");
+------------+
| EXPR$0     |
+------------+
| 2008-12-25 |
+------------+
(1 row)

!ok

# This doesn't work because the year element is in different locations.
SELECT PARSE_DATE("%Y %A %b %e", "Thursday Dec 25 2008");
Invalid format: '%Y %A %b %e' for datetime string: 'Thursday Dec 25 2008'
!error

# This doesn't work because one of the year elements is missing.
SELECT PARSE_DATE("%A %b %e", "Thursday Dec 25 2008");
Invalid format: '%A %b %e' for datetime string: 'Thursday Dec 25 2008'
!error

# This works because %F can find all matching elements in date_string.
SELECT PARSE_DATE("%F", "2000-12-30");
+------------+
| EXPR$0     |
+------------+
| 2000-12-30 |
+------------+
(1 row)

!ok

# When using PARSE_DATE, keep the following in mind:
#
# Unspecified fields. Any unspecified field is initialized from
#   1970-01-01.
# Case insensitivity. Names, such as Monday, February, and so on, are
#   case insensitive.
# Whitespace. One or more consecutive white spaces in the format
#   string matches zero or more consecutive white spaces in the date
#   string. In addition, leading and trailing white spaces in the date
#   string are always allowed -- even if they are not in the format
#   string.
# Format precedence. When two (or more) format elements have
#   overlapping information (for example both %F and %Y affect the
#   year), the last one generally overrides any earlier ones.
#
# Returns DATE

# This example converts a MM/DD/YY formatted string to a DATE object:

SELECT PARSE_DATE("%x", "12/25/08") AS parsed;
+------------+
| parsed     |
+------------+
| 2008-12-25 |
+------------+
(1 row)

!ok

# This example converts a YYYYMMDD formatted string to a DATE object:

SELECT PARSE_DATE("%Y%m%d", "20081225") AS parsed;
+------------+
| parsed     |
+------------+
| 2008-12-25 |
+------------+
(1 row)

!ok

#####################################################################
# PARSE_DATETIME
#
# PARSE_DATETIME(format_string, datetime_string)
#
# Converts a string representation of a datetime to a DATETIME object.
#
# format_string contains the format elements that define how
# datetime_string is formatted. Each element in datetime_string must
# have a corresponding element in format_string. The location of each
# element in format_string must match the location of each element in
# datetime_string.

# This works because elements on both sides match.
SELECT PARSE_DATETIME("%a %b %e %I:%M:%S %Y", "Thu Dec 25 07:30:00 2008");
+---------------------+
| EXPR$0              |
+---------------------+
| 2008-12-25 07:30:00 |
+---------------------+
(1 row)

!ok


# This doesn't work because the year element is in different locations.
SELECT PARSE_DATETIME("%a %b %e %Y %I:%M:%S", "Thu Dec 25 07:30:00 2008");
Invalid format: '%a %b %e %Y %I:%M:%S' for datetime string: 'Thu Dec 25 07:30:00 2008'
!error

# This doesn't work because one of the year elements is missing.
SELECT PARSE_DATETIME("%a %b %e %I:%M:%S", "Thu Dec 25 07:30:00 2008");
Invalid format: '%a %b %e %I:%M:%S' for datetime string: 'Thu Dec 25 07:30:00 2008'
!error


# This works because %c can find all matching elements in datetime_string.
SELECT PARSE_DATETIME("%c", "Thu Dec 25 07:30:00 2008");
+---------------------+
| EXPR$0              |
+---------------------+
| 2008-12-25 07:30:00 |
+---------------------+
(1 row)

!ok

# The format string fully supports most format elements, except for %P.
#
# PARSE_DATETIME parses string according to the following rules:
#   Unspecified fields. Any unspecified field is initialized from
#     1970-01-01 00:00:00.0. For example, if the year is unspecified
#     then it defaults to 1970.
#   Case insensitivity. Names, such as Monday and February, are case
#     insensitive.
#   Whitespace. One or more consecutive white spaces in the format
#     string matches zero or more consecutive white spaces in the
#     DATETIME string. Leading and trailing white spaces in the
#     DATETIME string are always allowed, even if they are not in the
#     format string.
#   Format precedence. When two or more format elements have
#     overlapping information, the last one generally overrides any
#     earlier ones, with some exceptions. For example, both %F and %Y
#     affect the year, so the earlier element overrides the later. See
#     the descriptions of %s, %C, and %y in Supported Format Elements
#     For DATETIME.
#   Format divergence. %p can be used with am, AM, pm, and PM.
#
# Returns DATETIME

# The following examples parse a STRING literal as a DATETIME.

SELECT PARSE_DATETIME('%Y-%m-%d %H:%M:%S', '1998-10-18 13:45:55') AS dt;
+---------------------+
| dt                  |
+---------------------+
| 1998-10-18 13:45:55 |
+---------------------+
(1 row)

!ok

SELECT PARSE_DATETIME('%m/%d/%Y %I:%M:%S %p', '8/30/2018 2:23:38 pm') AS dt;
+---------------------+
| dt                  |
+---------------------+
| 2018-08-30 14:23:38 |
+---------------------+
(1 row)

!ok

# The following example parses a STRING literal containing a date in a
# natural language format as a DATETIME.

SELECT PARSE_DATETIME('%A, %B %e, %Y','Wednesday, December 19, 2018')
  AS dt;
+---------------------+
| dt                  |
+---------------------+
| 2018-12-19 00:00:00 |
+---------------------+
(1 row)

!ok

#####################################################################
# PARSE_TIME
#
# PARSE_TIME(format_string, time_string)
#
# Converts a string representation of time to a TIME object.
#
# format_string contains the format elements that define how
# time_string is formatted. Each element in time_string must have a
# corresponding element in format_string. The location of each element
# in format_string must match the location of each element in
# time_string.
#

# This works because elements on both sides match.
SELECT PARSE_TIME("%I:%M:%S", "07:30:00");
+----------+
| EXPR$0   |
+----------+
| 07:30:00 |
+----------+
(1 row)

!ok

# TODO: validate for format element ordering
!if (false) {
# This doesn't work because the seconds element is in different locations.
SELECT PARSE_TIME("%S:%I:%M", "07:30:00");
!error
!}

# This doesn't work because one of the seconds elements is missing.
SELECT PARSE_TIME("%I:%M", "07:30:00");
Invalid format: '%I:%M' for datetime string: '07:30:00'
!error


# This works because %T can find all matching elements in time_string.
SELECT PARSE_TIME("%T", "07:30:00");
+----------+
| EXPR$0   |
+----------+
| 07:30:00 |
+----------+
(1 row)

!ok


# The format string fully supports most format elements except for %P.
#
# When using PARSE_TIME, keep the following in mind:
#   Unspecified fields. Any unspecified field is initialized from
#     00:00:00.0. For instance, if seconds is unspecified then it
#     defaults to 00, and so on.
#   Whitespace. One or more consecutive white spaces in the format
#     string matches zero or more consecutive white spaces in the TIME
#     string. In addition, leading and trailing white spaces in the
#     TIME string are always allowed, even if they are not in the
#     format string.
#   Format precedence. When two (or more) format elements have
#     overlapping information, the last one generally overrides any
#     earlier ones.
#   Format divergence. %p can be used with am, AM, pm, and PM.
#
# Returns TIME

SELECT PARSE_TIME("%H", "15") as parsed_time;
+-------------+
| parsed_time |
+-------------+
| 15:00:00    |
+-------------+
(1 row)

!ok

SELECT PARSE_TIME('%I:%M:%S %p', '2:23:38 pm') AS parsed_time;
+-------------+
| parsed_time |
+-------------+
| 14:23:38    |
+-------------+
(1 row)

!ok


#####################################################################
# PARSE_TIMESTAMP
#
# PARSE_TIMESTAMP(format_string, timestamp_string[, time_zone])
#
# Converts a string representation of a timestamp to a TIMESTAMP
# object.
#
# format_string contains the format elements that define how
# timestamp_string is formatted. Each element in timestamp_string must
# have a corresponding element in format_string. The location of each
# element in format_string must match the location of each element in
# timestamp_string.

# This works because elements on both sides match.
SELECT PARSE_TIMESTAMP("%a %b %e %I:%M:%S %Y", "Thu Dec 25 07:30:00 2008");
+---------------------+
| EXPR$0              |
+---------------------+
| 2008-12-25 07:30:00 |
+---------------------+
(1 row)

!ok

# This doesn't work because the year element is in different locations.
SELECT PARSE_TIMESTAMP("%a %b %e %Y %I:%M:%S", "Thu Dec 25 07:30:00 2008");
Invalid format: '%a %b %e %Y %I:%M:%S' for datetime string: 'Thu Dec 25 07:30:00 2008'
!error

# This doesn't work because one of the year elements is missing.
SELECT PARSE_TIMESTAMP("%a %b %e %I:%M:%S", "Thu Dec 25 07:30:00 2008");
Invalid format: '%a %b %e %I:%M:%S' for datetime string: 'Thu Dec 25 07:30:00 2008'
!error

# This works because %c can find all matching elements in timestamp_string.
SELECT PARSE_TIMESTAMP("%c", "Thu Dec 25 07:30:00 2008");
+---------------------+
| EXPR$0              |
+---------------------+
| 2008-12-25 07:30:00 |
+---------------------+
(1 row)

!ok

# The format string fully supports most format elements, except for %P.
#
# When using PARSE_TIMESTAMP, keep the following in mind:
#   Unspecified fields. Any unspecified field is initialized from
#     1970-01-01 00:00:00.0. This initialization value uses the time
#     zone specified by the function's time zone argument, if
#     present. If not, the initialization value uses the default time
#     zone, UTC. For instance, if the year is unspecified then it
#     defaults to 1970, and so on.
#   Case insensitivity. Names, such as Monday, February, and so on,
#     are case insensitive.
#   Whitespace. One or more consecutive white spaces in the format
#     string matches zero or more consecutive white spaces in the
#     timestamp string. In addition, leading and trailing white spaces
#     in the timestamp string are always allowed, even if they are not
#     in the format string.
#   Format precedence. When two (or more) format elements have
#     overlapping information (for example both %F and %Y affect the
#     year), the last one generally overrides any earlier ones, with
#     some exceptions (see the descriptions of %s, %C, and %y).
#   Format divergence. %p can be used with am, AM, pm, and PM.

# Display of results may differ, depending upon the environment and
# time zone where this query was executed.
#
# After [CALCITE-5446] is fixed, this and other TIMESTAMP WITH LOCAL TIME
# values will end in UTC, like this: 2008-12-25 15:30:00 UTC.
#
SELECT PARSE_TIMESTAMP("%c", "Thu Dec 25 07:30:00 2008") AS parsed;
+---------------------+
| parsed              |
+---------------------+
| 2008-12-25 07:30:00 |
+---------------------+
(1 row)

!ok

#####################################################################
# STRING and BYTES functions ########################################

#####################################################################
# ENDS_WITH(value1, value2)
#
# Takes two STRING or BYTES values. Returns TRUE if the second
# value is a suffix of the first.
#
# This function supports specifying collation.
WITH items AS (
  SELECT '1234' as item UNION ALL
  SELECT '123' UNION ALL
  SELECT '' UNION ALL
  SELECT NULL
)
SELECT
  item, ENDS_WITH(item, '34') as example
FROM items;
+------+---------+
| item | example |
+------+---------+
|      | false   |
| 123  | false   |
| 1234 | true    |
|      |         |
+------+---------+
(4 rows)

!ok

#####################################################################
# STARTS_WITH(value1, value2)
#
# Takes two STRING or BYTES values. Returns TRUE if the second
# value is a prefix of the first.
#
# This function supports specifying collation.
WITH items AS (
  SELECT 'foo' as item UNION ALL
  SELECT 'bar' UNION ALL
  SELECT 'baz' UNION ALL
  SELECT NULL
)
SELECT
  item, STARTS_WITH(item, 'b') as example
FROM items;
+------+---------+
| item | example |
+------+---------+
| bar  | true    |
| baz  | true    |
| foo  | false   |
|      |         |
+------+---------+
(4 rows)

!ok


# End big-query.iq
